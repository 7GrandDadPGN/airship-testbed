/* eslint-disable */

/*
* Types generated by Unity.
*
* DO NOT EDIT!
*/

declare const enum HideFlags {
    None = 0,
    HideInHierarchy = 1,
    HideInInspector = 2,
    DontSaveInEditor = 4,
    NotEditable = 8,
    DontSaveInBuild = 16,
    DontUnloadUnusedAsset = 32,
    DontSave = 52,
    HideAndDontSave = 61,
}
declare const enum FindObjectsInactive {
    Exclude = 0,
    Include = 1,
}
declare const enum FindObjectsSortMode {
    None = 0,
    InstanceID = 1,
}
declare const enum Space {
    World = 0,
    Self = 1,
}
declare const enum SendMessageOptions {
    RequireReceiver = 0,
    DontRequireReceiver = 1,
}
declare const enum PrimitiveType {
    Sphere = 0,
    Capsule = 1,
    Cylinder = 2,
    Cube = 3,
    Plane = 4,
    Quad = 5,
}
declare const enum RigidbodyConstraints {
    None = 0,
    FreezePositionX = 2,
    FreezePositionY = 4,
    FreezePositionZ = 8,
    FreezePosition = 14,
    FreezeRotationX = 16,
    FreezeRotationY = 32,
    FreezeRotationZ = 64,
    FreezeRotation = 112,
    FreezeAll = 126,
}
declare const enum CollisionDetectionMode {
    Discrete = 0,
    Continuous = 1,
    ContinuousDynamic = 2,
    ContinuousSpeculative = 3,
}
declare const enum RigidbodyInterpolation {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum ForceMode {
    Force = 0,
    Impulse = 1,
    VelocityChange = 2,
    Acceleration = 5,
}
declare const enum QueryTriggerInteraction {
    UseGlobal = 0,
    Ignore = 1,
    Collide = 2,
}
declare const enum ArticulationJointType {
    FixedJoint = 0,
    PrismaticJoint = 1,
    RevoluteJoint = 2,
    SphericalJoint = 3,
}
declare const enum ArticulationDofLock {
    LockedMotion = 0,
    LimitedMotion = 1,
    FreeMotion = 2,
}
declare const enum ArticulationDriveType {
    Force = 0,
    Acceleration = 1,
    Target = 2,
    Velocity = 3,
}
declare const enum ArticulationDriveAxis {
    X = 0,
    Y = 1,
    Z = 2,
}
declare const enum GeometryType {
    Sphere = 0,
    Capsule = 2,
    Box = 3,
    ConvexMesh = 4,
    TriangleMesh = 5,
    Terrain = 6,
    Invalid = -1,
}
declare const enum PhysicMaterialCombine {
    Average = 0,
    Multiply = 1,
    Minimum = 2,
    Maximum = 3,
}
declare const enum SimulationMode {
    FixedUpdate = 0,
    Update = 1,
    Script = 2,
}
declare const enum SimulationStage {
    None = 0,
    PrepareSimulation = 1,
    RunSimulation = 2,
    PublishSimulationResults = 4,
    All = 7,
}
declare const enum SimulationOption {
    None = 0,
    SyncTransforms = 1,
    IgnoreEmptyScenes = 2,
    All = 3,
}
declare const enum MeshColliderCookingOptions {
    None = 0,
    InflateConvexMesh = 1,
    CookForFasterSimulation = 2,
    EnableMeshCleaning = 4,
    WeldColocatedVertices = 8,
    UseFastMidphase = 16,
}
declare const enum CompositeOperation {
    None = 0,
    Merge = 1,
    Intersect = 2,
    Difference = 3,
    Flip = 4,
}
declare const enum GeometryType {
    Outlines = 0,
    Polygons = 1,
}
declare const enum GenerationType {
    Synchronous = 0,
    Manual = 1,
}
declare const enum RigidbodyType2D {
    Dynamic = 0,
    Kinematic = 1,
    Static = 2,
}
declare const enum RigidbodyConstraints2D {
    None = 0,
    FreezePositionX = 1,
    FreezePositionY = 2,
    FreezePosition = 3,
    FreezeRotation = 4,
    FreezeAll = 7,
}
declare const enum RigidbodyInterpolation2D {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum RigidbodySleepMode2D {
    NeverSleep = 0,
    StartAwake = 1,
    StartAsleep = 2,
}
declare const enum CollisionDetectionMode2D {
    None = 0,
    Discrete = 0,
    Continuous = 1,
}
declare const enum ForceMode2D {
    Force = 0,
    Impulse = 1,
}
declare const enum PhysicsShapeType2D {
    Circle = 0,
    Capsule = 1,
    Polygon = 2,
    Edges = 3,
}
declare const enum ColliderErrorState2D {
    None = 0,
    NoShapes = 1,
    RemovedShapes = 2,
}
declare const enum IndexFormat {
    UInt16 = 0,
    UInt32 = 1,
}
declare const enum Target {
    Vertex = 1,
    Index = 2,
    CopySource = 4,
    CopyDestination = 8,
    Structured = 16,
    Raw = 32,
    Append = 64,
    Counter = 128,
    IndirectArguments = 256,
    Constant = 512,
}
declare const enum SkinWeights {
    None = 0,
    OneBone = 1,
    TwoBones = 2,
    FourBones = 4,
    Unlimited = 255,
}
declare const enum UsageFlags {
    None = 0,
    LockBufferForWrite = 1,
}
declare const enum BlendShapeBufferLayout {
    PerShape = 0,
    PerVertex = 1,
}
declare const enum MeshTopology {
    Triangles = 0,
    Quads = 2,
    Lines = 3,
    LineStrip = 4,
    Points = 5,
}
declare const enum VertexAttribute {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    TexCoord0 = 4,
    TexCoord1 = 5,
    TexCoord2 = 6,
    TexCoord3 = 7,
    TexCoord4 = 8,
    TexCoord5 = 9,
    TexCoord6 = 10,
    TexCoord7 = 11,
    BlendWeight = 12,
    BlendIndices = 13,
}
declare const enum VertexAttributeFormat {
    Float32 = 0,
    Float16 = 1,
    UNorm8 = 2,
    SNorm8 = 3,
    UNorm16 = 4,
    SNorm16 = 5,
    UInt8 = 6,
    SInt8 = 7,
    UInt16 = 8,
    SInt16 = 9,
    UInt32 = 10,
    SInt32 = 11,
}
declare const enum MeshUpdateFlags {
    Default = 0,
    DontValidateIndices = 1,
    DontResetBoneBounds = 2,
    DontNotifyMeshUsers = 4,
    DontRecalculateBounds = 8,
}
declare const enum CapsuleDirection2D {
    Vertical = 0,
    Horizontal = 1,
}
declare const enum SimulationMode2D {
    FixedUpdate = 0,
    Update = 1,
    Script = 2,
}
declare const enum LogType {
    Error = 0,
    Assert = 1,
    Warning = 2,
    Log = 3,
    Exception = 4,
}
declare const enum LogOption {
    None = 0,
    NoStacktrace = 1,
}
declare const enum GraphicsFormat {
    None = 0,
    R8_SRGB = 1,
    R8G8_SRGB = 2,
    R8G8B8_SRGB = 3,
    R8G8B8A8_SRGB = 4,
    R8_UNorm = 5,
    R8G8_UNorm = 6,
    R8G8B8_UNorm = 7,
    R8G8B8A8_UNorm = 8,
    R8_SNorm = 9,
    R8G8_SNorm = 10,
    R8G8B8_SNorm = 11,
    R8G8B8A8_SNorm = 12,
    R8_UInt = 13,
    R8G8_UInt = 14,
    R8G8B8_UInt = 15,
    R8G8B8A8_UInt = 16,
    R8_SInt = 17,
    R8G8_SInt = 18,
    R8G8B8_SInt = 19,
    R8G8B8A8_SInt = 20,
    R16_UNorm = 21,
    R16G16_UNorm = 22,
    R16G16B16_UNorm = 23,
    R16G16B16A16_UNorm = 24,
    R16_SNorm = 25,
    R16G16_SNorm = 26,
    R16G16B16_SNorm = 27,
    R16G16B16A16_SNorm = 28,
    R16_UInt = 29,
    R16G16_UInt = 30,
    R16G16B16_UInt = 31,
    R16G16B16A16_UInt = 32,
    R16_SInt = 33,
    R16G16_SInt = 34,
    R16G16B16_SInt = 35,
    R16G16B16A16_SInt = 36,
    R32_UInt = 37,
    R32G32_UInt = 38,
    R32G32B32_UInt = 39,
    R32G32B32A32_UInt = 40,
    R32_SInt = 41,
    R32G32_SInt = 42,
    R32G32B32_SInt = 43,
    R32G32B32A32_SInt = 44,
    R16_SFloat = 45,
    R16G16_SFloat = 46,
    R16G16B16_SFloat = 47,
    R16G16B16A16_SFloat = 48,
    R32_SFloat = 49,
    R32G32_SFloat = 50,
    R32G32B32_SFloat = 51,
    R32G32B32A32_SFloat = 52,
    B8G8R8_SRGB = 56,
    B8G8R8A8_SRGB = 57,
    B8G8R8_UNorm = 58,
    B8G8R8A8_UNorm = 59,
    B8G8R8_SNorm = 60,
    B8G8R8A8_SNorm = 61,
    B8G8R8_UInt = 62,
    B8G8R8A8_UInt = 63,
    B8G8R8_SInt = 64,
    B8G8R8A8_SInt = 65,
    R4G4B4A4_UNormPack16 = 66,
    B4G4R4A4_UNormPack16 = 67,
    R5G6B5_UNormPack16 = 68,
    B5G6R5_UNormPack16 = 69,
    R5G5B5A1_UNormPack16 = 70,
    B5G5R5A1_UNormPack16 = 71,
    A1R5G5B5_UNormPack16 = 72,
    E5B9G9R9_UFloatPack32 = 73,
    B10G11R11_UFloatPack32 = 74,
    A2B10G10R10_UNormPack32 = 75,
    A2B10G10R10_UIntPack32 = 76,
    A2B10G10R10_SIntPack32 = 77,
    A2R10G10B10_UNormPack32 = 78,
    A2R10G10B10_UIntPack32 = 79,
    A2R10G10B10_SIntPack32 = 80,
    A2R10G10B10_XRSRGBPack32 = 81,
    A2R10G10B10_XRUNormPack32 = 82,
    R10G10B10_XRSRGBPack32 = 83,
    R10G10B10_XRUNormPack32 = 84,
    A10R10G10B10_XRSRGBPack32 = 85,
    A10R10G10B10_XRUNormPack32 = 86,
    D16_UNorm = 90,
    D24_UNorm = 91,
    D24_UNorm_S8_UInt = 92,
    D32_SFloat = 93,
    D32_SFloat_S8_UInt = 94,
    S8_UInt = 95,
    RGB_DXT1_SRGB = 96,
    RGBA_DXT1_SRGB = 96,
    RGB_DXT1_UNorm = 97,
    RGBA_DXT1_UNorm = 97,
    RGBA_DXT3_SRGB = 98,
    RGBA_DXT3_UNorm = 99,
    RGBA_DXT5_SRGB = 100,
    RGBA_DXT5_UNorm = 101,
    R_BC4_UNorm = 102,
    R_BC4_SNorm = 103,
    RG_BC5_UNorm = 104,
    RG_BC5_SNorm = 105,
    RGB_BC6H_UFloat = 106,
    RGB_BC6H_SFloat = 107,
    RGBA_BC7_SRGB = 108,
    RGBA_BC7_UNorm = 109,
    RGB_PVRTC_2Bpp_SRGB = 110,
    RGB_PVRTC_2Bpp_UNorm = 111,
    RGB_PVRTC_4Bpp_SRGB = 112,
    RGB_PVRTC_4Bpp_UNorm = 113,
    RGBA_PVRTC_2Bpp_SRGB = 114,
    RGBA_PVRTC_2Bpp_UNorm = 115,
    RGBA_PVRTC_4Bpp_SRGB = 116,
    RGBA_PVRTC_4Bpp_UNorm = 117,
    RGB_ETC_UNorm = 118,
    RGB_ETC2_SRGB = 119,
    RGB_ETC2_UNorm = 120,
    RGB_A1_ETC2_SRGB = 121,
    RGB_A1_ETC2_UNorm = 122,
    RGBA_ETC2_SRGB = 123,
    RGBA_ETC2_UNorm = 124,
    R_EAC_UNorm = 125,
    R_EAC_SNorm = 126,
    RG_EAC_UNorm = 127,
    RG_EAC_SNorm = 128,
    RGBA_ASTC4X4_SRGB = 129,
    RGBA_ASTC4X4_UNorm = 130,
    RGBA_ASTC5X5_SRGB = 131,
    RGBA_ASTC5X5_UNorm = 132,
    RGBA_ASTC6X6_SRGB = 133,
    RGBA_ASTC6X6_UNorm = 134,
    RGBA_ASTC8X8_SRGB = 135,
    RGBA_ASTC8X8_UNorm = 136,
    RGBA_ASTC10X10_SRGB = 137,
    RGBA_ASTC10X10_UNorm = 138,
    RGBA_ASTC12X12_SRGB = 139,
    RGBA_ASTC12X12_UNorm = 140,
    YUV2 = 141,
    DepthAuto = 142,
    ShadowAuto = 143,
    VideoAuto = 144,
    RGBA_ASTC4X4_UFloat = 145,
    RGBA_ASTC5X5_UFloat = 146,
    RGBA_ASTC6X6_UFloat = 147,
    RGBA_ASTC8X8_UFloat = 148,
    RGBA_ASTC10X10_UFloat = 149,
    RGBA_ASTC12X12_UFloat = 150,
    D16_UNorm_S8_UInt = 151,
}
declare const enum TextureDimension {
    None = 0,
    Any = 1,
    Tex2D = 2,
    Tex3D = 3,
    Cube = 4,
    Tex2DArray = 5,
    CubeArray = 6,
    Unknown = -1,
}
declare const enum TextureWrapMode {
    Repeat = 0,
    Clamp = 1,
    Mirror = 2,
    MirrorOnce = 3,
}
declare const enum FilterMode {
    Point = 0,
    Bilinear = 1,
    Trilinear = 2,
}
declare const enum GraphicsTextureDescriptorFlags {
    None = 0,
    RenderTarget = 1,
    RandomWriteTarget = 2,
}
declare const enum GraphicsTextureState {
    Constructed = 0,
    Initializing = 1,
    InitializedOnRenderThread = 2,
    DestroyQueued = 3,
    Destroyed = 4,
}
declare const enum AnisotropicFiltering {
    Disable = 0,
    Enable = 1,
    ForceEnable = 2,
}
declare const enum TextureFormat {
    Alpha8 = 1,
    ARGB4444 = 2,
    RGB24 = 3,
    RGBA32 = 4,
    ARGB32 = 5,
    RGB565 = 7,
    R16 = 9,
    DXT1 = 10,
    DXT5 = 12,
    RGBA4444 = 13,
    BGRA32 = 14,
    RHalf = 15,
    RGHalf = 16,
    RGBAHalf = 17,
    RFloat = 18,
    RGFloat = 19,
    RGBAFloat = 20,
    YUY2 = 21,
    RGB9e5Float = 22,
    BC6H = 24,
    BC7 = 25,
    BC4 = 26,
    BC5 = 27,
    DXT1Crunched = 28,
    DXT5Crunched = 29,
    PVRTC_RGB2 = 30,
    PVRTC_RGBA2 = 31,
    PVRTC_RGB4 = 32,
    PVRTC_RGBA4 = 33,
    ETC_RGB4 = 34,
    EAC_R = 41,
    EAC_R_SIGNED = 42,
    EAC_RG = 43,
    EAC_RG_SIGNED = 44,
    ETC2_RGB = 45,
    ETC2_RGBA1 = 46,
    ETC2_RGBA8 = 47,
    ASTC_4x4 = 48,
    ASTC_5x5 = 49,
    ASTC_6x6 = 50,
    ASTC_8x8 = 51,
    ASTC_10x10 = 52,
    ASTC_12x12 = 53,
    RG16 = 62,
    R8 = 63,
    ETC_RGB4Crunched = 64,
    ETC2_RGBA8Crunched = 65,
    ASTC_HDR_4x4 = 66,
    ASTC_HDR_5x5 = 67,
    ASTC_HDR_6x6 = 68,
    ASTC_HDR_8x8 = 69,
    ASTC_HDR_10x10 = 70,
    ASTC_HDR_12x12 = 71,
    RG32 = 72,
    RGB48 = 73,
    RGBA64 = 74,
    R8_SIGNED = 75,
    RG16_SIGNED = 76,
    RGB24_SIGNED = 77,
    RGBA32_SIGNED = 78,
    R16_SIGNED = 79,
    RG32_SIGNED = 80,
    RGB48_SIGNED = 81,
    RGBA64_SIGNED = 82,
    ETC_RGBA8_3DS = -61,
    ETC_RGB4_3DS = -60,
    ASTC_RGBA_12x12 = -59,
    ASTC_RGBA_10x10 = -58,
    ASTC_RGBA_8x8 = -57,
    ASTC_RGBA_6x6 = -56,
    ASTC_RGBA_5x5 = -55,
    ASTC_RGBA_4x4 = -54,
    ASTC_RGB_12x12 = -53,
    ASTC_RGB_10x10 = -52,
    ASTC_RGB_8x8 = -51,
    ASTC_RGB_6x6 = -50,
    ASTC_RGB_5x5 = -49,
    ASTC_RGB_4x4 = -48,
}
declare const enum SpritePackingMode {
    Tight = 0,
    Rectangle = 1,
}
declare const enum SpritePackingRotation {
    None = 0,
    FlipHorizontal = 1,
    FlipVertical = 2,
    Rotate180 = 3,
    Any = 15,
}
declare const enum SpriteMeshType {
    FullRect = 0,
    Tight = 1,
}
declare const enum DefaultFormat {
    LDR = 0,
    HDR = 1,
    DepthStencil = 2,
    Shadow = 3,
    Video = 4,
}
declare const enum TextureCreationFlags {
    None = 0,
    MipChain = 1,
    DontInitializePixels = 4,
    Crunch = 64,
    DontUploadUponCreate = 1024,
    IgnoreMipmapLimit = 2048,
}
declare const enum RenderingPath {
    VertexLit = 0,
    Forward = 1,
    DeferredLighting = 2,
    DeferredShading = 3,
    UsePlayerSettings = -1,
}
declare const enum OpaqueSortMode {
    Default = 0,
    FrontToBack = 1,
    NoDistanceSort = 2,
}
declare const enum TransparencySortMode {
    Default = 0,
    Perspective = 1,
    Orthographic = 2,
    CustomAxis = 3,
}
declare const enum CameraType {
    Game = 1,
    SceneView = 2,
    Preview = 4,
    VR = 8,
    Reflection = 16,
}
declare const enum CameraClearFlags {
    Skybox = 1,
    Color = 2,
    SolidColor = 2,
    Depth = 3,
    Nothing = 4,
}
declare const enum DepthTextureMode {
    None = 0,
    Depth = 1,
    DepthNormals = 2,
    MotionVectors = 4,
}
declare const enum GateFitMode {
    None = 0,
    Vertical = 1,
    Horizontal = 2,
    Fill = 3,
    Overscan = 4,
}
declare const enum VRTextureUsage {
    None = 0,
    OneEye = 1,
    TwoEyes = 2,
    DeviceSpecific = 3,
}
declare const enum RenderTextureMemoryless {
    None = 0,
    Color = 1,
    Depth = 2,
    MSAA = 4,
}
declare const enum RenderTextureFormat {
    ARGB32 = 0,
    Depth = 1,
    ARGBHalf = 2,
    Shadowmap = 3,
    RGB565 = 4,
    ARGB4444 = 5,
    ARGB1555 = 6,
    Default = 7,
    ARGB2101010 = 8,
    DefaultHDR = 9,
    ARGB64 = 10,
    ARGBFloat = 11,
    RGFloat = 12,
    RGHalf = 13,
    RFloat = 14,
    RHalf = 15,
    R8 = 16,
    ARGBInt = 17,
    RGInt = 18,
    RInt = 19,
    BGRA32 = 20,
    RGB111110Float = 22,
    RG32 = 23,
    RGBAUShort = 24,
    RG16 = 25,
    BGRA10101010_XR = 26,
    BGR101010_XR = 27,
    R16 = 28,
}
declare const enum ShadowSamplingMode {
    CompareDepths = 0,
    RawDepth = 1,
    None = 2,
}
declare const enum RenderTextureCreationFlags {
    MipMap = 1,
    AutoGenerateMips = 2,
    SRGB = 4,
    EyeTexture = 8,
    EnableRandomWrite = 16,
    CreatedFromScript = 32,
    AllowVerticalFlip = 128,
    NoResolvedColorSurface = 256,
    DynamicallyScalable = 1024,
    BindMS = 2048,
    DynamicallyScalableExplicit = 65536,
}
declare const enum MonoOrStereoscopicEye {
    Left = 0,
    Right = 1,
    Mono = 2,
}
declare const enum RenderTextureReadWrite {
    Default = 0,
    Linear = 1,
    sRGB = 2,
}
declare const enum StereoTargetEyeMask {
    None = 0,
    Left = 1,
    Right = 2,
    Both = 3,
}
declare const enum SceneViewFilterMode {
    Off = 0,
    ShowFiltered = 1,
}
declare const enum CameraEvent {
    BeforeDepthTexture = 0,
    AfterDepthTexture = 1,
    BeforeDepthNormalsTexture = 2,
    AfterDepthNormalsTexture = 3,
    BeforeGBuffer = 4,
    AfterGBuffer = 5,
    BeforeLighting = 6,
    AfterLighting = 7,
    BeforeFinalPass = 8,
    AfterFinalPass = 9,
    BeforeForwardOpaque = 10,
    AfterForwardOpaque = 11,
    BeforeImageEffectsOpaque = 12,
    AfterImageEffectsOpaque = 13,
    BeforeSkybox = 14,
    AfterSkybox = 15,
    BeforeForwardAlpha = 16,
    AfterForwardAlpha = 17,
    BeforeImageEffects = 18,
    AfterImageEffects = 19,
    AfterEverything = 20,
    BeforeReflections = 21,
    AfterReflections = 22,
    BeforeHaloAndLensFlares = 23,
    AfterHaloAndLensFlares = 24,
}
declare const enum RenderBufferLoadAction {
    Load = 0,
    Clear = 1,
    DontCare = 2,
}
declare const enum RenderBufferStoreAction {
    Store = 0,
    Resolve = 1,
    StoreAndResolve = 2,
    DontCare = 3,
}
declare const enum SubPassFlags {
    None = 0,
    ReadOnlyDepth = 2,
    ReadOnlyStencil = 4,
    ReadOnlyDepthStencil = 6,
}
declare const enum ShaderKeywordType {
    None = 0,
    BuiltinDefault = 2,
    BuiltinExtra = 6,
    BuiltinAutoStripped = 10,
    UserDefined = 16,
    Plugin = 32,
}
declare const enum ShaderPropertyFlags {
    None = 0,
    HideInInspector = 1,
    PerRendererData = 2,
    NoScaleOffset = 4,
    Normal = 8,
    HDR = 16,
    Gamma = 32,
    NonModifiableTextureData = 64,
    MainTexture = 128,
    MainColor = 256,
}
declare const enum ShaderPropertyType {
    Color = 0,
    Vector = 1,
    Float = 2,
    Range = 3,
    Texture = 4,
    Int = 5,
}
declare const enum ShadowCastingMode {
    Off = 0,
    On = 1,
    TwoSided = 2,
    ShadowsOnly = 3,
}
declare const enum MotionVectorGenerationMode {
    Camera = 0,
    Object = 1,
    ForceNoMotion = 2,
}
declare const enum LightProbeUsage {
    Off = 0,
    BlendProbes = 1,
    UseProxyVolume = 2,
    CustomProvided = 4,
}
declare const enum ReflectionProbeUsage {
    Off = 0,
    BlendProbes = 1,
    BlendProbesAndSkybox = 2,
    Simple = 3,
}
declare const enum RayTracingMode {
    Off = 0,
    Static = 1,
    DynamicTransform = 2,
    DynamicGeometry = 3,
}
declare const enum RayTracingAccelerationStructureBuildFlags {
    None = 0,
    PreferFastTrace = 1,
    PreferFastBuild = 2,
    MinimizeMemory = 4,
}
declare const enum ReflectionProbeClearFlags {
    Skybox = 1,
    SolidColor = 2,
}
declare const enum ReflectionProbeMode {
    Baked = 0,
    Realtime = 1,
    Custom = 2,
}
declare const enum ReflectionProbeRefreshMode {
    OnAwake = 0,
    EveryFrame = 1,
    ViaScripting = 2,
}
declare const enum ReflectionProbeTimeSlicingMode {
    AllFacesAtOnce = 0,
    IndividualFaces = 1,
    NoTimeSlicing = 2,
}
declare const enum ReflectionProbeEvent {
    ReflectionProbeAdded = 0,
    ReflectionProbeRemoved = 1,
}
declare const enum RenderTextureSubElement {
    Color = 0,
    Depth = 1,
    Stencil = 2,
    Default = 3,
}
declare const enum MaterialGlobalIlluminationFlags {
    None = 0,
    RealtimeEmissive = 1,
    BakedEmissive = 2,
    AnyEmissive = 3,
    EmissiveIsBlack = 4,
}
declare const enum MaterialPropertyType {
    Float = 0,
    Int = 1,
    Vector = 2,
    Matrix = 3,
    Texture = 4,
    ConstantBuffer = 5,
    ComputeBuffer = 6,
}
declare const enum RTClearFlags {
    None = 0,
    Color = 1,
    Depth = 2,
    ColorDepth = 3,
    Stencil = 4,
    ColorStencil = 5,
    DepthStencil = 6,
    All = 7,
}
declare const enum SynchronisationStage {
    VertexProcessing = 0,
    PixelProcessing = 1,
}
declare const enum GraphicsFenceType {
    AsyncQueueSynchronisation = 0,
    CPUSynchronisation = 1,
}
declare const enum SynchronisationStageFlags {
    VertexProcessing = 1,
    PixelProcessing = 2,
    ComputeProcessing = 4,
    AllGPUOperations = 7,
}
declare const enum CustomMarkerCallbackFlags {
    CustomMarkerCallbackDefault = 0,
    CustomMarkerCallbackForceInvalidateStateTracking = 4,
}
declare const enum CameraLateLatchMatrixType {
    View = 0,
    InverseView = 1,
    ViewProjection = 2,
    InverseViewProjection = 3,
}
declare const enum CommandBufferExecutionFlags {
    None = 0,
    AsyncCompute = 2,
}
declare const enum FoveatedRenderingMode {
    Disabled = 0,
    Enabled = 1,
}
declare const enum CubemapFace {
    PositiveX = 0,
    NegativeX = 1,
    PositiveY = 2,
    NegativeY = 3,
    PositiveZ = 4,
    NegativeZ = 5,
    Unknown = -1,
}
declare const enum RenderTargetFlags {
    None = 0,
    ReadOnlyDepth = 1,
    ReadOnlyStencil = 2,
    ReadOnlyDepthStencil = 3,
}
declare const enum SinglePassStereoMode {
    None = 0,
    SideBySide = 1,
    Instancing = 2,
    Multiview = 3,
}
declare const enum ComputeQueueType {
    Default = 0,
    Background = 1,
    Urgent = 2,
}
declare const enum StereoscopicEye {
    Left = 0,
    Right = 1,
}
declare const enum IMECompositionMode {
    Auto = 0,
    On = 1,
    Off = 2,
}
declare const enum DeviceOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    LandscapeRight = 4,
    FaceUp = 5,
    FaceDown = 6,
}
declare const enum LocationServiceStatus {
    Stopped = 0,
    Initializing = 1,
    Running = 2,
    Failed = 3,
}
declare const enum TouchPhase {
    Began = 0,
    Moved = 1,
    Stationary = 2,
    Ended = 3,
    Canceled = 4,
}
declare const enum TouchType {
    Direct = 0,
    Indirect = 1,
    Stylus = 2,
}
declare const enum KeyCode {
    None = 0,
    Backspace = 8,
    Tab = 9,
    Clear = 12,
    Return = 13,
    Pause = 19,
    Escape = 27,
    Space = 32,
    Exclaim = 33,
    DoubleQuote = 34,
    Hash = 35,
    Dollar = 36,
    Percent = 37,
    Ampersand = 38,
    Quote = 39,
    LeftParen = 40,
    RightParen = 41,
    Asterisk = 42,
    Plus = 43,
    Comma = 44,
    Minus = 45,
    Period = 46,
    Slash = 47,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Colon = 58,
    Semicolon = 59,
    Less = 60,
    Equals = 61,
    Greater = 62,
    Question = 63,
    At = 64,
    LeftBracket = 91,
    Backslash = 92,
    RightBracket = 93,
    Caret = 94,
    Underscore = 95,
    BackQuote = 96,
    A = 97,
    B = 98,
    C = 99,
    D = 100,
    E = 101,
    F = 102,
    G = 103,
    H = 104,
    I = 105,
    J = 106,
    K = 107,
    L = 108,
    M = 109,
    N = 110,
    O = 111,
    P = 112,
    Q = 113,
    R = 114,
    S = 115,
    T = 116,
    U = 117,
    V = 118,
    W = 119,
    X = 120,
    Y = 121,
    Z = 122,
    LeftCurlyBracket = 123,
    Pipe = 124,
    RightCurlyBracket = 125,
    Tilde = 126,
    Delete = 127,
    Keypad0 = 256,
    Keypad1 = 257,
    Keypad2 = 258,
    Keypad3 = 259,
    Keypad4 = 260,
    Keypad5 = 261,
    Keypad6 = 262,
    Keypad7 = 263,
    Keypad8 = 264,
    Keypad9 = 265,
    KeypadPeriod = 266,
    KeypadDivide = 267,
    KeypadMultiply = 268,
    KeypadMinus = 269,
    KeypadPlus = 270,
    KeypadEnter = 271,
    KeypadEquals = 272,
    UpArrow = 273,
    DownArrow = 274,
    RightArrow = 275,
    LeftArrow = 276,
    Insert = 277,
    Home = 278,
    End = 279,
    PageUp = 280,
    PageDown = 281,
    F1 = 282,
    F2 = 283,
    F3 = 284,
    F4 = 285,
    F5 = 286,
    F6 = 287,
    F7 = 288,
    F8 = 289,
    F9 = 290,
    F10 = 291,
    F11 = 292,
    F12 = 293,
    F13 = 294,
    F14 = 295,
    F15 = 296,
    Numlock = 300,
    CapsLock = 301,
    ScrollLock = 302,
    RightShift = 303,
    LeftShift = 304,
    RightControl = 305,
    LeftControl = 306,
    RightAlt = 307,
    LeftAlt = 308,
    RightMeta = 309,
    RightCommand = 309,
    RightApple = 309,
    LeftMeta = 310,
    LeftCommand = 310,
    LeftApple = 310,
    LeftWindows = 311,
    RightWindows = 312,
    AltGr = 313,
    Help = 315,
    Print = 316,
    SysReq = 317,
    Break = 318,
    Menu = 319,
    WheelUp = 321,
    WheelDown = 322,
    Mouse0 = 323,
    Mouse1 = 324,
    Mouse2 = 325,
    Mouse3 = 326,
    Mouse4 = 327,
    Mouse5 = 328,
    Mouse6 = 329,
    JoystickButton0 = 330,
    JoystickButton1 = 331,
    JoystickButton2 = 332,
    JoystickButton3 = 333,
    JoystickButton4 = 334,
    JoystickButton5 = 335,
    JoystickButton6 = 336,
    JoystickButton7 = 337,
    JoystickButton8 = 338,
    JoystickButton9 = 339,
    JoystickButton10 = 340,
    JoystickButton11 = 341,
    JoystickButton12 = 342,
    JoystickButton13 = 343,
    JoystickButton14 = 344,
    JoystickButton15 = 345,
    JoystickButton16 = 346,
    JoystickButton17 = 347,
    JoystickButton18 = 348,
    JoystickButton19 = 349,
    Joystick1Button0 = 350,
    Joystick1Button1 = 351,
    Joystick1Button2 = 352,
    Joystick1Button3 = 353,
    Joystick1Button4 = 354,
    Joystick1Button5 = 355,
    Joystick1Button6 = 356,
    Joystick1Button7 = 357,
    Joystick1Button8 = 358,
    Joystick1Button9 = 359,
    Joystick1Button10 = 360,
    Joystick1Button11 = 361,
    Joystick1Button12 = 362,
    Joystick1Button13 = 363,
    Joystick1Button14 = 364,
    Joystick1Button15 = 365,
    Joystick1Button16 = 366,
    Joystick1Button17 = 367,
    Joystick1Button18 = 368,
    Joystick1Button19 = 369,
    Joystick2Button0 = 370,
    Joystick2Button1 = 371,
    Joystick2Button2 = 372,
    Joystick2Button3 = 373,
    Joystick2Button4 = 374,
    Joystick2Button5 = 375,
    Joystick2Button6 = 376,
    Joystick2Button7 = 377,
    Joystick2Button8 = 378,
    Joystick2Button9 = 379,
    Joystick2Button10 = 380,
    Joystick2Button11 = 381,
    Joystick2Button12 = 382,
    Joystick2Button13 = 383,
    Joystick2Button14 = 384,
    Joystick2Button15 = 385,
    Joystick2Button16 = 386,
    Joystick2Button17 = 387,
    Joystick2Button18 = 388,
    Joystick2Button19 = 389,
    Joystick3Button0 = 390,
    Joystick3Button1 = 391,
    Joystick3Button2 = 392,
    Joystick3Button3 = 393,
    Joystick3Button4 = 394,
    Joystick3Button5 = 395,
    Joystick3Button6 = 396,
    Joystick3Button7 = 397,
    Joystick3Button8 = 398,
    Joystick3Button9 = 399,
    Joystick3Button10 = 400,
    Joystick3Button11 = 401,
    Joystick3Button12 = 402,
    Joystick3Button13 = 403,
    Joystick3Button14 = 404,
    Joystick3Button15 = 405,
    Joystick3Button16 = 406,
    Joystick3Button17 = 407,
    Joystick3Button18 = 408,
    Joystick3Button19 = 409,
    Joystick4Button0 = 410,
    Joystick4Button1 = 411,
    Joystick4Button2 = 412,
    Joystick4Button3 = 413,
    Joystick4Button4 = 414,
    Joystick4Button5 = 415,
    Joystick4Button6 = 416,
    Joystick4Button7 = 417,
    Joystick4Button8 = 418,
    Joystick4Button9 = 419,
    Joystick4Button10 = 420,
    Joystick4Button11 = 421,
    Joystick4Button12 = 422,
    Joystick4Button13 = 423,
    Joystick4Button14 = 424,
    Joystick4Button15 = 425,
    Joystick4Button16 = 426,
    Joystick4Button17 = 427,
    Joystick4Button18 = 428,
    Joystick4Button19 = 429,
    Joystick5Button0 = 430,
    Joystick5Button1 = 431,
    Joystick5Button2 = 432,
    Joystick5Button3 = 433,
    Joystick5Button4 = 434,
    Joystick5Button5 = 435,
    Joystick5Button6 = 436,
    Joystick5Button7 = 437,
    Joystick5Button8 = 438,
    Joystick5Button9 = 439,
    Joystick5Button10 = 440,
    Joystick5Button11 = 441,
    Joystick5Button12 = 442,
    Joystick5Button13 = 443,
    Joystick5Button14 = 444,
    Joystick5Button15 = 445,
    Joystick5Button16 = 446,
    Joystick5Button17 = 447,
    Joystick5Button18 = 448,
    Joystick5Button19 = 449,
    Joystick6Button0 = 450,
    Joystick6Button1 = 451,
    Joystick6Button2 = 452,
    Joystick6Button3 = 453,
    Joystick6Button4 = 454,
    Joystick6Button5 = 455,
    Joystick6Button6 = 456,
    Joystick6Button7 = 457,
    Joystick6Button8 = 458,
    Joystick6Button9 = 459,
    Joystick6Button10 = 460,
    Joystick6Button11 = 461,
    Joystick6Button12 = 462,
    Joystick6Button13 = 463,
    Joystick6Button14 = 464,
    Joystick6Button15 = 465,
    Joystick6Button16 = 466,
    Joystick6Button17 = 467,
    Joystick6Button18 = 468,
    Joystick6Button19 = 469,
    Joystick7Button0 = 470,
    Joystick7Button1 = 471,
    Joystick7Button2 = 472,
    Joystick7Button3 = 473,
    Joystick7Button4 = 474,
    Joystick7Button5 = 475,
    Joystick7Button6 = 476,
    Joystick7Button7 = 477,
    Joystick7Button8 = 478,
    Joystick7Button9 = 479,
    Joystick7Button10 = 480,
    Joystick7Button11 = 481,
    Joystick7Button12 = 482,
    Joystick7Button13 = 483,
    Joystick7Button14 = 484,
    Joystick7Button15 = 485,
    Joystick7Button16 = 486,
    Joystick7Button17 = 487,
    Joystick7Button18 = 488,
    Joystick7Button19 = 489,
    Joystick8Button0 = 490,
    Joystick8Button1 = 491,
    Joystick8Button2 = 492,
    Joystick8Button3 = 493,
    Joystick8Button4 = 494,
    Joystick8Button5 = 495,
    Joystick8Button6 = 496,
    Joystick8Button7 = 497,
    Joystick8Button8 = 498,
    Joystick8Button9 = 499,
    Joystick8Button10 = 500,
    Joystick8Button11 = 501,
    Joystick8Button12 = 502,
    Joystick8Button13 = 503,
    Joystick8Button14 = 504,
    Joystick8Button15 = 505,
    Joystick8Button16 = 506,
    Joystick8Button17 = 507,
    Joystick8Button18 = 508,
    Joystick8Button19 = 509,
}
declare const enum PenStatus {
    None = 0,
    Contact = 1,
    Barrel = 2,
    Inverted = 4,
    Eraser = 8,
}
declare const enum PenEventType {
    NoContact = 0,
    PenDown = 1,
    PenUp = 2,
}
declare const enum InputButton {
    Left = 0,
    Right = 1,
    Middle = 2,
}
declare const enum MoveDirection {
    Left = 0,
    Up = 1,
    Right = 2,
    Down = 3,
    None = 4,
}
declare const enum Mode {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    Automatic = 3,
    Explicit = 4,
}
declare const enum Transition {
    None = 0,
    ColorTint = 1,
    SpriteSwap = 2,
    Animation = 3,
}
declare const enum CanvasUpdate {
    Prelayout = 0,
    Layout = 1,
    PostLayout = 2,
    PreRender = 3,
    LatePreRender = 4,
    MaxUpdateValue = 5,
}
declare const enum Edge {
    Left = 0,
    Right = 1,
    Top = 2,
    Bottom = 3,
}
declare const enum Axis {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum RenderMode {
    ScreenSpaceOverlay = 0,
    ScreenSpaceCamera = 1,
    WorldSpace = 2,
}
declare const enum AdditionalCanvasShaderChannels {
    None = 0,
    TexCoord1 = 1,
    TexCoord2 = 2,
    TexCoord3 = 4,
    Normal = 8,
    Tangent = 16,
}
declare const enum StandaloneRenderResize {
    Enabled = 0,
    Disabled = 1,
}
declare const enum Type {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
    Filled = 3,
}
declare const enum FillMethod {
    Horizontal = 0,
    Vertical = 1,
    Radial90 = 2,
    Radial180 = 3,
    Radial360 = 4,
}
declare const enum AnimatorUpdateMode {
    Normal = 0,
    Fixed = 1,
    AnimatePhysics = 1,
    UnscaledTime = 2,
}
declare const enum AnimatorControllerParameterType {
    Float = 1,
    Int = 3,
    Bool = 4,
    Trigger = 9,
}
declare const enum AnimatorCullingMode {
    AlwaysAnimate = 0,
    CullUpdateTransforms = 1,
    BasedOnRenderers = 1,
    CullCompletely = 2,
}
declare const enum AnimatorRecorderMode {
    Offline = 0,
    Playback = 1,
    Record = 2,
}
declare const enum WrapMode {
    Default = 0,
    Once = 1,
    Clamp = 1,
    Loop = 2,
    PingPong = 4,
    ClampForever = 8,
}
declare const enum AnimationBlendMode {
    Blend = 0,
    Additive = 1,
}
declare const enum WeightedMode {
    None = 0,
    In = 1,
    Out = 2,
    Both = 3,
}
declare const enum DirectorUpdateMode {
    DSPClock = 0,
    GameTime = 1,
    UnscaledGameTime = 2,
    Manual = 3,
}
declare const enum DurationUnit {
    Fixed = 0,
    Normalized = 1,
}
declare const enum HumanBodyBones {
    Hips = 0,
    LeftUpperLeg = 1,
    RightUpperLeg = 2,
    LeftLowerLeg = 3,
    RightLowerLeg = 4,
    LeftFoot = 5,
    RightFoot = 6,
    Spine = 7,
    Chest = 8,
    Neck = 9,
    Head = 10,
    LeftShoulder = 11,
    RightShoulder = 12,
    LeftUpperArm = 13,
    RightUpperArm = 14,
    LeftLowerArm = 15,
    RightLowerArm = 16,
    LeftHand = 17,
    RightHand = 18,
    LeftToes = 19,
    RightToes = 20,
    LeftEye = 21,
    RightEye = 22,
    Jaw = 23,
    LeftThumbProximal = 24,
    LeftThumbIntermediate = 25,
    LeftThumbDistal = 26,
    LeftIndexProximal = 27,
    LeftIndexIntermediate = 28,
    LeftIndexDistal = 29,
    LeftMiddleProximal = 30,
    LeftMiddleIntermediate = 31,
    LeftMiddleDistal = 32,
    LeftRingProximal = 33,
    LeftRingIntermediate = 34,
    LeftRingDistal = 35,
    LeftLittleProximal = 36,
    LeftLittleIntermediate = 37,
    LeftLittleDistal = 38,
    RightThumbProximal = 39,
    RightThumbIntermediate = 40,
    RightThumbDistal = 41,
    RightIndexProximal = 42,
    RightIndexIntermediate = 43,
    RightIndexDistal = 44,
    RightMiddleProximal = 45,
    RightMiddleIntermediate = 46,
    RightMiddleDistal = 47,
    RightRingProximal = 48,
    RightRingIntermediate = 49,
    RightRingDistal = 50,
    RightLittleProximal = 51,
    RightLittleIntermediate = 52,
    RightLittleDistal = 53,
    UpperChest = 54,
    LastBone = 55,
}
declare const enum AvatarIKHint {
    LeftKnee = 0,
    RightKnee = 1,
    LeftElbow = 2,
    RightElbow = 3,
}
declare const enum AvatarIKGoal {
    LeftFoot = 0,
    RightFoot = 1,
    LeftHand = 2,
    RightHand = 3,
}
declare const enum AvatarTarget {
    Root = 0,
    Body = 1,
    LeftFoot = 2,
    RightFoot = 3,
    LeftHand = 4,
    RightHand = 5,
}
declare const enum ReceiveGI {
    Lightmaps = 1,
    LightProbes = 2,
}
declare const enum FontStyle {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldAndItalic = 3,
}
declare const enum AtlasPopulationMode {
    Static = 0,
    Dynamic = 1,
    DynamicOS = 2,
}
declare const enum GlyphClassDefinitionType {
    Undefined = 0,
    Base = 1,
    Ligature = 2,
    Mark = 3,
    Component = 4,
}
declare const enum TextElementType {
    Character = 1,
    Sprite = 2,
}
declare const enum GlyphRenderMode {
    SMOOTH = 4117,
    RASTER = 4118,
    SMOOTH_HINTED = 4121,
    RASTER_HINTED = 4122,
    SDF = 4134,
    SDFAA = 4165,
    SDFAA_HINTED = 4169,
    SDF8 = 8230,
    SDF16 = 16422,
    SDF32 = 32806,
    COLOR = 69652,
    COLOR_HINTED = 69656,
}
declare const enum FontFeatureLookupFlags {
    None = 0,
    IgnoreLigatures = 4,
    IgnoreSpacingAdjustments = 256,
}
declare const enum ColorMode {
    Single = 0,
    HorizontalGradient = 1,
    VerticalGradient = 2,
    FourCornersGradient = 3,
}
declare const enum FontWeight {
    Thin = 100,
    ExtraLight = 200,
    Light = 300,
    Regular = 400,
    Medium = 500,
    SemiBold = 600,
    Bold = 700,
    Heavy = 800,
    Black = 900,
}
declare const enum FontStyles {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    LowerCase = 8,
    UpperCase = 16,
    SmallCaps = 32,
    Strikethrough = 64,
    Superscript = 128,
    Subscript = 256,
    Highlight = 512,
}
declare const enum HorizontalAlignmentOptions {
    Left = 1,
    Center = 2,
    Right = 4,
    Justified = 8,
    Flush = 16,
    Geometry = 32,
}
declare const enum VerticalAlignmentOptions {
    Top = 256,
    Middle = 512,
    Bottom = 1024,
    Baseline = 2048,
    Geometry = 4096,
    Capline = 8192,
}
declare const enum TextAlignmentOptions {
    TopLeft = 257,
    Top = 258,
    TopRight = 260,
    TopJustified = 264,
    TopFlush = 272,
    TopGeoAligned = 288,
    Left = 513,
    Center = 514,
    Right = 516,
    Justified = 520,
    Flush = 528,
    CenterGeoAligned = 544,
    BottomLeft = 1025,
    Bottom = 1026,
    BottomRight = 1028,
    BottomJustified = 1032,
    BottomFlush = 1040,
    BottomGeoAligned = 1056,
    BaselineLeft = 2049,
    Baseline = 2050,
    BaselineRight = 2052,
    BaselineJustified = 2056,
    BaselineFlush = 2064,
    BaselineGeoAligned = 2080,
    MidlineLeft = 4097,
    Midline = 4098,
    MidlineRight = 4100,
    MidlineJustified = 4104,
    MidlineFlush = 4112,
    MidlineGeoAligned = 4128,
    CaplineLeft = 8193,
    Capline = 8194,
    CaplineRight = 8196,
    CaplineJustified = 8200,
    CaplineFlush = 8208,
    CaplineGeoAligned = 8224,
    Converted = 65535,
}
declare const enum TextWrappingModes {
    NoWrap = 0,
    Normal = 1,
    PreserveWhitespace = 2,
    PreserveWhitespaceNoWrap = 3,
}
declare const enum TextOverflowModes {
    Overflow = 0,
    Ellipsis = 1,
    Masking = 2,
    Truncate = 3,
    ScrollRect = 4,
    Page = 5,
    Linked = 6,
}
declare const enum OTL_FeatureTag {
    kern = 1801810542,
    liga = 1818847073,
    mark = 1835102827,
    mkmk = 1835756907,
}
declare const enum TextureMappingOptions {
    Character = 0,
    Line = 1,
    Paragraph = 2,
    MatchAspect = 3,
}
declare const enum TextRenderFlags {
    DontRender = 0,
    Render = 255,
}
declare const enum VertexSortingOrder {
    Normal = 0,
    Reverse = 1,
}
declare const enum TMP_TextElementType {
    Character = 0,
    Sprite = 1,
}
declare const enum TMP_VertexDataUpdateFlags {
    None = 0,
    Vertices = 1,
    Uv0 = 2,
    Uv2 = 4,
    Uv4 = 8,
    Colors32 = 16,
    All = 255,
}
declare const enum AnimationUpdateMode {
    Normal = 0,
    Fixed = 1,
}
declare const enum AnimationCullingType {
    AlwaysAnimate = 0,
    BasedOnRenderers = 1,
    BasedOnClipBounds = 2,
    BasedOnUserBounds = 3,
}
declare const enum PlayMode {
    StopSameLayer = 0,
    StopAll = 4,
}
declare const enum QueueMode {
    CompleteOthers = 0,
    PlayNow = 2,
}
declare const enum Status {
    Visible = 0,
    Done = 1,
    Canceled = 2,
    LostFocus = 3,
}
declare const enum TouchScreenKeyboardType {
    Default = 0,
    ASCIICapable = 1,
    NumbersAndPunctuation = 2,
    URL = 3,
    NumberPad = 4,
    PhonePad = 5,
    NamePhonePad = 6,
    EmailAddress = 7,
    NintendoNetworkAccount = 8,
    Social = 9,
    Search = 10,
    DecimalPad = 11,
    OneTimeCode = 12,
}
declare const enum StylePropertyId {
    Unknown = 0,
    Color = 65536,
    FontSize = 65537,
    LetterSpacing = 65538,
    TextShadow = 65539,
    UnityFont = 65540,
    UnityFontDefinition = 65541,
    UnityFontStyleAndWeight = 65542,
    UnityParagraphSpacing = 65543,
    UnityTextAlign = 65544,
    UnityTextOutlineColor = 65545,
    UnityTextOutlineWidth = 65546,
    Visibility = 65547,
    WhiteSpace = 65548,
    WordSpacing = 65549,
    AlignContent = 131072,
    AlignItems = 131073,
    AlignSelf = 131074,
    BorderBottomWidth = 131075,
    BorderLeftWidth = 131076,
    BorderRightWidth = 131077,
    BorderTopWidth = 131078,
    Bottom = 131079,
    Display = 131080,
    FlexBasis = 131081,
    FlexDirection = 131082,
    FlexGrow = 131083,
    FlexShrink = 131084,
    FlexWrap = 131085,
    Height = 131086,
    JustifyContent = 131087,
    Left = 131088,
    MarginBottom = 131089,
    MarginLeft = 131090,
    MarginRight = 131091,
    MarginTop = 131092,
    MaxHeight = 131093,
    MaxWidth = 131094,
    MinHeight = 131095,
    MinWidth = 131096,
    PaddingBottom = 131097,
    PaddingLeft = 131098,
    PaddingRight = 131099,
    PaddingTop = 131100,
    Position = 131101,
    Right = 131102,
    Top = 131103,
    Width = 131104,
    Cursor = 196608,
    TextOverflow = 196609,
    UnityBackgroundImageTintColor = 196610,
    UnityOverflowClipBox = 196611,
    UnitySliceBottom = 196612,
    UnitySliceLeft = 196613,
    UnitySliceRight = 196614,
    UnitySliceScale = 196615,
    UnitySliceTop = 196616,
    UnityTextOverflowPosition = 196617,
    All = 262144,
    BackgroundPosition = 262145,
    BorderColor = 262146,
    BorderRadius = 262147,
    BorderWidth = 262148,
    Flex = 262149,
    Margin = 262150,
    Padding = 262151,
    Transition = 262152,
    UnityBackgroundScaleMode = 262153,
    UnityTextOutline = 262154,
    Rotate = 327680,
    Scale = 327681,
    TransformOrigin = 327682,
    Translate = 327683,
    TransitionDelay = 393216,
    TransitionDuration = 393217,
    TransitionProperty = 393218,
    TransitionTimingFunction = 393219,
    BackgroundColor = 458752,
    BackgroundImage = 458753,
    BackgroundPositionX = 458754,
    BackgroundPositionY = 458755,
    BackgroundRepeat = 458756,
    BackgroundSize = 458757,
    BorderBottomColor = 458758,
    BorderBottomLeftRadius = 458759,
    BorderBottomRightRadius = 458760,
    BorderLeftColor = 458761,
    BorderRightColor = 458762,
    BorderTopColor = 458763,
    BorderTopLeftRadius = 458764,
    BorderTopRightRadius = 458765,
    Opacity = 458766,
    Overflow = 458767,
    Custom = -1,
}
declare const enum LengthUnit {
    Pixel = 0,
    Percent = 1,
}
declare const enum AtlasPopulationMode {
    Static = 0,
    Dynamic = 1,
    DynamicOS = 2,
}
declare const enum TextElementType {
    Character = 1,
    Sprite = 2,
}
declare const enum AngleUnit {
    Degree = 0,
    Gradian = 1,
    Radian = 2,
    Turn = 3,
}
declare const enum BackgroundPositionKeyword {
    Center = 0,
    Top = 1,
    Bottom = 2,
    Left = 3,
    Right = 4,
}
declare const enum Repeat {
    NoRepeat = 0,
    Space = 1,
    Round = 2,
    Repeat = 3,
}
declare const enum BackgroundSizeType {
    Length = 0,
    Cover = 1,
    Contain = 2,
}
declare const enum Align {
    Auto = 0,
    FlexStart = 1,
    Center = 2,
    FlexEnd = 3,
    Stretch = 4,
}
declare const enum DisplayStyle {
    Flex = 0,
    None = 1,
}
declare const enum StyleKeyword {
    Undefined = 0,
    Null = 1,
    Auto = 2,
    None = 3,
    Initial = 4,
}
declare const enum FlexDirection {
    Column = 0,
    ColumnReverse = 1,
    Row = 2,
    RowReverse = 3,
}
declare const enum Wrap {
    NoWrap = 0,
    Wrap = 1,
    WrapReverse = 2,
}
declare const enum Justify {
    FlexStart = 0,
    Center = 1,
    FlexEnd = 2,
    SpaceBetween = 3,
    SpaceAround = 4,
    SpaceEvenly = 5,
}
declare const enum Position {
    Relative = 0,
    Absolute = 1,
}
declare const enum TextOverflow {
    Clip = 0,
    Ellipsis = 1,
}
declare const enum TimeUnit {
    Second = 0,
    Millisecond = 1,
}
declare const enum EasingMode {
    Ease = 0,
    EaseIn = 1,
    EaseOut = 2,
    EaseInOut = 3,
    Linear = 4,
    EaseInSine = 5,
    EaseOutSine = 6,
    EaseInOutSine = 7,
    EaseInCubic = 8,
    EaseOutCubic = 9,
    EaseInOutCubic = 10,
    EaseInCirc = 11,
    EaseOutCirc = 12,
    EaseInOutCirc = 13,
    EaseInElastic = 14,
    EaseOutElastic = 15,
    EaseInOutElastic = 16,
    EaseInBack = 17,
    EaseOutBack = 18,
    EaseInOutBack = 19,
    EaseInBounce = 20,
    EaseOutBounce = 21,
    EaseInOutBounce = 22,
}
declare const enum TextAnchor {
    UpperLeft = 0,
    UpperCenter = 1,
    UpperRight = 2,
    MiddleLeft = 3,
    MiddleCenter = 4,
    MiddleRight = 5,
    LowerLeft = 6,
    LowerCenter = 7,
    LowerRight = 8,
}
declare const enum TextOverflowPosition {
    End = 0,
    Start = 1,
    Middle = 2,
}
declare const enum Visibility {
    Visible = 0,
    Hidden = 1,
}
declare const enum WhiteSpace {
    Normal = 0,
    NoWrap = 1,
}
declare const enum PropagationPhase {
    None = 0,
    TrickleDown = 1,
    AtTarget = 2,
    BubbleUp = 3,
    DefaultAction = 4,
    DefaultActionAtTarget = 5,
}
declare const enum EventType {
    MouseDown = 0,
    mouseDown = 0,
    MouseUp = 1,
    mouseUp = 1,
    MouseMove = 2,
    mouseMove = 2,
    mouseDrag = 3,
    MouseDrag = 3,
    KeyDown = 4,
    keyDown = 4,
    keyUp = 5,
    KeyUp = 5,
    ScrollWheel = 6,
    scrollWheel = 6,
    Repaint = 7,
    repaint = 7,
    Layout = 8,
    layout = 8,
    DragUpdated = 9,
    dragUpdated = 9,
    dragPerform = 10,
    DragPerform = 10,
    ignore = 11,
    Ignore = 11,
    used = 12,
    Used = 12,
    ValidateCommand = 13,
    ExecuteCommand = 14,
    DragExited = 15,
    ContextClick = 16,
    MouseEnterWindow = 20,
    MouseLeaveWindow = 21,
    TouchDown = 30,
    TouchUp = 31,
    TouchMove = 32,
    TouchEnter = 33,
    TouchLeave = 34,
    TouchStationary = 35,
}
declare const enum PointerType {
    Mouse = 0,
    Touch = 1,
    Pen = 2,
}
declare const enum EventModifiers {
    None = 0,
    Shift = 1,
    Control = 2,
    Alt = 4,
    Command = 8,
    Numeric = 16,
    CapsLock = 32,
    FunctionKey = 64,
}
declare const enum TrickleDown {
    NoTrickleDown = 0,
    TrickleDown = 1,
}
declare const enum UsageHints {
    None = 0,
    DynamicTransform = 1,
    GroupTransform = 2,
    MaskContainer = 4,
    DynamicColor = 8,
}
declare const enum PickingMode {
    Position = 0,
    Ignore = 1,
}
declare const enum LanguageDirection {
    Inherit = 0,
    LTR = 1,
    RTL = 2,
}
declare const enum PropertyPathPartKind {
    Name = 0,
    Index = 1,
    Key = 2,
}
declare const enum ContextType {
    Player = 0,
    Editor = 1,
}
declare const enum Overflow {
    Visible = 0,
    Hidden = 1,
}
declare const enum OverflowClipBox {
    PaddingBox = 0,
    ContentBox = 1,
}
declare const enum BindingUpdateTrigger {
    WhenDirty = 0,
    OnSourceChanged = 1,
    EveryUpdate = 2,
}
declare const enum BindingLogLevel {
    None = 0,
    Once = 1,
    All = 2,
}
declare const enum MeasureMode {
    Undefined = 0,
    Exactly = 1,
    AtMost = 2,
}
declare const enum ScrollerVisibility {
    Auto = 0,
    AlwaysVisible = 1,
    Hidden = 2,
}
declare const enum FogMode {
    Linear = 1,
    Exponential = 2,
    ExponentialSquared = 3,
}
declare const enum AmbientMode {
    Skybox = 0,
    Trilight = 1,
    Flat = 3,
    Custom = 4,
}
declare const enum LightType {
    Spot = 0,
    Directional = 1,
    Point = 2,
    Area = 3,
    Rectangle = 3,
    Disc = 4,
    Pyramid = 5,
    Box = 6,
    Tube = 7,
}
declare const enum LightmapBakeType {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum MixedLightingMode {
    IndirectOnly = 0,
    Subtractive = 1,
    Shadowmask = 2,
}
declare const enum LightShadowCasterMode {
    Default = 0,
    NonLightmappedOnly = 1,
    Everything = 2,
}
declare const enum LightShadows {
    None = 0,
    Hard = 1,
    Soft = 2,
}
declare const enum LightShadowResolution {
    Low = 0,
    Medium = 1,
    High = 2,
    VeryHigh = 3,
    FromQualitySettings = -1,
}
declare const enum LightRenderMode {
    Auto = 0,
    ForcePixel = 1,
    ForceVertex = 2,
}
declare const enum LightEvent {
    BeforeShadowMap = 0,
    AfterShadowMap = 1,
    BeforeScreenspaceMask = 2,
    AfterScreenspaceMask = 3,
    BeforeShadowMapPass = 4,
    AfterShadowMapPass = 5,
}
declare const enum ShadowMapPass {
    PointlightPositiveX = 1,
    PointlightNegativeX = 2,
    PointlightPositiveY = 4,
    PointlightNegativeY = 8,
    PointlightPositiveZ = 16,
    PointlightNegativeZ = 32,
    Pointlight = 63,
    DirectionalCascade0 = 64,
    DirectionalCascade1 = 128,
    DirectionalCascade2 = 256,
    DirectionalCascade3 = 512,
    Directional = 960,
    Spotlight = 1024,
    All = 2047,
    AreaLight = 2048,
}
declare const enum DefaultReflectionMode {
    Skybox = 0,
    Custom = 1,
}
declare const enum SyncDirection {
    ServerToClient = 0,
    ClientToServer = 1,
}
declare const enum SyncMode {
    Observers = 0,
    Owner = 1,
}
declare const enum Visibility {
    Default = 0,
    ForceHidden = 1,
    ForceShown = 2,
}
declare const enum LocalPhysicsMode {
    None = 0,
    Physics2D = 1,
    Physics3D = 2,
}
declare const enum LoadSceneMode {
    Single = 0,
    Additive = 1,
}
declare const enum UnloadSceneOptions {
    None = 0,
    UnloadAllEmbeddedSceneObjects = 1,
}
declare const enum AvatarMaskBodyPart {
    Root = 0,
    Body = 1,
    Head = 2,
    LeftLeg = 3,
    RightLeg = 4,
    LeftArm = 5,
    RightArm = 6,
    LeftFingers = 7,
    RightFingers = 8,
    LeftFootIK = 9,
    RightFootIK = 10,
    LeftHandIK = 11,
    RightHandIK = 12,
    LastBodyPart = 13,
}
declare const enum SkinQuality {
    Auto = 0,
    Bone1 = 1,
    Bone2 = 2,
    Bone4 = 4,
}
declare const enum ApplicationInstallMode {
    Unknown = 0,
    Store = 1,
    DeveloperBuild = 2,
    Adhoc = 3,
    Enterprise = 4,
    Editor = 5,
}
declare const enum ApplicationSandboxType {
    Unknown = 0,
    NotSandboxed = 1,
    Sandboxed = 2,
    SandboxBroken = 3,
}
declare const enum ThreadPriority {
    Low = 0,
    BelowNormal = 1,
    Normal = 2,
    High = 4,
}
declare const enum RuntimePlatform {
    OSXEditor = 0,
    OSXPlayer = 1,
    WindowsPlayer = 2,
    OSXWebPlayer = 3,
    OSXDashboardPlayer = 4,
    WindowsWebPlayer = 5,
    WindowsEditor = 7,
    IPhonePlayer = 8,
    PS3 = 9,
    XBOX360 = 10,
    Android = 11,
    NaCl = 12,
    LinuxPlayer = 13,
    FlashPlayer = 15,
    LinuxEditor = 16,
    WebGLPlayer = 17,
    MetroPlayerX86 = 18,
    WSAPlayerX86 = 18,
    MetroPlayerX64 = 19,
    WSAPlayerX64 = 19,
    MetroPlayerARM = 20,
    WSAPlayerARM = 20,
    WP8Player = 21,
    BB10Player = 22,
    BlackBerryPlayer = 22,
    TizenPlayer = 23,
    PSP2 = 24,
    PS4 = 25,
    PSM = 26,
    XboxOne = 27,
    SamsungTVPlayer = 28,
    WiiU = 30,
    tvOS = 31,
    Switch = 32,
    Lumin = 33,
    Stadia = 34,
    LinuxHeadlessSimulation = 35,
    GameCoreXboxSeries = 36,
    GameCoreXboxOne = 37,
    PS5 = 38,
    EmbeddedLinuxArm64 = 39,
    EmbeddedLinuxArm32 = 40,
    EmbeddedLinuxX64 = 41,
    EmbeddedLinuxX86 = 42,
    LinuxServer = 43,
    WindowsServer = 44,
    OSXServer = 45,
    QNXArm32 = 46,
    QNXArm64 = 47,
    QNXX64 = 48,
    QNXX86 = 49,
    GameCoreScarlett = -1,
    CloudRendering = -1,
}
declare const enum SystemLanguage {
    Afrikaans = 0,
    Arabic = 1,
    Basque = 2,
    Belarusian = 3,
    Bulgarian = 4,
    Catalan = 5,
    Chinese = 6,
    Czech = 7,
    Danish = 8,
    Dutch = 9,
    English = 10,
    Estonian = 11,
    Faroese = 12,
    Finnish = 13,
    French = 14,
    German = 15,
    Greek = 16,
    Hebrew = 17,
    Hungarian = 18,
    Hugarian = 18,
    Icelandic = 19,
    Indonesian = 20,
    Italian = 21,
    Japanese = 22,
    Korean = 23,
    Latvian = 24,
    Lithuanian = 25,
    Norwegian = 26,
    Polish = 27,
    Portuguese = 28,
    Romanian = 29,
    Russian = 30,
    SerboCroatian = 31,
    Slovak = 32,
    Slovenian = 33,
    Spanish = 34,
    Swedish = 35,
    Thai = 36,
    Turkish = 37,
    Ukrainian = 38,
    Vietnamese = 39,
    ChineseSimplified = 40,
    ChineseTraditional = 41,
    Hindi = 42,
    Unknown = 43,
}
declare const enum NetworkReachability {
    NotReachable = 0,
    ReachableViaCarrierDataNetwork = 1,
    ReachableViaLocalAreaNetwork = 2,
}
declare const enum StackTraceLogType {
    None = 0,
    ScriptOnly = 1,
    Full = 2,
}
declare const enum UserAuthorization {
    WebCam = 1,
    Microphone = 2,
}
declare const enum ParticleSystemCurveMode {
    Constant = 0,
    Curve = 1,
    TwoCurves = 2,
    TwoConstants = 3,
}
declare const enum ParticleSystemGradientMode {
    Color = 0,
    Gradient = 1,
    TwoColors = 2,
    TwoGradients = 3,
    RandomColor = 4,
}
declare const enum GradientMode {
    Blend = 0,
    Fixed = 1,
    PerceptualBlend = 2,
}
declare const enum ColorSpace {
    Gamma = 0,
    Linear = 1,
    Uninitialized = -1,
}
declare const enum ParticleSystemGravitySource {
    Physics3D = 0,
    Physics2D = 1,
}
declare const enum ParticleSystemSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2,
}
declare const enum ParticleSystemScalingMode {
    Hierarchy = 0,
    Local = 1,
    Shape = 2,
}
declare const enum ParticleSystemEmitterVelocityMode {
    Transform = 0,
    Rigidbody = 1,
    Custom = 2,
}
declare const enum ParticleSystemStopAction {
    None = 0,
    Disable = 1,
    Destroy = 2,
    Callback = 3,
}
declare const enum ParticleSystemRingBufferMode {
    Disabled = 0,
    PauseUntilReplaced = 1,
    LoopUntilReplaced = 2,
}
declare const enum ParticleSystemCullingMode {
    Automatic = 0,
    PauseAndCatchup = 1,
    Pause = 2,
    AlwaysSimulate = 3,
}
declare const enum ParticleSystemShapeType {
    Sphere = 0,
    SphereShell = 1,
    Hemisphere = 2,
    HemisphereShell = 3,
    Cone = 4,
    Box = 5,
    Mesh = 6,
    ConeShell = 7,
    ConeVolume = 8,
    ConeVolumeShell = 9,
    Circle = 10,
    CircleEdge = 11,
    SingleSidedEdge = 12,
    MeshRenderer = 13,
    SkinnedMeshRenderer = 14,
    BoxShell = 15,
    BoxEdge = 16,
    Donut = 17,
    Rectangle = 18,
    Sprite = 19,
    SpriteRenderer = 20,
}
declare const enum ParticleSystemShapeMultiModeValue {
    Random = 0,
    Loop = 1,
    PingPong = 2,
    BurstSpread = 3,
}
declare const enum ParticleSystemMeshShapeType {
    Vertex = 0,
    Edge = 1,
    Triangle = 2,
}
declare const enum SpriteDrawMode {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
}
declare const enum SpriteTileMode {
    Continuous = 0,
    Adaptive = 1,
}
declare const enum SpriteMaskInteraction {
    None = 0,
    VisibleInsideMask = 1,
    VisibleOutsideMask = 2,
}
declare const enum SpriteSortPoint {
    Center = 0,
    Pivot = 1,
}
declare const enum ParticleSystemShapeTextureChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
}
declare const enum ParticleSystemInheritVelocityMode {
    Initial = 0,
    Current = 1,
}
declare const enum ParticleSystemGameObjectFilter {
    LayerMask = 0,
    List = 1,
    LayerMaskAndList = 2,
}
declare const enum ParticleSystemForceFieldShape {
    Sphere = 0,
    Hemisphere = 1,
    Cylinder = 2,
    Box = 3,
}
declare const enum ParticleSystemNoiseQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
declare const enum ParticleSystemCollisionType {
    Planes = 0,
    World = 1,
}
declare const enum ParticleSystemCollisionMode {
    Collision3D = 0,
    Collision2D = 1,
}
declare const enum ParticleSystemCollisionQuality {
    High = 0,
    Medium = 1,
    Low = 2,
}
declare const enum ParticleSystemOverlapAction {
    Ignore = 0,
    Kill = 1,
    Callback = 2,
}
declare const enum ParticleSystemColliderQueryMode {
    Disabled = 0,
    One = 1,
    All = 2,
}
declare const enum ParticleSystemSubEmitterType {
    Birth = 0,
    Collision = 1,
    Death = 2,
    Trigger = 3,
    Manual = 4,
}
declare const enum ParticleSystemSubEmitterProperties {
    InheritNothing = 0,
    InheritColor = 1,
    InheritSize = 2,
    InheritRotation = 4,
    InheritLifetime = 8,
    InheritDuration = 16,
    InheritEverything = 31,
}
declare const enum ParticleSystemAnimationMode {
    Grid = 0,
    Sprites = 1,
}
declare const enum ParticleSystemAnimationTimeMode {
    Lifetime = 0,
    Speed = 1,
    FPS = 2,
}
declare const enum ParticleSystemAnimationType {
    WholeSheet = 0,
    SingleRow = 1,
}
declare const enum ParticleSystemAnimationRowMode {
    Custom = 0,
    Random = 1,
    MeshIndex = 2,
}
declare const enum UVChannelFlags {
    UV0 = 1,
    UV1 = 2,
    UV2 = 4,
    UV3 = 8,
}
declare const enum ParticleSystemTrailMode {
    PerParticle = 0,
    Ribbon = 1,
}
declare const enum ParticleSystemTrailTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
    Static = 4,
}
declare const enum ParticleSystemCustomData {
    Custom1 = 0,
    Custom2 = 1,
}
declare const enum ParticleSystemCustomDataMode {
    Disabled = 0,
    Vector = 1,
    Color = 2,
}
declare const enum ParticleSystemStopBehavior {
    StopEmittingAndClear = 0,
    StopEmitting = 1,
}
declare const enum ParticleSystemRenderSpace {
    View = 0,
    World = 1,
    Local = 2,
    Facing = 3,
    Velocity = 4,
}
declare const enum ParticleSystemRenderMode {
    Billboard = 0,
    Stretch = 1,
    HorizontalBillboard = 2,
    VerticalBillboard = 3,
    Mesh = 4,
    None = 5,
}
declare const enum ParticleSystemMeshDistribution {
    UniformRandom = 0,
    NonUniformRandom = 1,
}
declare const enum ParticleSystemSortMode {
    None = 0,
    Distance = 1,
    OldestInFront = 2,
    YoungestInFront = 3,
    Depth = 4,
    DistanceReverse = 5,
    DepthReverse = 6,
}
declare const enum ParticleSystemBakeMeshOptions {
    Default = 0,
    BakeRotationAndScale = 1,
    BakePosition = 2,
}
declare const enum ParticleSystemBakeTextureOptions {
    BakeRotationAndScale = 1,
    BakePosition = 2,
    PerVertex = 4,
    Default = 4,
    PerParticle = 8,
    IncludeParticleIndices = 16,
}
declare const enum ParticleSystemVertexStream {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    UV = 4,
    UV2 = 5,
    UV3 = 6,
    UV4 = 7,
    AnimBlend = 8,
    AnimFrame = 9,
    Center = 10,
    VertexID = 11,
    SizeX = 12,
    SizeXY = 13,
    SizeXYZ = 14,
    Rotation = 15,
    Rotation3D = 16,
    RotationSpeed = 17,
    RotationSpeed3D = 18,
    Velocity = 19,
    Speed = 20,
    AgePercent = 21,
    InvStartLifetime = 22,
    StableRandomX = 23,
    StableRandomXY = 24,
    StableRandomXYZ = 25,
    StableRandomXYZW = 26,
    VaryingRandomX = 27,
    VaryingRandomXY = 28,
    VaryingRandomXYZ = 29,
    VaryingRandomXYZW = 30,
    Custom1X = 31,
    Custom1XY = 32,
    Custom1XYZ = 33,
    Custom1XYZW = 34,
    Custom2X = 35,
    Custom2XY = 36,
    Custom2XYZ = 37,
    Custom2XYZW = 38,
    NoiseSumX = 39,
    NoiseSumXY = 40,
    NoiseSumXYZ = 41,
    NoiseImpulseX = 42,
    NoiseImpulseXY = 43,
    NoiseImpulseXYZ = 44,
    MeshIndex = 45,
    ParticleIndex = 46,
    ColorPackedAsTwoFloats = 47,
    MeshAxisOfRotation = 48,
    NextTrailCenter = 49,
    PreviousTrailCenter = 50,
    PercentageAlongTrail = 51,
    TrailWidth = 52,
}
declare const enum ProfilerArea {
    CPU = 0,
    GPU = 1,
    Rendering = 2,
    Memory = 3,
    Audio = 4,
    Video = 5,
    Physics = 6,
    Physics2D = 7,
    NetworkMessages = 8,
    NetworkOperations = 9,
    UI = 10,
    UIDetails = 11,
    GlobalIllumination = 12,
    VirtualTexturing = 13,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum ContentType {
    Standard = 0,
    Autocorrected = 1,
    IntegerNumber = 2,
    DecimalNumber = 3,
    Alphanumeric = 4,
    Name = 5,
    EmailAddress = 6,
    Password = 7,
    Pin = 8,
    Custom = 9,
}
declare const enum LineType {
    SingleLine = 0,
    MultiLineSubmit = 1,
    MultiLineNewline = 2,
}
declare const enum InputType {
    Standard = 0,
    AutoCorrect = 1,
    Password = 2,
}
declare const enum CharacterValidation {
    None = 0,
    Digit = 1,
    Integer = 2,
    Decimal = 3,
    Alphanumeric = 4,
    Name = 5,
    Regex = 6,
    EmailAddress = 7,
    CustomValidator = 8,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum VerticalWrapMode {
    Truncate = 0,
    Overflow = 1,
}
declare const enum HorizontalWrapMode {
    Wrap = 0,
    Overflow = 1,
}
declare const enum AudioClipLoadType {
    DecompressOnLoad = 0,
    CompressedInMemory = 1,
    Streaming = 2,
}
declare const enum AudioDataLoadState {
    Unloaded = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
}
declare const enum AudioMixerUpdateMode {
    Normal = 0,
    UnscaledTime = 1,
}
declare const enum GamepadSpeakerOutputType {
    Speaker = 0,
    Vibration = 1,
    SecondaryVibration = 2,
}
declare const enum AudioVelocityUpdateMode {
    Auto = 0,
    Fixed = 1,
    Dynamic = 2,
}
declare const enum AudioRolloffMode {
    Logarithmic = 0,
    Linear = 1,
    Custom = 2,
}
declare const enum AudioSourceCurveType {
    CustomRolloff = 0,
    SpatialBlend = 1,
    ReverbZoneMix = 2,
    Spread = 3,
}
declare const enum FFTWindow {
    Rectangular = 0,
    Triangle = 1,
    Hamming = 2,
    Hanning = 3,
    Blackman = 4,
    BlackmanHarris = 5,
}
declare const enum EaseType {
    Linear = 0,
    SineIn = 10,
    SineOut = 11,
    SineInOut = 12,
    QuadIn = 20,
    QuadOut = 21,
    QuadInOut = 22,
    CubicIn = 30,
    CubicOut = 31,
    CubicInOut = 32,
    QuartIn = 40,
    QuartOut = 41,
    QuartInOut = 42,
    QuintIn = 50,
    QuintOut = 51,
    QuintInOut = 52,
    ExpoIn = 60,
    ExpoOut = 61,
    ExpoInOut = 62,
    CircIn = 70,
    CircOut = 71,
    CircInOut = 72,
    BackIn = 80,
    BackOut = 81,
    BackInOut = 82,
    ElasticIn = 90,
    ElasticOut = 91,
    ElasticInOut = 92,
    BounceIn = 100,
    BounceOut = 101,
    BounceInOut = 102,
}
declare const enum ChatroomAgentMode {
    Unconnected = 0,
    Host = 1,
    Guest = 2,
}
declare const enum StereoScreenCaptureMode {
    LeftEye = 1,
    RightEye = 2,
    BothEyes = 3,
}
declare const enum ContextStyle {
    Block = 0,
    Prefab = 1,
    GreedyMeshingTiles = 2,
    PipeBlocks = 3,
    QuarterBlocks = 4,
    StaticMesh = 5,
}
declare const enum CollisionType {
    None = 0,
    Solid = 1,
    Slope = 2,
}
declare const enum CollisionFlags {
    None = 0,
    Sides = 1,
    CollidedSides = 1,
    Above = 2,
    CollidedAbove = 2,
    Below = 4,
    CollidedBelow = 4,
}
declare const enum LineTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
    Static = 4,
}
declare const enum LineAlignment {
    View = 0,
    Local = 1,
    TransformZ = 1,
}
declare const enum Result {
    InProgress = 0,
    Success = 1,
    ConnectionError = 2,
    ProtocolError = 3,
    DataProcessingError = 4,
}
declare const enum ToggleTransition {
    None = 0,
    Fade = 1,
}
declare const enum FitMode {
    Unconstrained = 0,
    MinSize = 1,
    PreferredSize = 2,
}
declare const enum AspectMode {
    None = 0,
    WidthControlsHeight = 1,
    HeightControlsWidth = 2,
    FitInParent = 3,
    EnvelopeParent = 4,
}
declare const enum MovementType {
    Unrestricted = 0,
    Elastic = 1,
    Clamped = 2,
}
declare const enum ScrollbarVisibility {
    Permanent = 0,
    AutoHide = 1,
    AutoHideAndExpandViewport = 2,
}
declare const enum SaveFolder {
    ApplicationData = 0,
    PicturesFolder = 1,
    Documents = 2,
}
declare const enum LogContext {
    Client = 0,
    Server = 1,
}
declare const enum Key {
    None = 0,
    Space = 1,
    Enter = 2,
    Tab = 3,
    Backquote = 4,
    Quote = 5,
    Semicolon = 6,
    Comma = 7,
    Period = 8,
    Slash = 9,
    Backslash = 10,
    LeftBracket = 11,
    RightBracket = 12,
    Minus = 13,
    Equals = 14,
    A = 15,
    B = 16,
    C = 17,
    D = 18,
    E = 19,
    F = 20,
    G = 21,
    H = 22,
    I = 23,
    J = 24,
    K = 25,
    L = 26,
    M = 27,
    N = 28,
    O = 29,
    P = 30,
    Q = 31,
    R = 32,
    S = 33,
    T = 34,
    U = 35,
    V = 36,
    W = 37,
    X = 38,
    Y = 39,
    Z = 40,
    Digit1 = 41,
    Digit2 = 42,
    Digit3 = 43,
    Digit4 = 44,
    Digit5 = 45,
    Digit6 = 46,
    Digit7 = 47,
    Digit8 = 48,
    Digit9 = 49,
    Digit0 = 50,
    LeftShift = 51,
    RightShift = 52,
    LeftAlt = 53,
    RightAlt = 54,
    AltGr = 54,
    LeftCtrl = 55,
    RightCtrl = 56,
    LeftMeta = 57,
    LeftWindows = 57,
    LeftCommand = 57,
    LeftApple = 57,
    RightCommand = 58,
    RightMeta = 58,
    RightWindows = 58,
    RightApple = 58,
    ContextMenu = 59,
    Escape = 60,
    LeftArrow = 61,
    RightArrow = 62,
    UpArrow = 63,
    DownArrow = 64,
    Backspace = 65,
    PageDown = 66,
    PageUp = 67,
    Home = 68,
    End = 69,
    Insert = 70,
    Delete = 71,
    CapsLock = 72,
    NumLock = 73,
    PrintScreen = 74,
    ScrollLock = 75,
    Pause = 76,
    NumpadEnter = 77,
    NumpadDivide = 78,
    NumpadMultiply = 79,
    NumpadPlus = 80,
    NumpadMinus = 81,
    NumpadPeriod = 82,
    NumpadEquals = 83,
    Numpad0 = 84,
    Numpad1 = 85,
    Numpad2 = 86,
    Numpad3 = 87,
    Numpad4 = 88,
    Numpad5 = 89,
    Numpad6 = 90,
    Numpad7 = 91,
    Numpad8 = 92,
    Numpad9 = 93,
    F1 = 94,
    F2 = 95,
    F3 = 96,
    F4 = 97,
    F5 = 98,
    F6 = 99,
    F7 = 100,
    F8 = 101,
    F9 = 102,
    F10 = 103,
    F11 = 104,
    F12 = 105,
    OEM1 = 106,
    OEM2 = 107,
    OEM3 = 108,
    OEM4 = 109,
    OEM5 = 110,
    IMESelected = 111,
}
declare const enum EngineRunMode {
    EDITOR = 0,
    PLAY = 1,
    BOTH = 2,
    NONE = -1,
}
declare const enum AccessorySlot {
    Root = 0,
    Head = 1,
    Hair = 2,
    Face = 3,
    Neck = 4,
    Torso = 5,
    RightHand = 6,
    LeftHand = 7,
    Waist = 8,
    Legs = 9,
    Feet = 10,
    Ears = 11,
    Nose = 12,
    TorsoOuter = 13,
    TorsoInner = 14,
    Backpack = 15,
    Hands = 16,
    HandsOuter = 17,
    LeftWrist = 18,
    RightWrist = 19,
    LegsOuter = 20,
    LegsInner = 21,
    FeetInner = 22,
    LeftFoot = 23,
    RightFoot = 24,
}
declare const enum VisibilityMode {
    ThirdPerson = 0,
    FirstPerson = 1,
    Both = 2,
}
declare const enum BodyMask {
    NONE = 0,
    HAIR = 1,
    FACE = 2,
    R_ARM_UPPER = 4,
    L_ARM_UPPER = 8,
    EARS = 16,
    UNUSED1 = 32,
    UNUSED2 = 64,
    L_ARM_LOWER = 128,
    L_HAND = 256,
    R_HAND = 512,
    R_ARM_LOWER = 1024,
    R_ARM_JOINTS = 2048,
    L_ARM_JOINTS = 4096,
    UNUSED5 = 8192,
    UNUSED6 = 16384,
    L_LEG_UPPER = 32768,
    HIPS = 65536,
    TORSO = 131072,
    R_LEG_UPPER = 262144,
    R_LEG_JOINTS = 524288,
    L_LEG_JOINTS = 1048576,
    UNUSED9 = 2097152,
    UNUSED10 = 4194304,
    L_LEG_LOWER = 8388608,
    L_FOOT = 16777216,
    R_FOOT = 33554432,
    R_LEG_LOWER = 67108864,
    UNUSED11 = 134217728,
    UNUSED12 = 268435456,
    UNUSED13 = 536870912,
    UNUSED14 = 1073741824,
}
declare const enum BlendMode {
    Normal = 0,
    Additive = 1,
    Screen = 2,
    Multiply = 3,
}
declare const enum ColorBleedMode {
    ImageColor = 0,
    ShadowColor = 1,
    Black = 2,
    White = 3,
    Plugin = 4,
}
declare const enum AirshipPlatform {
    iOS = 0,
    Android = 1,
    Mac = 2,
    Windows = 3,
    Linux = 4,
}
declare const enum BuildTarget {
    StandaloneOSX = 2,
    StandaloneOSXUniversal = 3,
    StandaloneOSXIntel = 4,
    StandaloneWindows = 5,
    WebPlayer = 6,
    WebPlayerStreamed = 7,
    iOS = 9,
    PS3 = 10,
    XBOX360 = 11,
    Android = 13,
    StandaloneLinux = 17,
    StandaloneWindows64 = 19,
    WebGL = 20,
    WSAPlayer = 21,
    StandaloneLinux64 = 24,
    StandaloneLinuxUniversal = 25,
    WP8Player = 26,
    StandaloneOSXIntel64 = 27,
    BlackBerry = 28,
    Tizen = 29,
    PSP2 = 30,
    PS4 = 31,
    PSM = 32,
    XboxOne = 33,
    SamsungTV = 34,
    N3DS = 35,
    WiiU = 36,
    tvOS = 37,
    Switch = 38,
    Lumin = 39,
    Stadia = 40,
    LinuxHeadlessSimulation = 41,
    CloudRendering = 41,
    GameCoreScarlett = 42,
    GameCoreXboxSeries = 42,
    GameCoreXboxOne = 43,
    PS5 = 44,
    EmbeddedLinux = 45,
    QNX = 46,
    Bratwurst = 47,
    NoTarget = -2,
    MetroPlayer = -1,
    iPhone = -1,
    BB10 = -1,
}
declare const enum BatteryStatus {
    Unknown = 0,
    Charging = 1,
    Discharging = 2,
    NotCharging = 3,
    Full = 4,
}
declare const enum OperatingSystemFamily {
    Other = 0,
    MacOSX = 1,
    Windows = 2,
    Linux = 3,
}
declare const enum DeviceType {
    Unknown = 0,
    Handheld = 1,
    Console = 2,
    Desktop = 3,
}
declare const enum GraphicsDeviceType {
    OpenGL2 = 0,
    Direct3D9 = 1,
    Direct3D11 = 2,
    PlayStation3 = 3,
    Null = 4,
    Xbox360 = 6,
    OpenGLES2 = 8,
    OpenGLES3 = 11,
    PlayStationVita = 12,
    PlayStation4 = 13,
    XboxOne = 14,
    PlayStationMobile = 15,
    Metal = 16,
    OpenGLCore = 17,
    Direct3D12 = 18,
    N3DS = 19,
    Vulkan = 21,
    Switch = 22,
    XboxOneD3D12 = 23,
    GameCoreXboxOne = 24,
    GameCoreXboxSeries = 25,
    PlayStation5 = 26,
    PlayStation5NGGC = 27,
    WebGPU = 28,
    GameCoreScarlett = -1,
}
declare const enum RenderingThreadingMode {
    Direct = 0,
    SingleThreaded = 1,
    MultiThreaded = 2,
    LegacyJobified = 3,
    NativeGraphicsJobs = 4,
    NativeGraphicsJobsWithoutRenderThread = 5,
    NativeGraphicsJobsSplitThreading = 6,
}
declare const enum FoveatedRenderingCaps {
    None = 0,
    FoveationImage = 1,
    NonUniformRaster = 2,
    ModeChangeOnlyBeforeRenderTargetSet = 4,
}
declare const enum CopyTextureSupport {
    None = 0,
    Basic = 1,
    Copy3D = 2,
    DifferentTypes = 4,
    TextureToRT = 8,
    RTToTexture = 16,
}
declare const enum NPOTSupport {
    None = 0,
    Restricted = 1,
    Full = 2,
}
declare const enum HDRDisplaySupportFlags {
    None = 0,
    Supported = 1,
    RuntimeSwitchable = 2,
    AutomaticTonemapping = 4,
}
declare const enum GraphicsFormatUsage {
    None = 0,
    Sample = 1,
    Linear = 2,
    Sparse = 4,
    Render = 16,
    Blend = 32,
    GetPixels = 64,
    SetPixels = 128,
    SetPixels32 = 256,
    ReadPixels = 512,
    LoadStore = 1024,
    MSAA2x = 2048,
    MSAA4x = 4096,
    MSAA8x = 8192,
    StencilSampling = 65536,
}
declare const enum ScaleMode {
    ConstantPixelSize = 0,
    ScaleWithScreenSize = 1,
    ConstantPhysicalSize = 2,
}
declare const enum ScreenMatchMode {
    MatchWidthOrHeight = 0,
    Expand = 1,
    Shrink = 2,
}
declare const enum Unit {
    Centimeters = 0,
    Millimeters = 1,
    Inches = 2,
    Points = 3,
    Picas = 4,
}
declare const enum Corner {
    UpperLeft = 0,
    UpperRight = 1,
    LowerLeft = 2,
    LowerRight = 3,
}
declare const enum Axis {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum Constraint {
    Flexible = 0,
    FixedColumnCount = 1,
    FixedRowCount = 2,
}
declare const enum FullScreenMode {
    ExclusiveFullScreen = 0,
    FullScreenWindow = 1,
    MaximizedWindow = 2,
    Windowed = 3,
}
declare const enum ScreenOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    Landscape = 3,
    LandscapeRight = 4,
    AutoRotation = 5,
}
declare const enum AirshipDeviceType {
    Tablet = 0,
    Phone = 1,
    Desktop = 2,
}
declare const enum OffMeshLinkType {
    LinkTypeManual = 0,
    LinkTypeDropDown = 1,
    LinkTypeJumpAcross = 2,
}
declare const enum NavMeshPathStatus {
    PathComplete = 0,
    PathPartial = 1,
    PathInvalid = 2,
}
declare const enum ObstacleAvoidanceType {
    NoObstacleAvoidance = 0,
    LowQualityObstacleAvoidance = 1,
    MedQualityObstacleAvoidance = 2,
    GoodQualityObstacleAvoidance = 3,
    HighQualityObstacleAvoidance = 4,
}
declare const enum NavMeshBuildDebugFlags {
    None = 0,
    InputGeometry = 1,
    Voxels = 2,
    Regions = 4,
    RawContours = 8,
    SimplifiedContours = 16,
    PolygonMeshes = 32,
    PolygonMeshesDetail = 64,
    All = 127,
}
declare const enum NavMeshObstacleShape {
    Capsule = 0,
    Box = 1,
}
declare const enum TouchScrollBehavior {
    Unrestricted = 0,
    Elastic = 1,
    Clamped = 2,
}
declare const enum NestedInteractionKind {
    Default = 0,
    StopScrolling = 1,
    ForwardScrolling = 2,
}
declare const enum DeltaSpeed {
    Fast = 0,
    Normal = 1,
    Slow = 2,
}
declare const enum SliderDirection {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum ScrollViewMode {
    Vertical = 0,
    Horizontal = 1,
    VerticalAndHorizontal = 2,
}
declare const enum DetailScatterMode {
    CoverageMode = 0,
    InstanceCountMode = 1,
}
declare const enum DetailRenderMode {
    GrassBillboard = 0,
    VertexLit = 1,
    Grass = 2,
}
declare const enum TerrainLayerSmoothnessSource {
    Constant = 0,
    DiffuseAlphaChannel = 1,
}
declare const enum TerrainHeightmapSyncControl {
    None = 0,
    HeightOnly = 1,
    HeightAndLod = 2,
}
declare const enum ColorGamut {
    sRGB = 0,
    Rec709 = 1,
    Rec2020 = 2,
    DisplayP3 = 3,
    HDR10 = 4,
    DolbyHDR = 5,
    P3D65G22 = 6,
}
declare const enum GraphicsTier {
    Tier1 = 0,
    Tier2 = 1,
    Tier3 = 2,
}
declare const enum OpenGLESVersion {
    None = 0,
    OpenGLES20 = 1,
    OpenGLES30 = 2,
    OpenGLES31 = 3,
    OpenGLES31AEP = 4,
    OpenGLES32 = 5,
}
declare const enum BoundingBoxMode {
    AutomaticLocal = 0,
    AutomaticWorld = 1,
    Custom = 2,
}
declare const enum ResolutionMode {
    Automatic = 0,
    Custom = 1,
}
declare const enum ProbePositionMode {
    CellCorner = 0,
    CellCenter = 1,
}
declare const enum RefreshMode {
    Automatic = 0,
    EveryFrame = 1,
    ViaScripting = 2,
}
declare const enum QualityMode {
    Low = 0,
    Normal = 1,
}
declare const enum DataFormat {
    HalfFloat = 0,
    Float = 1,
}
declare const enum EventTriggerType {
    PointerEnter = 0,
    PointerExit = 1,
    PointerDown = 2,
    PointerUp = 3,
    PointerClick = 4,
    Drag = 5,
    Drop = 6,
    Scroll = 7,
    UpdateSelected = 8,
    Select = 9,
    Deselect = 10,
    Move = 11,
    InitializePotentialDrag = 12,
    BeginDrag = 13,
    EndDrag = 14,
    Submit = 15,
    Cancel = 16,
}
declare const enum TerrainRenderFlags {
    heightmap = 1,
    Heightmap = 1,
    trees = 2,
    Trees = 2,
    details = 4,
    Details = 4,
    all = 7,
    All = 7,
}
declare const enum TreeMotionVectorModeOverride {
    CameraMotionOnly = 0,
    PerObjectMotion = 1,
    ForceNoMotion = 2,
    InheritFromPrototype = 3,
}
declare const enum BlockingObjects {
    None = 0,
    TwoD = 1,
    ThreeD = 2,
    All = 3,
}
declare const enum SerializedPropertyType {
    Integer = 0,
    Boolean = 1,
    Float = 2,
    String = 3,
    Color = 4,
    ObjectReference = 5,
    LayerMask = 6,
    Enum = 7,
    Vector2 = 8,
    Vector3 = 9,
    Vector4 = 10,
    Rect = 11,
    ArraySize = 12,
    Character = 13,
    AnimationCurve = 14,
    Bounds = 15,
    Gradient = 16,
    Quaternion = 17,
    ExposedReference = 18,
    FixedBufferSize = 19,
    Vector2Int = 20,
    Vector3Int = 21,
    RectInt = 22,
    BoundsInt = 23,
    ManagedReference = 24,
    Hash128 = 25,
    Generic = -1,
}
declare const enum SerializedPropertyNumericType {
    Unknown = 0,
    Int8 = 1,
    UInt8 = 2,
    Int16 = 3,
    UInt16 = 4,
    Int32 = 5,
    UInt32 = 6,
    Int64 = 7,
    UInt64 = 8,
    Float = 100,
    Double = 101,
}
declare const enum DepthOfFieldMode {
    Off = 0,
    Gaussian = 1,
    Bokeh = 2,
}
declare const enum DisplayType {
    Checkbox = 0,
    EnumPopup = 1,
}
declare const enum RemovePlayerOptions {
    KeepActive = 0,
    Unspawn = 1,
    Destroy = 2,
}
declare const enum ConnectionQuality {
    ESTIMATING = 0,
    POOR = 1,
    FAIR = 2,
    GOOD = 3,
    EXCELLENT = 4,
}
declare const enum ConnectionQualityMethod {
    Simple = 0,
    Pragmatic = 1,
}
declare const enum CoordinateSpace {
    Local = 0,
    World = 1,
}
declare const enum PredictionMode {
    Smooth = 0,
    Fast = 1,
}
declare const enum CellLayout {
    Rectangle = 0,
    Hexagon = 1,
    Isometric = 2,
    IsometricZAsY = 3,
}
declare const enum CellSwizzle {
    XYZ = 0,
    XZY = 1,
    YXZ = 2,
    YZX = 3,
    ZXY = 4,
    ZYX = 5,
}
declare const enum VFXSpace {
    Local = 0,
    World = 1,
    None = -1,
}
declare const enum VFXSpawnerLoopState {
    Finished = 0,
    DelayingBeforeLoop = 1,
    Looping = 2,
    DelayingAfterLoop = 3,
}
declare const enum LoadingStatus {
    NotLoading = 0,
    Loading = 1,
    Loaded = 2,
}

    
interface RaycastHit {
    readonly collider: Collider;
    readonly colliderInstanceID: number;
    point: Vector3;
    normal: Vector3;
    barycentricCoordinate: Vector3;
    distance: number;
    readonly triangleIndex: number;
    readonly textureCoord: Vector2;
    readonly textureCoord2: Vector2;
    readonly transform: Transform;
    readonly rigidbody: Rigidbody;
    readonly articulationBody: ArticulationBody;
    readonly lightmapCoord: Vector2;





}
    
    
    
    
    
    
    
    
    
interface FrustumPlanes {
    left: number;
    right: number;
    bottom: number;
    top: number;
    zNear: number;
    zFar: number;





}
    
    
    
interface Plane {
    normal: Vector3;
    distance: number;
    readonly flipped: Plane;



    ClosestPointOnPlane(point: Vector3): Vector3;
    Flip(): void;
    GetDistanceToPoint(point: Vector3): number;
    GetSide(point: Vector3): boolean;
    Raycast(ray: Ray, enter: unknown): boolean;
    SameSide(inPt0: Vector3, inPt1: Vector3): boolean;
    Set3Points(a: Vector3, b: Vector3, c: Vector3): void;
    SetNormalAndPosition(inNormal: Vector3, inPoint: Vector3): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
    Translate(translation: Vector3): void;


}
    
    
    
interface PlaneConstructor {


    new(inNormal: Vector3, inPoint: Vector3): Plane;
    new(inNormal: Vector3, d: number): Plane;
    new(a: Vector3, b: Vector3, c: Vector3): Plane;


    Translate(plane: Plane, translation: Vector3): Plane;

}
declare const Plane: PlaneConstructor;
    
    
    
interface Scene {
    readonly handle: number;
    readonly path: string;
    name: string;
    readonly isLoaded: boolean;
    readonly buildIndex: number;
    readonly isDirty: boolean;
    readonly rootCount: number;
    isSubScene: boolean;



    Equals(other: unknown): boolean;
    GetHashCode(): number;
    GetRootGameObjects(): CSArray<GameObject>;
    GetRootGameObjects(rootGameObjects: CSArray<GameObject>): void;
    IsValid(): boolean;


}
    
interface TagHandle {



    ToString(): string;


}
    
interface TagHandleConstructor {




    GetExistingTag(tagName: string): TagHandle;

}
declare const TagHandle: TagHandleConstructor;
    
    
    
    
    
    
    
    
interface Rigidbody extends Component {
    velocity: Vector3;
    angularVelocity: Vector3;
    drag: number;
    angularDrag: number;
    mass: number;
    useGravity: boolean;
    maxDepenetrationVelocity: number;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints;
    collisionDetectionMode: CollisionDetectionMode;
    automaticCenterOfMass: boolean;
    centerOfMass: Vector3;
    readonly worldCenterOfMass: Vector3;
    automaticInertiaTensor: boolean;
    inertiaTensorRotation: Quaternion;
    inertiaTensor: Vector3;
    detectCollisions: boolean;
    position: Vector3;
    rotation: Quaternion;
    interpolation: RigidbodyInterpolation;
    solverIterations: number;
    sleepThreshold: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    solverVelocityIterations: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;



    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: ForceMode): void;
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number): void;
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number): void;
    AddForce(force: Vector3, mode: ForceMode): void;
    AddForce(force: Vector3): void;
    AddForce(x: number, y: number, z: number, mode: ForceMode): void;
    AddForce(x: number, y: number, z: number): void;
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    AddRelativeForce(force: Vector3): void;
    AddRelativeForce(x: number, y: number, z: number, mode: ForceMode): void;
    AddRelativeForce(x: number, y: number, z: number): void;
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    AddRelativeTorque(torque: Vector3): void;
    AddRelativeTorque(x: number, y: number, z: number, mode: ForceMode): void;
    AddRelativeTorque(x: number, y: number, z: number): void;
    AddTorque(torque: Vector3, mode: ForceMode): void;
    AddTorque(torque: Vector3): void;
    AddTorque(x: number, y: number, z: number, mode: ForceMode): void;
    AddTorque(x: number, y: number, z: number): void;
    ClosestPointOnBounds(position: Vector3): Vector3;
    GetAccumulatedForce(step: number): Vector3;
    GetAccumulatedForce(): Vector3;
    GetAccumulatedTorque(step: number): Vector3;
    GetAccumulatedTorque(): Vector3;
    GetPointVelocity(worldPoint: Vector3): Vector3;
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    IsSleeping(): boolean;
    Move(position: Vector3, rotation: Quaternion): void;
    MovePosition(position: Vector3): void;
    MoveRotation(rot: Quaternion): void;
    PublishTransform(): void;
    ResetCenterOfMass(): void;
    ResetInertiaTensor(): void;
    SetDensity(density: number): void;
    Sleep(): void;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown): boolean;
    SweepTestAll(direction: Vector3, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3): CSArray<RaycastHit>;
    WakeUp(): void;


}
    
    
    
interface RigidbodyConstructor {


    new(): Rigidbody;



}
declare const Rigidbody: RigidbodyConstructor;
    
interface Behaviour extends Component {
    enabled: boolean;
    readonly isActiveAndEnabled: boolean;





}
    
interface BehaviourConstructor {


    new(): Behaviour;



}
declare const Behaviour: BehaviourConstructor;
    
interface ArticulationBody extends Behaviour {
    jointType: ArticulationJointType;
    anchorPosition: Vector3;
    parentAnchorPosition: Vector3;
    anchorRotation: Quaternion;
    parentAnchorRotation: Quaternion;
    readonly isRoot: boolean;
    matchAnchors: boolean;
    linearLockX: ArticulationDofLock;
    linearLockY: ArticulationDofLock;
    linearLockZ: ArticulationDofLock;
    swingYLock: ArticulationDofLock;
    swingZLock: ArticulationDofLock;
    twistLock: ArticulationDofLock;
    xDrive: ArticulationDrive;
    yDrive: ArticulationDrive;
    zDrive: ArticulationDrive;
    immovable: boolean;
    useGravity: boolean;
    linearDamping: number;
    angularDamping: number;
    jointFriction: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    velocity: Vector3;
    angularVelocity: Vector3;
    mass: number;
    automaticCenterOfMass: boolean;
    centerOfMass: Vector3;
    readonly worldCenterOfMass: Vector3;
    automaticInertiaTensor: boolean;
    inertiaTensor: Vector3;
    inertiaTensorRotation: Quaternion;
    sleepThreshold: number;
    solverIterations: number;
    solverVelocityIterations: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    maxJointVelocity: number;
    maxDepenetrationVelocity: number;
    jointPosition: ArticulationReducedSpace;
    jointVelocity: ArticulationReducedSpace;
    jointAcceleration: ArticulationReducedSpace;
    jointForce: ArticulationReducedSpace;
    readonly driveForce: ArticulationReducedSpace;
    readonly dofCount: number;
    readonly index: number;
    collisionDetectionMode: CollisionDetectionMode;



    AddForce(force: Vector3, mode: ForceMode): void;
    AddForce(force: Vector3): void;
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    AddRelativeForce(force: Vector3): void;
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    AddRelativeTorque(torque: Vector3): void;
    AddTorque(torque: Vector3, mode: ForceMode): void;
    AddTorque(torque: Vector3): void;
    GetAccumulatedForce(step: number): Vector3;
    GetAccumulatedForce(): Vector3;
    GetAccumulatedTorque(step: number): Vector3;
    GetAccumulatedTorque(): Vector3;
    GetClosestPoint(point: Vector3): Vector3;
    GetDenseJacobian(jacobian: unknown): number;
    GetDofStartIndices(dofStartIndices: CSArray<number>): number;
    GetDriveForces(forces: CSArray<number>): number;
    GetDriveTargets(targets: CSArray<number>): number;
    GetDriveTargetVelocities(targetVelocities: CSArray<number>): number;
    GetJointAccelerations(accelerations: CSArray<number>): number;
    GetJointCoriolisCentrifugalForces(forces: CSArray<number>): number;
    GetJointExternalForces(forces: CSArray<number>, step: number): number;
    GetJointForces(forces: CSArray<number>): number;
    GetJointForcesForAcceleration(acceleration: ArticulationReducedSpace): ArticulationReducedSpace;
    GetJointGravityForces(forces: CSArray<number>): number;
    GetJointPositions(positions: CSArray<number>): number;
    GetJointVelocities(velocities: CSArray<number>): number;
    GetPointVelocity(worldPoint: Vector3): Vector3;
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    IsSleeping(): boolean;
    PublishTransform(): void;
    ResetCenterOfMass(): void;
    ResetInertiaTensor(): void;
    SetDriveDamping(axis: ArticulationDriveAxis, value: number): void;
    SetDriveForceLimit(axis: ArticulationDriveAxis, value: number): void;
    SetDriveLimits(axis: ArticulationDriveAxis, lower: number, upper: number): void;
    SetDriveStiffness(axis: ArticulationDriveAxis, value: number): void;
    SetDriveTarget(axis: ArticulationDriveAxis, value: number): void;
    SetDriveTargets(targets: CSArray<number>): void;
    SetDriveTargetVelocities(targetVelocities: CSArray<number>): void;
    SetDriveTargetVelocity(axis: ArticulationDriveAxis, value: number): void;
    SetJointForces(forces: CSArray<number>): void;
    SetJointPositions(positions: CSArray<number>): void;
    SetJointVelocities(velocities: CSArray<number>): void;
    Sleep(): void;
    SnapAnchorToClosestContact(): void;
    TeleportRoot(position: Vector3, rotation: Quaternion): void;
    WakeUp(): void;


}
    
interface ArticulationDrive {
    lowerLimit: number;
    upperLimit: number;
    stiffness: number;
    damping: number;
    forceLimit: number;
    target: number;
    targetVelocity: number;
    driveType: ArticulationDriveType;





}
    
interface ArticulationReducedSpace {
    dofCount: number;
    Item: number;





}
    
interface ArticulationReducedSpaceConstructor {


    new(a: number): ArticulationReducedSpace;
    new(a: number, b: number): ArticulationReducedSpace;
    new(a: number, b: number, c: number): ArticulationReducedSpace;



}
declare const ArticulationReducedSpace: ArticulationReducedSpaceConstructor;
    
interface ArticulationBodyConstructor {


    new(): ArticulationBody;



}
declare const ArticulationBody: ArticulationBodyConstructor;
    
interface Bounds {
    center: Vector3;
    size: Vector3;
    extents: Vector3;
    min: Vector3;
    max: Vector3;



    ClosestPoint(point: Vector3): Vector3;
    Contains(point: Vector3): boolean;
    Encapsulate(point: Vector3): void;
    Encapsulate(bounds: Bounds): void;
    Equals(other: unknown): boolean;
    Equals(other: Bounds): boolean;
    Expand(amount: number): void;
    Expand(amount: Vector3): void;
    GetHashCode(): number;
    IntersectRay(ray: Ray): boolean;
    IntersectRay(ray: Ray, distance: unknown): boolean;
    Intersects(bounds: Bounds): boolean;
    SetMinMax(min: Vector3, max: Vector3): void;
    SqrDistance(point: Vector3): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;


}
    
interface BoundsConstructor {


    new(center: Vector3, size: Vector3): Bounds;



}
declare const Bounds: BoundsConstructor;
    
interface GeometryHolder {
    readonly Type: GeometryType;



    As<T>(): T;


}
    
interface GeometryHolderConstructor {


    new(): GeometryHolder;


    Create<T>(geometry: T): GeometryHolder;

}
declare const GeometryHolder: GeometryHolderConstructor;
    
interface PhysicMaterial extends Object {
    bounciness: number;
    dynamicFriction: number;
    staticFriction: number;
    frictionCombine: PhysicMaterialCombine;
    bounceCombine: PhysicMaterialCombine;





}
    
interface PhysicMaterialConstructor {


    new(): PhysicMaterial;
    new(name: string): PhysicMaterial;



}
declare const PhysicMaterial: PhysicMaterialConstructor;
    
    
    
    
    
interface PhysicsScene {



    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene): boolean;
    GetHashCode(): number;
    InterpolateBodies(): void;
    IsEmpty(): boolean;
    IsValid(): boolean;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>): number;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapSphere(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, raycastHits: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    ResetInterpolationPoses(): void;
    RunSimulationStages(step: number, stages: SimulationStage, options: SimulationOption): void;
    Simulate(step: number): void;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    ToString(): string;


}
    
interface ModifiableContactPair {
    rotation: Quaternion;
    position: Vector3;
    otherRotation: Quaternion;
    otherPosition: Vector3;
    readonly colliderInstanceID: number;
    readonly otherColliderInstanceID: number;
    readonly bodyInstanceID: number;
    readonly otherBodyInstanceID: number;
    readonly bodyVelocity: Vector3;
    readonly bodyAngularVelocity: Vector3;
    readonly otherBodyVelocity: Vector3;
    readonly otherBodyAngularVelocity: Vector3;
    readonly contactCount: number;
    massProperties: ModifiableMassProperties;



    GetBounciness(i: number): number;
    GetDynamicFriction(i: number): number;
    GetFaceIndex(i: number): number;
    GetMaxImpulse(i: number): number;
    GetNormal(i: number): Vector3;
    GetPoint(i: number): Vector3;
    GetSeparation(i: number): number;
    GetStaticFriction(i: number): number;
    GetTargetVelocity(i: number): Vector3;
    IgnoreContact(i: number): void;
    SetBounciness(i: number, bounciness: number): void;
    SetDynamicFriction(i: number, dynamicFriction: number): void;
    SetMaxImpulse(i: number, value: number): void;
    SetNormal(i: number, normal: Vector3): void;
    SetPoint(i: number, v: Vector3): void;
    SetSeparation(i: number, separation: number): void;
    SetStaticFriction(i: number, staticFriction: number): void;
    SetTargetVelocity(i: number, velocity: Vector3): void;


}
    
interface ModifiableMassProperties {
    inverseMassScale: number;
    inverseInertiaScale: number;
    otherInverseMassScale: number;
    otherInverseInertiaScale: number;





}
    
    
interface Physics2D {





}
    
interface PhysicsScene2D {
    readonly subStepCount: number;
    readonly subStepLostTime: number;



    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene2D): boolean;
    GetHashCode(): number;
    GetRayIntersection(ray: Ray, distance: number, layerMask: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    IsEmpty(): boolean;
    IsValid(): boolean;
    Linecast(start: Vector2, end: Vector2, layerMask: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, layerMask: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D): Collider2D;
    OverlapCircle(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, layerMask: number): Collider2D;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D): Collider2D;
    OverlapPoint(point: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Simulate(deltaTime: number): boolean;
    Simulate(deltaTime: number, simulationLayers: number): boolean;
    ToString(): string;


}
    
interface RaycastHit2D {
    centroid: Vector2;
    point: Vector2;
    normal: Vector2;
    distance: number;
    fraction: number;
    readonly collider: Collider2D;
    readonly rigidbody: Rigidbody2D;
    readonly transform: Transform;



    CompareTo(other: RaycastHit2D): number;


}
    
interface Collider2D extends Behaviour {
    density: number;
    isTrigger: boolean;
    usedByEffector: boolean;
    compositeOperation: CompositeOperation;
    compositeOrder: number;
    readonly composite: CompositeCollider2D;
    offset: Vector2;
    readonly attachedRigidbody: Rigidbody2D;
    readonly localToWorldMatrix: Matrix4x4;
    readonly shapeCount: number;
    readonly bounds: Bounds;
    readonly errorState: ColliderErrorState2D;
    readonly compositeCapable: boolean;
    sharedMaterial: PhysicsMaterial2D;
    layerOverridePriority: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    forceSendLayers: LayerMask;
    forceReceiveLayers: LayerMask;
    contactCaptureLayers: LayerMask;
    callbackLayers: LayerMask;
    readonly friction: number;
    readonly bounciness: number;



    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(position: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(position: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    ClosestPoint(position: Vector2): Vector2;
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean): Mesh;
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean, useDelaunay: boolean): Mesh;
    Distance(collider: Collider2D): ColliderDistance2D;
    Distance(thisPosition: Vector2, thisAngle: number, collider: Collider2D, position: Vector2, angle: number): ColliderDistance2D;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetShapeBounds(bounds: CSArray<Bounds>, useRadii: boolean, useWorldSpace: boolean): Bounds;
    GetShapeHash(): number;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: number, shapeCount: number): number;
    IsTouching(collider: Collider2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    IsTouchingLayers(layerMask: number): boolean;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(results: CSArray<Collider2D>): number;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): boolean;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;


}
    
interface CompositeCollider2D extends Collider2D {
    geometryType: GeometryType;
    generationType: GenerationType;
    useDelaunayMesh: boolean;
    vertexDistance: number;
    edgeRadius: number;
    offsetDistance: number;
    readonly pathCount: number;
    readonly pointCount: number;



    GenerateGeometry(): void;
    GetCompositedColliders(colliders: CSArray<Collider2D>): number;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPathPointCount(index: number): number;


}
    
interface CompositeCollider2DConstructor {


    new(): CompositeCollider2D;



}
declare const CompositeCollider2D: CompositeCollider2DConstructor;
    
interface Rigidbody2D extends Component {
    position: Vector2;
    rotation: number;
    velocity: Vector2;
    velocityX: number;
    velocityY: number;
    angularVelocity: number;
    useAutoMass: boolean;
    mass: number;
    sharedMaterial: PhysicsMaterial2D;
    centerOfMass: Vector2;
    readonly worldCenterOfMass: Vector2;
    inertia: number;
    drag: number;
    angularDrag: number;
    gravityScale: number;
    bodyType: RigidbodyType2D;
    useFullKinematicContacts: boolean;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints2D;
    simulated: boolean;
    interpolation: RigidbodyInterpolation2D;
    sleepMode: RigidbodySleepMode2D;
    collisionDetectionMode: CollisionDetectionMode2D;
    readonly attachedColliderCount: number;
    totalForce: Vector2;
    totalTorque: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    readonly localToWorldMatrix: Matrix4x4;



    AddForce(force: Vector2): void;
    AddForce(force: Vector2, mode: ForceMode2D): void;
    AddForceAtPosition(force: Vector2, position: Vector2): void;
    AddForceAtPosition(force: Vector2, position: Vector2, mode: ForceMode2D): void;
    AddForceX(force: number, mode: ForceMode2D): void;
    AddForceY(force: number, mode: ForceMode2D): void;
    AddRelativeForce(relativeForce: Vector2): void;
    AddRelativeForce(relativeForce: Vector2, mode: ForceMode2D): void;
    AddRelativeForceX(force: number, mode: ForceMode2D): void;
    AddRelativeForceY(force: number, mode: ForceMode2D): void;
    AddTorque(torque: number): void;
    AddTorque(torque: number, mode: ForceMode2D): void;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(position: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(position: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    ClosestPoint(position: Vector2): Vector2;
    Distance(collider: Collider2D): ColliderDistance2D;
    Distance(thisPosition: Vector2, thisAngle: number, collider: Collider2D, position: Vector2, angle: number): ColliderDistance2D;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetAttachedColliders(results: CSArray<Collider2D>, findTriggers: boolean): number;
    GetAttachedColliders(results: CSArray<Collider2D>, findTriggers: boolean): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetPoint(point: Vector2): Vector2;
    GetPointVelocity(point: Vector2): Vector2;
    GetRelativePoint(relativePoint: Vector2): Vector2;
    GetRelativePointVelocity(relativePoint: Vector2): Vector2;
    GetRelativeVector(relativeVector: Vector2): Vector2;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetVector(vector: Vector2): Vector2;
    IsAwake(): boolean;
    IsSleeping(): boolean;
    IsTouching(collider: Collider2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    IsTouchingLayers(layerMask: number): boolean;
    MovePosition(position: Vector2): void;
    MovePositionAndRotation(position: Vector2, angle: number): void;
    MovePositionAndRotation(position: Vector2, rotation: Quaternion): void;
    MoveRotation(angle: number): void;
    MoveRotation(rotation: Quaternion): void;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(results: CSArray<Collider2D>): number;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): boolean;
    SetRotation(angle: number): void;
    SetRotation(rotation: Quaternion): void;
    Sleep(): void;
    Slide(velocity: Vector2, deltaTime: number, slideMovement: SlideMovement): SlideResults;
    WakeUp(): void;


}
    
interface PhysicsMaterial2D extends Object {
    bounciness: number;
    friction: number;





}
    
interface PhysicsMaterial2DConstructor {


    new(): PhysicsMaterial2D;
    new(name: string): PhysicsMaterial2D;



}
declare const PhysicsMaterial2D: PhysicsMaterial2DConstructor;
    
interface ContactFilter2D {
    useTriggers: boolean;
    useLayerMask: boolean;
    useDepth: boolean;
    useOutsideDepth: boolean;
    useNormalAngle: boolean;
    useOutsideNormalAngle: boolean;
    layerMask: LayerMask;
    minDepth: number;
    maxDepth: number;
    minNormalAngle: number;
    maxNormalAngle: number;
    readonly isFiltering: boolean;



    ClearDepth(): void;
    ClearLayerMask(): void;
    ClearNormalAngle(): void;
    IsFilteringDepth(obj: GameObject): boolean;
    IsFilteringLayerMask(obj: GameObject): boolean;
    IsFilteringNormalAngle(normal: Vector2): boolean;
    IsFilteringNormalAngle(angle: number): boolean;
    IsFilteringTrigger(collider: Collider2D): boolean;
    NoFilter(): ContactFilter2D;
    SetDepth(minDepth: number, maxDepth: number): void;
    SetLayerMask(layerMask: LayerMask): void;
    SetNormalAngle(minNormalAngle: number, maxNormalAngle: number): void;


}
    
interface ContactFilter2DConstructor {
    NormalAngleUpperLimit: number;





}
declare const ContactFilter2D: ContactFilter2DConstructor;
    
interface ColliderDistance2D {
    pointA: Vector2;
    pointB: Vector2;
    readonly normal: Vector2;
    distance: number;
    readonly isOverlapped: boolean;
    isValid: boolean;





}
    
interface ContactPoint2D {
    readonly point: Vector2;
    readonly normal: Vector2;
    readonly separation: number;
    readonly normalImpulse: number;
    readonly tangentImpulse: number;
    readonly relativeVelocity: Vector2;
    readonly collider: Collider2D;
    readonly otherCollider: Collider2D;
    readonly rigidbody: Rigidbody2D;
    readonly otherRigidbody: Rigidbody2D;
    readonly enabled: boolean;





}
    
interface PhysicsShapeGroup2D {
    readonly shapeCount: number;
    readonly vertexCount: number;
    localToWorldMatrix: Matrix4x4;



    Add(physicsShapeGroup: PhysicsShapeGroup2D): void;
    AddBox(center: Vector2, size: Vector2, angle: number, edgeRadius: number): number;
    AddCapsule(vertex0: Vector2, vertex1: Vector2, radius: number): number;
    AddCircle(center: Vector2, radius: number): number;
    AddEdges(vertices: CSArray<Vector2>, edgeRadius: number): number;
    AddEdges(vertices: CSArray<Vector2>, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2, edgeRadius: number): number;
    AddPolygon(vertices: CSArray<Vector2>): number;
    Clear(): void;
    DeleteShape(shapeIndex: number): void;
    GetShape(shapeIndex: number): PhysicsShape2D;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeVertex(shapeIndex: number, vertexIndex: number): Vector2;
    GetShapeVertices(shapeIndex: number, vertices: CSArray<Vector2>): void;
    SetShapeAdjacentVertices(shapeIndex: number, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2): void;
    SetShapeRadius(shapeIndex: number, radius: number): void;
    SetShapeVertex(shapeIndex: number, vertexIndex: number, vertex: Vector2): void;


}
    
interface PhysicsShape2D {
    shapeType: PhysicsShapeType2D;
    radius: number;
    vertexStartIndex: number;
    vertexCount: number;
    useAdjacentStart: boolean;
    useAdjacentEnd: boolean;
    adjacentStart: Vector2;
    adjacentEnd: Vector2;





}
    
interface PhysicsShapeGroup2DConstructor {


    new(shapeCapacity: number, vertexCapacity: number): PhysicsShapeGroup2D;



}
declare const PhysicsShapeGroup2D: PhysicsShapeGroup2DConstructor;
    
interface SlideResults {
    remainingVelocity: Vector2;
    position: Vector2;
    iterationsUsed: number;
    slideHit: RaycastHit2D;
    surfaceHit: RaycastHit2D;





}
    
interface SlideMovement {
    maxIterations: number;
    surfaceSlideAngle: number;
    gravitySlipAngle: number;
    surfaceUp: Vector2;
    surfaceAnchor: Vector2;
    gravity: Vector2;
    startPosition: Vector2;
    selectedCollider: Collider2D;
    layerMask: LayerMask;
    useLayerMask: boolean;
    useStartPosition: boolean;
    useNoMove: boolean;
    useSimulationMove: boolean;
    useAttachedTriggers: boolean;



    SetLayerMask(mask: LayerMask): void;
    SetStartPosition(position: Vector2): void;


}
    
interface SlideMovementConstructor {


    new(): SlideMovement;



}
declare const SlideMovement: SlideMovementConstructor;
    
interface Rigidbody2DConstructor {


    new(): Rigidbody2D;



}
declare const Rigidbody2D: Rigidbody2DConstructor;
    
interface Mesh extends Object {
    indexFormat: IndexFormat;
    readonly vertexBufferCount: number;
    vertexBufferTarget: Target;
    indexBufferTarget: Target;
    readonly blendShapeCount: number;
    readonly bindposeCount: number;
    bindposes: CSArray<Matrix4x4>;
    readonly isReadable: boolean;
    readonly vertexCount: number;
    subMeshCount: number;
    bounds: Bounds;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uv: CSArray<Vector2>;
    uv2: CSArray<Vector2>;
    uv3: CSArray<Vector2>;
    uv4: CSArray<Vector2>;
    uv5: CSArray<Vector2>;
    uv6: CSArray<Vector2>;
    uv7: CSArray<Vector2>;
    uv8: CSArray<Vector2>;
    colors: CSArray<Color>;
    colors32: CSArray<Color32>;
    readonly vertexAttributeCount: number;
    triangles: CSArray<number>;
    boneWeights: CSArray<BoneWeight>;
    readonly skinWeightBufferLayout: SkinWeights;



    AddBlendShapeFrame(shapeName: string, frameWeight: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    Clear(keepVertexLayout: boolean): void;
    Clear(): void;
    ClearBlendShapes(): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean, hasLightmapData: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>): void;
    GetAllBoneWeights(): CSArray<BoneWeight1>;
    GetBaseVertex(submesh: number): number;
    GetBindposes(): CSArray<Matrix4x4>;
    GetBindposes(bindposes: CSArray<Matrix4x4>): void;
    GetBlendShapeBuffer(layout: BlendShapeBufferLayout): GraphicsBuffer;
    GetBlendShapeBuffer(): GraphicsBuffer;
    GetBlendShapeBufferRange(blendShapeIndex: number): BlendShapeBufferRange;
    GetBlendShapeFrameCount(shapeIndex: number): number;
    GetBlendShapeFrameVertices(shapeIndex: number, frameIndex: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    GetBlendShapeFrameWeight(shapeIndex: number, frameIndex: number): number;
    GetBlendShapeIndex(blendShapeName: string): number;
    GetBlendShapeName(shapeIndex: number): string;
    GetBonesPerVertex(): CSArray<number>;
    GetBoneWeightBuffer(layout: SkinWeights): GraphicsBuffer;
    GetBoneWeights(boneWeights: CSArray<BoneWeight>): void;
    GetColors(colors: CSArray<Color>): void;
    GetColors(colors: CSArray<Color32>): void;
    GetIndexBuffer(): GraphicsBuffer;
    GetIndexCount(submesh: number): number;
    GetIndexStart(submesh: number): number;
    GetIndices(submesh: number): CSArray<number>;
    GetIndices(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetIndices(indices: CSArray<number>, submesh: number): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNativeIndexBufferPtr(): unknown;
    GetNativeVertexBufferPtr(index: number): unknown;
    GetNormals(normals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(tangents: CSArray<Vector4>): void;
    GetTopology(submesh: number): MeshTopology;
    GetTriangles(submesh: number): CSArray<number>;
    GetTriangles(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetTriangles(triangles: CSArray<number>, submesh: number): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetUVDistributionMetric(uvSetIndex: number): number;
    GetUVs(channel: number, uvs: CSArray<Vector2>): void;
    GetUVs(channel: number, uvs: CSArray<Vector3>): void;
    GetUVs(channel: number, uvs: CSArray<Vector4>): void;
    GetVertexAttribute(index: number): VertexAttributeDescriptor;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributes(): CSArray<VertexAttributeDescriptor>;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBuffer(index: number): GraphicsBuffer;
    GetVertexBufferStride(stream: number): number;
    GetVertices(vertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    MarkDynamic(): void;
    MarkModified(): void;
    Optimize(): void;
    OptimizeIndexBuffers(): void;
    OptimizeReorderVertexBuffer(): void;
    RecalculateBounds(): void;
    RecalculateBounds(flags: MeshUpdateFlags): void;
    RecalculateNormals(): void;
    RecalculateNormals(flags: MeshUpdateFlags): void;
    RecalculateTangents(): void;
    RecalculateTangents(flags: MeshUpdateFlags): void;
    RecalculateUVDistributionMetric(uvSetIndex: number, uvAreaThreshold: number): void;
    RecalculateUVDistributionMetrics(uvAreaThreshold: number): void;
    SetBindposes(poses: CSArray<Matrix4x4>): void;
    SetBoneWeights(bonesPerVertex: CSArray<number>, weights: CSArray<BoneWeight1>): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors<T>(inColors: CSArray<T>): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals<T>(inNormals: CSArray<T>): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents<T>(inTangents: CSArray<T>): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices<T>(inVertices: CSArray<T>): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    UploadMeshData(markNoLongerReadable: boolean): void;


}
    
    
    
interface Color32 {
    r: number;
    g: number;
    b: number;
    a: number;
    Item: number;



    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;


}
    
interface Color32Constructor {


    new(r: number, g: number, b: number, a: number): Color32;


    Lerp(a: Color32, b: Color32, t: number): Color32;
    LerpUnclamped(a: Color32, b: Color32, t: number): Color32;

}
declare const Color32: Color32Constructor;
    
interface BoneWeight {
    weight0: number;
    weight1: number;
    weight2: number;
    weight3: number;
    boneIndex0: number;
    boneIndex1: number;
    boneIndex2: number;
    boneIndex3: number;



    Equals(other: unknown): boolean;
    Equals(other: BoneWeight): boolean;
    GetHashCode(): number;


}
    
interface CombineInstance {
    mesh: Mesh;
    subMeshIndex: number;
    transform: Matrix4x4;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;





}
    
interface BoneWeight1 {
    weight: number;
    boneIndex: number;



    Equals(other: unknown): boolean;
    Equals(other: BoneWeight1): boolean;
    GetHashCode(): number;


}
    
interface GraphicsBuffer {
    readonly count: number;
    readonly stride: number;
    readonly target: Target;
    readonly usageFlags: UsageFlags;
    readonly bufferHandle: GraphicsBufferHandle;
    name: string;



    Dispose(): void;
    GetData(data: unknown): void;
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    GetNativeBufferPtr(): unknown;
    IsValid(): boolean;
    LockBufferForWrite<T>(bufferStartIndex: number, count: number): CSArray<T>;
    Release(): void;
    SetCounterValue(counterValue: number): void;
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    SetData(data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    UnlockBufferAfterWrite<T>(countWritten: number): void;


}
    
interface GraphicsBufferHandle {
    readonly value: number;



    CompareTo(other: GraphicsBufferHandle): number;
    Equals(obj: unknown): boolean;
    Equals(other: GraphicsBufferHandle): boolean;
    GetHashCode(): number;


}
    
interface ComputeBuffer {
    readonly count: number;
    readonly stride: number;
    name: string;



    BeginWrite<T>(computeBufferStartIndex: number, count: number): CSArray<T>;
    Dispose(): void;
    EndWrite<T>(countWritten: number): void;
    GetData(data: unknown): void;
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    GetNativeBufferPtr(): unknown;
    IsValid(): boolean;
    Release(): void;
    SetCounterValue(counterValue: number): void;
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    SetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;


}
    
interface ComputeBufferConstructor {


    new(count: number, stride: number): ComputeBuffer;
    new(count: number, stride: number, type: ComputeBufferType): ComputeBuffer;
    new(count: number, stride: number, type: ComputeBufferType, usage: ComputeBufferMode): ComputeBuffer;


    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;

}
declare const ComputeBuffer: ComputeBufferConstructor;
    
interface GraphicsBufferConstructor {


    new(target: Target, count: number, stride: number): GraphicsBuffer;
    new(target: Target, usageFlags: UsageFlags, count: number, stride: number): GraphicsBuffer;


    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;

}
declare const GraphicsBuffer: GraphicsBufferConstructor;
    
interface BlendShapeBufferRange {
    readonly startIndex: number;
    readonly endIndex: number;





}
    
interface SubMeshDescriptor {
    bounds: Bounds;
    topology: MeshTopology;
    indexStart: number;
    indexCount: number;
    baseVertex: number;
    firstVertex: number;
    vertexCount: number;



    ToString(): string;


}
    
interface SubMeshDescriptorConstructor {


    new(indexStart: number, indexCount: number, topology: MeshTopology): SubMeshDescriptor;



}
declare const SubMeshDescriptor: SubMeshDescriptorConstructor;
    
interface VertexAttributeDescriptor {
    attribute: VertexAttribute;
    format: VertexAttributeFormat;
    dimension: number;
    stream: number;



    Equals(other: unknown): boolean;
    Equals(other: VertexAttributeDescriptor): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface VertexAttributeDescriptorConstructor {


    new(attribute: VertexAttribute, format: VertexAttributeFormat, dimension: number, stream: number): VertexAttributeDescriptor;



}
declare const VertexAttributeDescriptor: VertexAttributeDescriptorConstructor;
    
interface MeshDataArray {
    readonly Length: number;
    readonly Item: MeshData;



    Dispose(): void;


}
    
interface MeshData {
    readonly vertexCount: number;
    readonly vertexBufferCount: number;
    readonly indexFormat: IndexFormat;
    subMeshCount: number;



    GetColors(outColors: CSArray<Color>): void;
    GetColors(outColors: CSArray<Color32>): void;
    GetIndexData<T>(): CSArray<T>;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNormals(outNormals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(outTangents: CSArray<Vector4>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector2>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector3>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector4>): void;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBufferStride(stream: number): number;
    GetVertexData<T>(stream: number): CSArray<T>;
    GetVertices(outVertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;


}
    
interface MeshConstructor {


    new(): Mesh;


    AcquireReadOnlyMeshData(mesh: Mesh): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshCount: number): MeshDataArray;
    AllocateWritableMeshData(mesh: Mesh): MeshDataArray;
    AllocateWritableMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, mesh: Mesh, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;

}
declare const Mesh: MeshConstructor;
    
interface Collider2DConstructor {


    new(): Collider2D;



}
declare const Collider2D: Collider2DConstructor;
    
interface PhysicsScene2DConstructor {




    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(position: Vector2, angle: number, collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapCollider(position: Vector2, angle: number, collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;

}
declare const PhysicsScene2D: PhysicsScene2DConstructor;
    
interface PhysicsJobOptions2D {
    useMultithreading: boolean;
    useConsistencySorting: boolean;
    interpolationPosesPerJob: number;
    newContactsPerJob: number;
    collideContactsPerJob: number;
    clearFlagsPerJob: number;
    clearBodyForcesPerJob: number;
    syncDiscreteFixturesPerJob: number;
    syncContinuousFixturesPerJob: number;
    findNearestContactsPerJob: number;
    updateTriggerContactsPerJob: number;
    islandSolverCostThreshold: number;
    islandSolverBodyCostScale: number;
    islandSolverContactCostScale: number;
    islandSolverJointCostScale: number;
    islandSolverBodiesPerJob: number;
    islandSolverContactsPerJob: number;





}
    
interface Physics2DConstructor {
    IgnoreRaycastLayer: number;
    DefaultRaycastLayers: number;
    AllLayers: number;
    MaxPolygonShapeVertices: number;
    readonly defaultPhysicsScene: PhysicsScene2D;
    velocityIterations: number;
    positionIterations: number;
    gravity: Vector2;
    queriesHitTriggers: boolean;
    queriesStartInColliders: boolean;
    callbacksOnDisable: boolean;
    reuseCollisionCallbacks: boolean;
    autoSyncTransforms: boolean;
    simulationMode: SimulationMode2D;
    simulationLayers: LayerMask;
    useSubStepping: boolean;
    useSubStepContacts: boolean;
    minSubStepFPS: number;
    maxSubStepCount: number;
    jobOptions: PhysicsJobOptions2D;
    bounceThreshold: number;
    maxLinearCorrection: number;
    maxAngularCorrection: number;
    maxTranslationSpeed: number;
    maxRotationSpeed: number;
    defaultContactOffset: number;
    baumgarteScale: number;
    baumgarteTOIScale: number;
    timeToSleep: number;
    linearSleepTolerance: number;
    angularSleepTolerance: number;


    new(): Physics2D;


    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    CircleCast(origin: Vector2, radius: number, direction: Vector2): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    ClosestPoint(position: Vector2, collider: Collider2D): Vector2;
    ClosestPoint(position: Vector2, rigidbody: Rigidbody2D): Vector2;
    Distance(colliderA: Collider2D, colliderB: Collider2D): ColliderDistance2D;
    Distance(colliderA: Collider2D, positionA: Vector2, angleA: number, colliderB: Collider2D, positionB: Vector2, angleB: number): ColliderDistance2D;
    GetContacts(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetIgnoreCollision(collider1: Collider2D, collider2: Collider2D): boolean;
    GetIgnoreLayerCollision(layer1: number, layer2: number): boolean;
    GetLayerCollisionMask(layer: number): number;
    GetRayIntersection(ray: Ray): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, layerMask: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    GetRayIntersectionAll(ray: Ray): CSArray<RaycastHit2D>;
    GetRayIntersectionAll(ray: Ray, distance: number): CSArray<RaycastHit2D>;
    GetRayIntersectionAll(ray: Ray, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    IgnoreCollision(collider1: Collider2D, collider2: Collider2D): void;
    IgnoreCollision(collider1: Collider2D, collider2: Collider2D, ignore: boolean): void;
    IgnoreLayerCollision(layer1: number, layer2: number): void;
    IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void;
    IsTouching(collider1: Collider2D, collider2: Collider2D): boolean;
    IsTouching(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(collider: Collider2D): boolean;
    IsTouchingLayers(collider: Collider2D, layerMask: number): boolean;
    Linecast(start: Vector2, end: Vector2): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number, minDepth: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    LinecastAll(start: Vector2, end: Vector2): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    OverlapArea(pointA: Vector2, pointB: Vector2): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapBox(point: Vector2, size: Vector2, angle: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCircle(point: Vector2, radius: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number, minDepth: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircleAll(point: Vector2, radius: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number, minDepth: number): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPointAll(point: Vector2): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    Raycast(origin: Vector2, direction: Vector2): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    RaycastAll(origin: Vector2, direction: Vector2): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    SetLayerCollisionMask(layer: number, layerMask: number): void;
    Simulate(deltaTime: number): boolean;
    Simulate(deltaTime: number, simulationLayers: number): boolean;
    SyncTransforms(): void;

}
declare const Physics2D: Physics2DConstructor;
    
interface MonoBehaviour extends Behaviour {
    readonly destroyCancellationToken: unknown;
    useGUILayout: boolean;
    readonly didStart: boolean;
    readonly didAwake: boolean;
    runInEditMode: boolean;



    CancelInvoke(): void;
    CancelInvoke(methodName: string): void;
    Invoke(methodName: string, time: number): void;
    InvokeRepeating(methodName: string, time: number, repeatRate: number): void;
    IsInvoking(): boolean;
    IsInvoking(methodName: string): boolean;
    StartCoroutine(methodName: string): Coroutine;
    StartCoroutine(methodName: string, value: unknown): Coroutine;
    StartCoroutine(routine: unknown): Coroutine;
    StopAllCoroutines(): void;
    StopCoroutine(routine: unknown): void;
    StopCoroutine(routine: Coroutine): void;
    StopCoroutine(methodName: string): void;


}
    
interface YieldInstruction {





}
    
interface YieldInstructionConstructor {


    new(): YieldInstruction;



}
declare const YieldInstruction: YieldInstructionConstructor;
    
interface Coroutine extends YieldInstruction {





}
    
interface MonoBehaviourConstructor {


    new(): MonoBehaviour;


    print(message: unknown): void;

}
declare const MonoBehaviour: MonoBehaviourConstructor;
    
interface Debug {





}
    
interface StartupLog {
    timestamp: number;
    logType: LogType;
    message: string;





}
    
interface DebugConstructor {
    readonly unityLogger: unknown;
    developerConsoleEnabled: boolean;
    developerConsoleVisible: boolean;
    readonly isDebugBuild: boolean;


    new(): Debug;


    Assert(condition: boolean): void;
    Assert(condition: boolean, context: Object): void;
    Assert(condition: boolean, message: unknown): void;
    Assert(condition: boolean, message: string): void;
    Assert(condition: boolean, message: unknown, context: Object): void;
    Assert(condition: boolean, message: string, context: Object): void;
    AssertFormat(condition: boolean, format: string, args: CSArray<unknown>): void;
    AssertFormat(condition: boolean, context: Object, format: string, args: CSArray<unknown>): void;
    Break(): void;
    ClearDeveloperConsole(): void;
    DebugBreak(): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number): void;
    DrawLine(start: Vector3, end: Vector3, color: Color): void;
    DrawLine(start: Vector3, end: Vector3): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number, depthTest: boolean): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color): void;
    DrawRay(start: Vector3, dir: Vector3): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number, depthTest: boolean): void;
    ExtractStackTraceNoAlloc(buffer: unknown, bufferMax: number, projectFolder: string): number;
    Log(message: unknown): void;
    Log(message: unknown, context: Object): void;
    LogAssertion(message: unknown): void;
    LogAssertion(message: unknown, context: Object): void;
    LogAssertionFormat(format: string, args: CSArray<unknown>): void;
    LogAssertionFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogError(message: unknown): void;
    LogError(message: unknown, context: Object): void;
    LogErrorFormat(format: string, args: CSArray<unknown>): void;
    LogErrorFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogException(exception: unknown): void;
    LogException(exception: unknown, context: Object): void;
    LogFormat(format: string, args: CSArray<unknown>): void;
    LogFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogFormat(logType: LogType, logOptions: LogOption, context: Object, format: string, args: CSArray<unknown>): void;
    LogWarning(message: unknown): void;
    LogWarning(message: unknown, context: Object): void;
    LogWarningFormat(format: string, args: CSArray<unknown>): void;
    LogWarningFormat(context: Object, format: string, args: CSArray<unknown>): void;
    RetrieveStartupLogs(): CSArray<StartupLog>;

}
declare const Debug: DebugConstructor;
    
interface Sprite extends Object {
    readonly bounds: Bounds;
    readonly rect: Rect;
    readonly border: Vector4;
    readonly texture: Texture2D;
    readonly pixelsPerUnit: number;
    readonly spriteAtlasTextureScale: number;
    readonly associatedAlphaSplitTexture: Texture2D;
    readonly pivot: Vector2;
    readonly packed: boolean;
    readonly packingMode: SpritePackingMode;
    readonly packingRotation: SpritePackingRotation;
    readonly textureRect: Rect;
    readonly textureRectOffset: Vector2;
    readonly vertices: CSArray<Vector2>;
    readonly triangles: CSArray<number>;
    readonly uv: CSArray<Vector2>;



    AddScriptableObject(obj: ScriptableObject): boolean;
    GetPhysicsShape(shapeIdx: number, physicsShape: CSArray<Vector2>): number;
    GetPhysicsShapeCount(): number;
    GetPhysicsShapePointCount(shapeIdx: number): number;
    GetScriptableObjects(scriptableObjects: CSArray<ScriptableObject>): number;
    GetScriptableObjectsCount(): number;
    GetSecondaryTextureCount(): number;
    GetSecondaryTextures(secondaryTexture: CSArray<SecondarySpriteTexture>): number;
    OverrideGeometry(vertices: CSArray<Vector2>, triangles: CSArray<number>): void;
    OverridePhysicsShape(physicsShapes: CSArray<CSArray<Vector2>>): void;
    RemoveScriptableObjectAt(i: number): boolean;
    SetScriptableObjectAt(obj: ScriptableObject, i: number): boolean;


}
    
interface Rect {
    x: number;
    y: number;
    position: Vector2;
    center: Vector2;
    min: Vector2;
    max: Vector2;
    width: number;
    height: number;
    size: Vector2;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;



    Contains(point: Vector2): boolean;
    Contains(point: Vector3): boolean;
    Contains(point: Vector3, allowInverse: boolean): boolean;
    Equals(other: unknown): boolean;
    Equals(other: Rect): boolean;
    GetHashCode(): number;
    Overlaps(other: Rect): boolean;
    Overlaps(other: Rect, allowInverse: boolean): boolean;
    Set(x: number, y: number, width: number, height: number): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;


}
    
interface RectConstructor {
    readonly zero: Rect;


    new(x: number, y: number, width: number, height: number): Rect;
    new(position: Vector2, size: Vector2): Rect;
    new(source: Rect): Rect;


    MinMaxRect(xmin: number, ymin: number, xmax: number, ymax: number): Rect;
    NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2): Vector2;
    PointToNormalized(rectangle: Rect, point: Vector2): Vector2;

}
declare const Rect: RectConstructor;
    
interface Texture extends Object {
    readonly mipmapCount: number;
    readonly graphicsFormat: GraphicsFormat;
    width: number;
    height: number;
    dimension: TextureDimension;
    readonly isReadable: boolean;
    wrapMode: TextureWrapMode;
    wrapModeU: TextureWrapMode;
    wrapModeV: TextureWrapMode;
    wrapModeW: TextureWrapMode;
    filterMode: FilterMode;
    anisoLevel: number;
    mipMapBias: number;
    readonly texelSize: Vector2;
    readonly updateCount: number;
    readonly isDataSRGB: boolean;
    imageContentsHash: Hash128;
    readonly graphicsTexture: GraphicsTexture;



    GetNativeTexturePtr(): unknown;
    IncrementUpdateCount(): void;


}
    
interface Hash128 {
    readonly isValid: boolean;



    Append(data: string): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(val: unknown): void;
    Append(val: number): void;
    Append(val: number): void;
    Append(data: unknown, size: number): void;
    CompareTo(rhs: Hash128): number;
    CompareTo(obj: unknown): number;
    Equals(obj: unknown): boolean;
    Equals(obj: Hash128): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface Hash128Constructor {


    new(u32_0: number, u32_1: number, u32_2: number, u32_3: number): Hash128;
    new(u64_0: number, u64_1: number): Hash128;


    Compute(data: string): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(val: unknown): Hash128;
    Compute(val: number): Hash128;
    Compute(val: number): Hash128;
    Compute(data: unknown, size: number): Hash128;
    Parse(hashString: string): Hash128;

}
declare const Hash128: Hash128Constructor;
    
interface GraphicsTexture {
    readonly descriptor: GraphicsTextureDescriptor;
    readonly state: GraphicsTextureState;



    Dispose(): void;


}
    
interface GraphicsTextureDescriptor {
    width: number;
    height: number;
    depth: number;
    arrayLength: number;
    format: GraphicsFormat;
    dimension: TextureDimension;
    mipCount: number;
    numSamples: number;
    flags: GraphicsTextureDescriptorFlags;





}
    
interface GraphicsTextureConstructor {
    active: GraphicsTexture;


    new(desc: GraphicsTextureDescriptor): GraphicsTexture;



}
declare const GraphicsTexture: GraphicsTextureConstructor;
    
interface TextureConstructor {
    readonly GenerateAllMips: number;
    anisotropicFiltering: AnisotropicFiltering;
    readonly totalTextureMemory: number;
    readonly desiredTextureMemory: number;
    readonly targetTextureMemory: number;
    readonly currentTextureMemory: number;
    readonly nonStreamingTextureMemory: number;
    readonly streamingMipmapUploadCount: number;
    readonly streamingRendererCount: number;
    readonly streamingTextureCount: number;
    readonly nonStreamingTextureCount: number;
    readonly streamingTexturePendingLoadCount: number;
    readonly streamingTextureLoadingCount: number;
    streamingTextureForceLoadAll: boolean;
    streamingTextureDiscardUnusedMips: boolean;
    allowThreadedTextureCreation: boolean;




    SetGlobalAnisotropicFilteringLimits(forcedMin: number, globalMax: number): void;
    SetStreamingTextureMaterialDebugProperties(): void;

}
declare const Texture: TextureConstructor;
    
interface Texture2D extends Texture {
    readonly format: TextureFormat;
    readonly mipmapLimitGroup: string;
    readonly activeMipmapLimit: number;
    readonly isReadable: boolean;
    readonly vtOnly: boolean;
    readonly streamingMipmaps: boolean;
    readonly streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    minimumMipmapLevel: number;
    readonly calculatedMipmapLevel: number;
    readonly desiredMipmapLevel: number;
    readonly loadingMipmapLevel: number;
    readonly loadedMipmapLevel: number;
    alphaIsTransparency: boolean;
    ignoreMipmapLimit: boolean;



    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    ClearMinimumMipmapLevel(): void;
    ClearRequestedMipmapLevel(): void;
    Compress(highQuality: boolean): void;
    GetPixel(x: number, y: number): Color;
    GetPixel(x: number, y: number, mipLevel: number): Color;
    GetPixelBilinear(u: number, v: number): Color;
    GetPixelBilinear(u: number, v: number, mipLevel: number): Color;
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number, miplevel: number): CSArray<Color>;
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number): CSArray<Color>;
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    GetRawTextureData(): CSArray<number>;
    GetRawTextureData<T>(): CSArray<T>;
    IsRequestedMipmapLevelLoaded(): boolean;
    LoadRawTextureData(data: unknown, size: number): void;
    LoadRawTextureData(data: CSArray<number>): void;
    LoadRawTextureData<T>(data: CSArray<T>): void;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number, makeNoLongerReadable: boolean): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number): CSArray<Rect>;
    ReadPixels(source: Rect, destX: number, destY: number, recalculateMipMaps: boolean): void;
    ReadPixels(source: Rect, destX: number, destY: number): void;
    Reinitialize(width: number, height: number): boolean;
    Reinitialize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    Reinitialize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    SetPixel(x: number, y: number, color: Color): void;
    SetPixel(x: number, y: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>, miplevel: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>): void;
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(colors: CSArray<Color32>): void;
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>): void;
    UpdateExternalTexture(nativeTex: unknown): void;


}
    
interface Texture2DConstructor {
    readonly whiteTexture: Texture2D;
    readonly blackTexture: Texture2D;
    readonly redTexture: Texture2D;
    readonly grayTexture: Texture2D;
    readonly linearGrayTexture: Texture2D;
    readonly normalTexture: Texture2D;


    new(width: number, height: number, format: DefaultFormat, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, mipmapLimitGroupName: string, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, flags: TextureCreationFlags, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, mipmapLimitGroupName: string, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean, ignoreMipmapLimit: boolean, mipmapLimitGroupName: string): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean, createUninitialized: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean): Texture2D;
    new(width: number, height: number): Texture2D;


    CreateExternalTexture(width: number, height: number, format: TextureFormat, mipChain: boolean, linear: boolean, nativeTex: unknown): Texture2D;
    GenerateAtlas(sizes: CSArray<Vector2>, padding: number, atlasSize: number, results: CSArray<Rect>): boolean;

}
declare const Texture2D: Texture2DConstructor;
    
interface ScriptableObject extends Object {





}
    
interface ScriptableObjectConstructor {


    new(): ScriptableObject;


    CreateInstance(className: string): ScriptableObject;
    CreateInstance(type: unknown): ScriptableObject;
    CreateInstance<T>(): T;

}
declare const ScriptableObject: ScriptableObjectConstructor;
    
interface SecondarySpriteTexture {
    name: string;
    texture: Texture2D;





}
    
interface SpriteConstructor {




    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean, secondaryTextures: CSArray<SecondarySpriteTexture>): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2): Sprite;

}
declare const Sprite: SpriteConstructor;
    
interface TextAsset extends Object {
    readonly bytes: CSArray<number>;
    readonly text: string;
    readonly dataSize: number;



    GetData<T>(): CSArray<T>;
    ToString(): string;


}
    
interface TextAssetConstructor {


    new(): TextAsset;
    new(text: string): TextAsset;



}
declare const TextAsset: TextAssetConstructor;
    
interface Resources {





}
    
interface AsyncOperation extends YieldInstruction {
    readonly isDone: boolean;
    readonly progress: number;
    priority: number;
    allowSceneActivation: boolean;

    readonly completed: MonoSignal<AsyncOperation>;




}
    
interface AsyncOperationConstructor {


    new(): AsyncOperation;



}
declare const AsyncOperation: AsyncOperationConstructor;
    
interface ResourceRequest extends AsyncOperation {
    readonly asset: Object;





}
    
interface ResourceRequestConstructor {


    new(): ResourceRequest;



}
declare const ResourceRequest: ResourceRequestConstructor;
    
interface ResourcesConstructor {


    new(): Resources;


    FindObjectsOfTypeAll(type: unknown): CSArray<Object>;
    FindObjectsOfTypeAll<T>(): CSArray<T>;
    GetBuiltinResource(type: unknown, path: string): Object;
    GetBuiltinResource<T>(path: string): T;
    InstanceIDIsValid(instanceId: number): boolean;
    InstanceIDsToValidArray(instanceIDs: CSArray<number>, validArray: CSArray<boolean>): void;
    InstanceIDsToValidArray(instanceIDs: unknown, validArray: unknown): void;
    InstanceIDToObject(instanceID: number): Object;
    InstanceIDToObjectList(instanceIDs: CSArray<number>, objects: CSArray<Object>): void;
    Load(path: string): Object;
    Load<T>(path: string): T;
    Load(path: string, systemTypeInstance: unknown): Object;
    LoadAll(path: string, systemTypeInstance: unknown): CSArray<Object>;
    LoadAll(path: string): CSArray<Object>;
    LoadAll<T>(path: string): CSArray<T>;
    LoadAsync(path: string): ResourceRequest;
    LoadAsync<T>(path: string): ResourceRequest;
    LoadAsync(path: string, type: unknown): ResourceRequest;
    UnloadAsset(assetToUnload: Object): void;
    UnloadUnusedAssets(): AsyncOperation;

}
declare const Resources: ResourcesConstructor;
    
interface AgonesCore {





}
    
interface AgonesProxy extends MonoBehaviour {

    readonly connected: MonoSignal<void>;
    readonly ready: MonoSignal<void>;
    readonly test: MonoSignal<void>;


    AppendListValue(list: string, value: string): boolean;
    Connect(): void;
    DeleteListValue(list: string, value: string): boolean;
    GetListValues(list: string): CSArray<string>;
    ListContains(list: string, value: string): boolean;
    Ready(): void;
    SetAnnotation(key: string, value: string): boolean;
    SetLabel(key: string, value: string): boolean;
    Shutdown(): void;


}
    
interface AgonesProxyConstructor {


    new(): AgonesProxy;



}
declare const AgonesProxy: AgonesProxyConstructor;
    
interface AgonesCoreConstructor {
    Agones: AgonesProxy;


    new(): AgonesCore;


    SetAgonesProxy(agones: AgonesProxy): void;

}
declare const AgonesCore: AgonesCoreConstructor;
    
interface RunCore {





}
    
interface RunCoreConstructor {
    launchInDedicatedServerMode: boolean;


    new(): RunCore;


    IsClient(): boolean;
    IsClone(): boolean;
    IsEditor(): boolean;
    IsInternal(): boolean;
    IsServer(): boolean;
    OnLoad(): void;

}
declare const RunCore: RunCoreConstructor;
    
interface NetworkCore {





}
    
interface Net extends MonoBehaviour {

    readonly broadcastFromServerAction: MonoSignal<void>;
    readonly broadcastFromClientAction: MonoSignal<void>;


    BroadcastToAllClients(blob: BinaryBlob, reliable: number): void;
    BroadcastToAllExceptClient(ignoredClientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClient(clientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClients(clientIds: CSArray<number>, blob: BinaryBlob, reliable: number): void;
    BroadcastToServer(blob: BinaryBlob, reliable: number): void;
    OnStartClient(): void;
    OnStartServer(): void;


}
    
interface BinaryBlob {
    m_dataSize: number;
    m_data: CSArray<number>;



    GetDictionary(): CSDictionary<unknown, unknown>;


}
    
interface BinaryBlobConstructor {


    new(): BinaryBlob;
    new(bytes: CSArray<number>): BinaryBlob;



}
declare const BinaryBlob: BinaryBlobConstructor;
    
interface NetConstructor {


    new(): Net;



}
declare const Net: NetConstructor;
    
interface NetworkCoreConstructor {
    Net: Net;


    new(): NetworkCore;


    SetNet(net: Net): void;

}
declare const NetworkCore: NetworkCoreConstructor;
    
interface Camera extends Behaviour {
    nearClipPlane: number;
    farClipPlane: number;
    fieldOfView: number;
    renderingPath: RenderingPath;
    readonly actualRenderingPath: RenderingPath;
    allowHDR: boolean;
    allowMSAA: boolean;
    allowDynamicResolution: boolean;
    forceIntoRenderTexture: boolean;
    orthographicSize: number;
    orthographic: boolean;
    opaqueSortMode: OpaqueSortMode;
    transparencySortMode: TransparencySortMode;
    transparencySortAxis: Vector3;
    depth: number;
    aspect: number;
    readonly velocity: Vector3;
    cullingMask: number;
    eventMask: number;
    layerCullSpherical: boolean;
    cameraType: CameraType;
    overrideSceneCullingMask: number;
    layerCullDistances: CSArray<number>;
    useOcclusionCulling: boolean;
    cullingMatrix: Matrix4x4;
    backgroundColor: Color;
    clearFlags: CameraClearFlags;
    depthTextureMode: DepthTextureMode;
    clearStencilAfterLightingPass: boolean;
    usePhysicalProperties: boolean;
    iso: number;
    shutterSpeed: number;
    aperture: number;
    focusDistance: number;
    focalLength: number;
    bladeCount: number;
    curvature: Vector2;
    barrelClipping: number;
    anamorphism: number;
    sensorSize: Vector2;
    lensShift: Vector2;
    gateFit: GateFitMode;
    rect: Rect;
    pixelRect: Rect;
    readonly pixelWidth: number;
    readonly pixelHeight: number;
    readonly scaledPixelWidth: number;
    readonly scaledPixelHeight: number;
    targetTexture: RenderTexture;
    readonly activeTexture: RenderTexture;
    targetDisplay: number;
    readonly cameraToWorldMatrix: Matrix4x4;
    worldToCameraMatrix: Matrix4x4;
    projectionMatrix: Matrix4x4;
    nonJitteredProjectionMatrix: Matrix4x4;
    useJitteredProjectionMatrixForTransparentRendering: boolean;
    readonly previousViewProjectionMatrix: Matrix4x4;
    scene: Scene;
    readonly stereoEnabled: boolean;
    stereoSeparation: number;
    stereoConvergence: number;
    readonly areVRStereoViewMatricesWithinSingleCullTolerance: boolean;
    stereoTargetEye: StereoTargetEyeMask;
    readonly stereoActiveEye: MonoOrStereoscopicEye;
    readonly sceneViewFilterMode: SceneViewFilterMode;
    renderCloudsInSceneView: boolean;
    readonly commandBufferCount: number;



    AddCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    AddCommandBufferAsync(evt: CameraEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    CalculateFrustumCorners(viewport: Rect, z: number, eye: MonoOrStereoscopicEye, outCorners: CSArray<Vector3>): void;
    CalculateObliqueMatrix(clipPlane: Vector4): Matrix4x4;
    CopyFrom(other: Camera): void;
    CopyStereoDeviceProjectionMatrixToNonJittered(eye: StereoscopicEye): void;
    GetCommandBuffers(evt: CameraEvent): CSArray<CommandBuffer>;
    GetGateFittedFieldOfView(): number;
    GetGateFittedLensShift(): Vector2;
    GetStereoNonJitteredProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoViewMatrix(eye: StereoscopicEye): Matrix4x4;
    RemoveAllCommandBuffers(): void;
    RemoveCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    RemoveCommandBuffers(evt: CameraEvent): void;
    Render(): void;
    RenderDontRestore(): void;
    RenderToCubemap(cubemap: Cubemap, faceMask: number): boolean;
    RenderToCubemap(cubemap: Cubemap): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number): boolean;
    RenderToCubemap(cubemap: RenderTexture): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number, stereoEye: MonoOrStereoscopicEye): boolean;
    RenderWithShader(shader: Shader, replacementTag: string): void;
    Reset(): void;
    ResetAspect(): void;
    ResetCullingMatrix(): void;
    ResetProjectionMatrix(): void;
    ResetReplacementShader(): void;
    ResetStereoProjectionMatrices(): void;
    ResetStereoViewMatrices(): void;
    ResetTransparencySortSettings(): void;
    ResetWorldToCameraMatrix(): void;
    ScreenPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    ScreenPointToRay(pos: Vector3): Ray;
    ScreenToViewportPoint(position: Vector3): Vector3;
    ScreenToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    ScreenToWorldPoint(position: Vector3): Vector3;
    SetReplacementShader(shader: Shader, replacementTag: string): void;
    SetStereoProjectionMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    SetStereoViewMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    SetTargetBuffers(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer): void;
    SetTargetBuffers(colorBuffer: CSArray<RenderBuffer>, depthBuffer: RenderBuffer): void;
    SubmitRenderRequest<RequestData>(renderRequest: RequestData): void;
    TryGetCullingParameters(cullingParameters: unknown): boolean;
    TryGetCullingParameters(stereoAware: boolean, cullingParameters: unknown): boolean;
    ViewportPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    ViewportPointToRay(pos: Vector3): Ray;
    ViewportToScreenPoint(position: Vector3): Vector3;
    ViewportToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    ViewportToWorldPoint(position: Vector3): Vector3;
    WorldToScreenPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    WorldToScreenPoint(position: Vector3): Vector3;
    WorldToViewportPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    WorldToViewportPoint(position: Vector3): Vector3;


}
    
interface RenderTexture extends Texture {
    width: number;
    height: number;
    dimension: TextureDimension;
    graphicsFormat: GraphicsFormat;
    useMipMap: boolean;
    readonly sRGB: boolean;
    vrUsage: VRTextureUsage;
    memorylessMode: RenderTextureMemoryless;
    format: RenderTextureFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    autoGenerateMips: boolean;
    volumeDepth: number;
    antiAliasing: number;
    bindTextureMS: boolean;
    enableRandomWrite: boolean;
    useDynamicScale: boolean;
    useDynamicScaleExplicit: boolean;
    isPowerOfTwo: boolean;
    readonly colorBuffer: RenderBuffer;
    readonly depthBuffer: RenderBuffer;
    depth: number;
    descriptor: RenderTextureDescriptor;



    ApplyDynamicScale(): void;
    ConvertToEquirect(equirect: RenderTexture, eye: MonoOrStereoscopicEye): void;
    Create(): boolean;
    DiscardContents(discardColor: boolean, discardDepth: boolean): void;
    DiscardContents(): void;
    GenerateMips(): void;
    GetNativeDepthBufferPtr(): unknown;
    IsCreated(): boolean;
    Release(): void;
    ResolveAntiAliasedSurface(): void;
    ResolveAntiAliasedSurface(target: RenderTexture): void;
    SetGlobalShaderProperty(propertyName: string): void;


}
    
interface RenderBuffer {



    GetNativeRenderBufferPtr(): unknown;


}
    
interface RenderTextureDescriptor {
    width: number;
    height: number;
    msaaSamples: number;
    volumeDepth: number;
    mipCount: number;
    graphicsFormat: GraphicsFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    colorFormat: RenderTextureFormat;
    sRGB: boolean;
    depthBufferBits: number;
    dimension: TextureDimension;
    shadowSamplingMode: ShadowSamplingMode;
    vrUsage: VRTextureUsage;
    readonly flags: RenderTextureCreationFlags;
    memoryless: RenderTextureMemoryless;
    useMipMap: boolean;
    autoGenerateMips: boolean;
    enableRandomWrite: boolean;
    bindMS: boolean;
    useDynamicScale: boolean;
    useDynamicScaleExplicit: boolean;





}
    
interface RenderTextureDescriptorConstructor {


    new(width: number, height: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number, readWrite: RenderTextureReadWrite): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTextureDescriptor;



}
declare const RenderTextureDescriptor: RenderTextureDescriptorConstructor;
    
interface RenderTextureConstructor {
    active: RenderTexture;


    new(desc: RenderTextureDescriptor): RenderTexture;
    new(textureToCopy: RenderTexture): RenderTexture;
    new(width: number, height: number, depth: number, format: DefaultFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: GraphicsFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: GraphicsFormat, mipCount: number): RenderTexture;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTexture;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat): RenderTexture;
    new(width: number, height: number, depth: number): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat, mipCount: number): RenderTexture;


    GetTemporary(desc: RenderTextureDescriptor): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number): RenderTexture;
    GetTemporary(width: number, height: number): RenderTexture;
    ReleaseTemporary(temp: RenderTexture): void;
    SupportsStencil(rt: RenderTexture): boolean;

}
declare const RenderTexture: RenderTextureConstructor;
    
interface CommandBuffer {
    name: string;
    readonly sizeInBytes: number;



    BeginRenderPass(width: number, height: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>): void;
    BeginRenderPass(width: number, height: number, volumeDepth: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>): void;
    BeginRenderPass(width: number, height: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>, debugNameUtf8: unknown): void;
    BeginRenderPass(width: number, height: number, volumeDepth: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>, debugNameUtf8: unknown): void;
    BeginSample(name: string): void;
    BeginSample(sampler: CustomSampler): void;
    BeginSample(marker: ProfilerMarker): void;
    Blit(source: Texture, dest: RenderTargetIdentifier): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number, destDepthSlice: number): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, relativeOrigin: Vector3): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, buildSettings: BuildSettings): void;
    Clear(): void;
    ClearRandomWriteTargets(): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number, stencil: number): void;
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColor: Color, depth: number, stencil: number): void;
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColors: CSArray<Color>, depth: number, stencil: number): void;
    ConfigureFoveatedRendering(platformData: unknown): void;
    ConvertTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    ConvertTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer): void;
    CopyCounterValue(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number, dstX: number, dstY: number): void;
    CreateAsyncGraphicsFence(): GraphicsFence;
    CreateAsyncGraphicsFence(stage: SynchronisationStage): GraphicsFence;
    CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags): GraphicsFence;
    DisableKeyword(keyword: unknown): void;
    DisableKeyword(material: Material, keyword: unknown): void;
    DisableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    DisableScissorRect(): void;
    DisableShaderKeyword(keyword: string): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchRays(rayTracingShader: RayTracingShader, rayGenName: string, width: number, height: number, depth: number, camera: Camera): void;
    Dispose(): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer): void;
    DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, count: number, properties: MaterialPropertyBlock): void;
    DrawMultipleMeshes(matrices: CSArray<Matrix4x4>, meshes: CSArray<Mesh>, subsetIndices: CSArray<number>, count: number, material: Material, shaderPass: number, properties: MaterialPropertyBlock): void;
    DrawOcclusionMesh(normalizedCamViewport: RectInt): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number, shaderPass: number): void;
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number): void;
    DrawRenderer(renderer: Renderer, material: Material): void;
    DrawRendererList(rendererList: RendererList): void;
    EnableKeyword(keyword: unknown): void;
    EnableKeyword(material: Material, keyword: unknown): void;
    EnableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    EnableScissorRect(scissor: Rect): void;
    EnableShaderKeyword(keyword: string): void;
    EndRenderPass(): void;
    EndSample(name: string): void;
    EndSample(sampler: CustomSampler): void;
    EndSample(marker: ProfilerMarker): void;
    GenerateMips(rt: RenderTargetIdentifier): void;
    GenerateMips(rt: RenderTexture): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, useDynamicScale: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number): void;
    IncrementUpdateCount(dest: RenderTargetIdentifier): void;
    InvokeOnRenderObjectCallbacks(): void;
    IssuePluginCustomBlit(callback: unknown, command: number, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, commandParam: number, commandFlags: number): void;
    IssuePluginCustomTextureUpdateV2(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginEvent(callback: unknown, eventID: number): void;
    IssuePluginEventAndData(callback: unknown, eventID: number, data: unknown): void;
    IssuePluginEventAndDataWithFlags(callback: unknown, eventID: number, flags: CustomMarkerCallbackFlags, data: unknown): void;
    MarkLateLatchMatrixShaderPropertyID(matrixPropertyType: CameraLateLatchMatrixType, shaderPropertyID: number): void;
    NextSubPass(): void;
    ProcessVTFeedback(rt: RenderTargetIdentifier, resolver: unknown, slice: number, x: number, width: number, y: number, height: number, mip: number): void;
    Release(): void;
    ReleaseTemporaryRT(nameID: number): void;
    RequestAsyncReadback(src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadback(src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    ResolveAntiAliasedSurface(rt: RenderTexture, target: RenderTexture): void;
    SetBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    SetBufferCounterValue(buffer: GraphicsBuffer, counterValue: number): void;
    SetBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData(buffer: GraphicsBuffer, data: unknown): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData(buffer: GraphicsBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, bufferHandle: GraphicsBufferHandle): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, bufferHandle: GraphicsBufferHandle): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetComputeFloatParam(computeShader: ComputeShader, nameID: number, val: number): void;
    SetComputeFloatParam(computeShader: ComputeShader, name: string, val: number): void;
    SetComputeFloatParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    SetComputeFloatParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    SetComputeIntParam(computeShader: ComputeShader, nameID: number, val: number): void;
    SetComputeIntParam(computeShader: ComputeShader, name: string, val: number): void;
    SetComputeIntParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    SetComputeIntParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    SetComputeMatrixArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Matrix4x4>): void;
    SetComputeMatrixArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Matrix4x4>): void;
    SetComputeMatrixParam(computeShader: ComputeShader, nameID: number, val: Matrix4x4): void;
    SetComputeMatrixParam(computeShader: ComputeShader, name: string, val: Matrix4x4): void;
    SetComputeParamsFromMaterial(computeShader: ComputeShader, kernelIndex: number, material: Material): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    SetComputeVectorArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Vector4>): void;
    SetComputeVectorArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Vector4>): void;
    SetComputeVectorParam(computeShader: ComputeShader, nameID: number, val: Vector4): void;
    SetComputeVectorParam(computeShader: ComputeShader, name: string, val: Vector4): void;
    SetExecutionFlags(flags: CommandBufferExecutionFlags): void;
    SetFoveatedRenderingMode(foveatedRenderingMode: FoveatedRenderingMode): void;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalConstantBuffer(buffer: ComputeBuffer, nameID: number, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: ComputeBuffer, name: string, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, nameID: number, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, name: string, offset: number, size: number): void;
    SetGlobalDepthBias(bias: number, slopeBias: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalRayTracingAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetGlobalRayTracingAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetGlobalTexture(name: string, value: RenderTargetIdentifier): void;
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier): void;
    SetGlobalTexture(name: string, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetInstanceMultiplier(multiplier: number): void;
    SetInvertCulling(invertCulling: boolean): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetKeyword(material: Material, keyword: unknown, value: boolean): void;
    SetKeyword(computeShader: ComputeShader, keyword: unknown, value: boolean): void;
    SetLateLatchProjectionMatrices(projectionMat: CSArray<Matrix4x4>): void;
    SetProjectionMatrix(proj: Matrix4x4): void;
    SetRandomWriteTarget(index: number, rt: RenderTargetIdentifier): void;
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer): void;
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer): void;
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(computeShader: ComputeShader, kernelIndex: number, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(computeShader: ComputeShader, kernelIndex: number, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, bufferHandle: GraphicsBufferHandle): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, bufferHandle: GraphicsBufferHandle): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Matrix4x4>): void;
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Matrix4x4>): void;
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, name: string, val: Matrix4x4): void;
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, nameID: number, val: Matrix4x4): void;
    SetRayTracingShaderPass(rayTracingShader: RayTracingShader, passName: string): void;
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, name: string, rt: RenderTargetIdentifier): void;
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, nameID: number, rt: RenderTargetIdentifier): void;
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Vector4>): void;
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Vector4>): void;
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, name: string, val: Vector4): void;
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, nameID: number, val: Vector4): void;
    SetRenderTarget(rt: RenderTargetIdentifier): void;
    SetRenderTarget(rt: RenderTargetIdentifier, loadAction: RenderBufferLoadAction, storeAction: RenderBufferStoreAction): void;
    SetRenderTarget(rt: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depth: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier): void;
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(binding: RenderTargetBinding, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(binding: RenderTargetBinding): void;
    SetShadowSamplingMode(shadowmap: RenderTargetIdentifier, mode: ShadowSamplingMode): void;
    SetSinglePassStereo(mode: SinglePassStereoMode): void;
    SetupCameraProperties(camera: Camera): void;
    SetViewMatrix(view: Matrix4x4): void;
    SetViewport(pixelRect: Rect): void;
    SetViewProjectionMatrices(view: Matrix4x4, proj: Matrix4x4): void;
    SetWireframe(enable: boolean): void;
    UnmarkLateLatchMatrix(matrixPropertyType: CameraLateLatchMatrixType): void;
    WaitAllAsyncReadbackRequests(): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStage): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStageFlags): void;


}
    
interface AttachmentDescriptor {
    loadAction: RenderBufferLoadAction;
    storeAction: RenderBufferStoreAction;
    graphicsFormat: GraphicsFormat;
    format: RenderTextureFormat;
    loadStoreTarget: RenderTargetIdentifier;
    resolveTarget: RenderTargetIdentifier;
    clearColor: Color;
    clearDepth: number;
    clearStencil: number;



    ConfigureClear(clearColor: Color, clearDepth: number, clearStencil: number): void;
    ConfigureResolveTarget(target: RenderTargetIdentifier): void;
    ConfigureTarget(target: RenderTargetIdentifier, loadExistingContents: boolean, storeResults: boolean): void;
    Equals(other: AttachmentDescriptor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;


}
    
interface RenderTargetIdentifier {



    Equals(rhs: RenderTargetIdentifier): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface RenderTargetIdentifierConstructor {
    AllDepthSlices: number;


    new(type: BuiltinRenderTextureType): RenderTargetIdentifier;
    new(type: BuiltinRenderTextureType, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(name: string): RenderTargetIdentifier;
    new(name: string, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(nameID: number): RenderTargetIdentifier;
    new(nameID: number, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(renderTargetIdentifier: RenderTargetIdentifier, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(tex: Texture): RenderTargetIdentifier;
    new(tex: Texture, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(buf: RenderBuffer, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;



}
declare const RenderTargetIdentifier: RenderTargetIdentifierConstructor;
    
interface AttachmentDescriptorConstructor {


    new(format: GraphicsFormat): AttachmentDescriptor;
    new(format: RenderTextureFormat): AttachmentDescriptor;
    new(format: RenderTextureFormat, target: RenderTargetIdentifier, loadExistingContents: boolean, storeResults: boolean, resolve: boolean): AttachmentDescriptor;



}
declare const AttachmentDescriptor: AttachmentDescriptorConstructor;
    
interface SubPassDescriptor {
    inputs: AttachmentIndexArray;
    colorOutputs: AttachmentIndexArray;
    flags: SubPassFlags;





}
    
interface AttachmentIndexArray {
    Item: number;
    readonly Length: number;





}
    
interface AttachmentIndexArrayConstructor {
    Emtpy: AttachmentIndexArray;
    MaxAttachments: number;


    new(numAttachments: number): AttachmentIndexArray;
    new(attachments: CSArray<number>): AttachmentIndexArray;
    new(attachments: CSArray<number>): AttachmentIndexArray;



}
declare const AttachmentIndexArray: AttachmentIndexArrayConstructor;
    
interface Sampler {
    readonly isValid: boolean;
    readonly name: string;



    GetRecorder(): Recorder;


}
    
interface Recorder {
    readonly isValid: boolean;
    enabled: boolean;
    readonly elapsedNanoseconds: number;
    readonly gpuElapsedNanoseconds: number;
    readonly sampleBlockCount: number;
    readonly gpuSampleBlockCount: number;



    CollectFromAllThreads(): void;
    FilterToCurrentThread(): void;


}
    
interface RecorderConstructor {




    Get(samplerName: string): Recorder;

}
declare const Recorder: RecorderConstructor;
    
interface SamplerConstructor {




    Get(name: string): Sampler;
    GetNames(names: CSArray<string>): number;

}
declare const Sampler: SamplerConstructor;
    
interface CustomSampler extends Sampler {



    Begin(): void;
    Begin(targetObject: Object): void;
    End(): void;


}
    
interface CustomSamplerConstructor {




    Create(name: string, collectGpuData: boolean): CustomSampler;

}
declare const CustomSampler: CustomSamplerConstructor;
    
interface ProfilerMarker {
    readonly Handle: unknown;



    Auto(): AutoScope;
    Begin(): void;
    Begin(contextUnityObject: Object): void;
    End(): void;


}
    
interface AutoScope {



    Dispose(): void;


}
    
interface ProfilerMarkerConstructor {


    new(name: string): ProfilerMarker;
    new(name: unknown, nameLen: number): ProfilerMarker;
    new(category: ProfilerCategory, name: string): ProfilerMarker;
    new(category: ProfilerCategory, name: unknown, nameLen: number): ProfilerMarker;
    new(category: ProfilerCategory, name: string, flags: MarkerFlags): ProfilerMarker;
    new(category: ProfilerCategory, name: unknown, nameLen: number, flags: MarkerFlags): ProfilerMarker;



}
declare const ProfilerMarker: ProfilerMarkerConstructor;
    
interface Material extends Object {
    shader: Shader;
    color: Color;
    mainTexture: Texture;
    mainTextureOffset: Vector2;
    mainTextureScale: Vector2;
    renderQueue: number;
    enabledKeywords: CSArray<LocalKeyword>;
    globalIlluminationFlags: MaterialGlobalIlluminationFlags;
    doubleSidedGI: boolean;
    enableInstancing: boolean;
    readonly passCount: number;
    shaderKeywords: CSArray<string>;
    parent: Material;
    readonly isVariant: boolean;



    ApplyPropertyOverride(destination: Material, nameID: number, recordUndo: boolean): void;
    ApplyPropertyOverride(destination: Material, name: string, recordUndo: boolean): void;
    ComputeCRC(): number;
    CopyMatchingPropertiesFromMaterial(mat: Material): void;
    CopyPropertiesFromMaterial(mat: Material): void;
    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    FindPass(passName: string): number;
    GetBuffer(name: string): GraphicsBufferHandle;
    GetColor(name: string): Color;
    GetColor(nameID: number): Color;
    GetColorArray(name: string): CSArray<Color>;
    GetColorArray(nameID: number): CSArray<Color>;
    GetColorArray(name: string, values: CSArray<Color>): void;
    GetColorArray(nameID: number, values: CSArray<Color>): void;
    GetConstantBuffer(name: string): GraphicsBufferHandle;
    GetFloat(name: string): number;
    GetFloat(nameID: number): number;
    GetFloatArray(name: string): CSArray<number>;
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    GetInt(name: string): number;
    GetInt(nameID: number): number;
    GetInteger(name: string): number;
    GetInteger(nameID: number): number;
    GetMatrix(name: string): Matrix4x4;
    GetMatrix(nameID: number): Matrix4x4;
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetPassName(pass: number): string;
    GetPropertyNames(type: MaterialPropertyType): CSArray<string>;
    GetShaderPassEnabled(passName: string): boolean;
    GetTag(tag: string, searchFallbacks: boolean, defaultValue: string): string;
    GetTag(tag: string, searchFallbacks: boolean): string;
    GetTexture(name: string): Texture;
    GetTexture(nameID: number): Texture;
    GetTextureOffset(name: string): Vector2;
    GetTextureOffset(nameID: number): Vector2;
    GetTexturePropertyNameIDs(): CSArray<number>;
    GetTexturePropertyNameIDs(outNames: CSArray<number>): void;
    GetTexturePropertyNames(): CSArray<string>;
    GetTexturePropertyNames(outNames: CSArray<string>): void;
    GetTextureScale(name: string): Vector2;
    GetTextureScale(nameID: number): Vector2;
    GetVector(name: string): Vector4;
    GetVector(nameID: number): Vector4;
    GetVectorArray(name: string): CSArray<Vector4>;
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    HasBuffer(name: string): boolean;
    HasBuffer(nameID: number): boolean;
    HasColor(name: string): boolean;
    HasColor(nameID: number): boolean;
    HasConstantBuffer(name: string): boolean;
    HasConstantBuffer(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInteger(name: string): boolean;
    HasInteger(nameID: number): boolean;
    HasMatrix(name: string): boolean;
    HasMatrix(nameID: number): boolean;
    HasProperty(nameID: number): boolean;
    HasProperty(name: string): boolean;
    HasTexture(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasVector(name: string): boolean;
    HasVector(nameID: number): boolean;
    IsChildOf(ancestor: Material): boolean;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    IsPropertyLocked(nameID: number): boolean;
    IsPropertyLocked(name: string): boolean;
    IsPropertyLockedByAncestor(nameID: number): boolean;
    IsPropertyLockedByAncestor(name: string): boolean;
    IsPropertyOverriden(nameID: number): boolean;
    IsPropertyOverriden(name: string): boolean;
    Lerp(start: Material, end: Material, t: number): void;
    RevertAllPropertyOverrides(): void;
    RevertPropertyOverride(nameID: number): void;
    RevertPropertyOverride(name: string): void;
    SetBuffer(name: string, value: ComputeBuffer): void;
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    SetBuffer(name: string, value: GraphicsBuffer): void;
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    SetColor(name: string, value: Color): void;
    SetColor(nameID: number, value: Color): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(name: string, value: number): void;
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetInt(name: string, value: number): void;
    SetInt(nameID: number, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(nameID: number, value: number): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetMatrix(name: string, value: Matrix4x4): void;
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetOverrideTag(tag: string, val: string): void;
    SetPass(pass: number): boolean;
    SetPropertyLock(nameID: number, value: boolean): void;
    SetPropertyLock(name: string, value: boolean): void;
    SetShaderPassEnabled(passName: string, enabled: boolean): void;
    SetTexture(name: string, value: Texture): void;
    SetTexture(nameID: number, value: Texture): void;
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTextureOffset(name: string, value: Vector2): void;
    SetTextureOffset(nameID: number, value: Vector2): void;
    SetTextureScale(name: string, value: Vector2): void;
    SetTextureScale(nameID: number, value: Vector2): void;
    SetVector(name: string, value: Vector4): void;
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;


}
    
interface Shader extends Object {
    maximumLOD: number;
    readonly isSupported: boolean;
    readonly keywordSpace: LocalKeywordSpace;
    readonly renderQueue: number;
    readonly passCount: number;
    readonly subshaderCount: number;



    FindPassTagValue(passIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindPassTagValue(subshaderIndex: number, passIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindPropertyIndex(propertyName: string): number;
    FindSubshaderTagValue(subshaderIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindTextureStack(propertyIndex: number, stackName: CSArray<string>, layerIndex: unknown): boolean;
    GetDependency(name: string): Shader;
    GetPassCountInSubshader(subshaderIndex: number): number;
    GetPropertyAttributes(propertyIndex: number): CSArray<string>;
    GetPropertyCount(): number;
    GetPropertyDefaultFloatValue(propertyIndex: number): number;
    GetPropertyDefaultIntValue(propertyIndex: number): number;
    GetPropertyDefaultVectorValue(propertyIndex: number): Vector4;
    GetPropertyDescription(propertyIndex: number): string;
    GetPropertyFlags(propertyIndex: number): ShaderPropertyFlags;
    GetPropertyName(propertyIndex: number): string;
    GetPropertyNameId(propertyIndex: number): number;
    GetPropertyRangeLimits(propertyIndex: number): Vector2;
    GetPropertyTextureDefaultName(propertyIndex: number): string;
    GetPropertyTextureDimension(propertyIndex: number): TextureDimension;
    GetPropertyType(propertyIndex: number): ShaderPropertyType;


}
    
interface LocalKeywordSpace {
    readonly keywords: CSArray<LocalKeyword>;
    readonly keywordNames: CSArray<string>;
    readonly keywordCount: number;



    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeywordSpace): boolean;
    FindKeyword(name: string): LocalKeyword;
    GetHashCode(): number;


}
    
interface LocalKeyword {
    readonly name: string;
    readonly isDynamic: boolean;
    readonly isOverridable: boolean;
    readonly isValid: boolean;
    readonly type: ShaderKeywordType;



    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeyword): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface LocalKeywordConstructor {


    new(shader: Shader, name: string): LocalKeyword;
    new(shader: ComputeShader, name: string): LocalKeyword;



}
declare const LocalKeyword: LocalKeywordConstructor;
    
interface ShaderTagId {
    readonly name: string;



    Equals(obj: unknown): boolean;
    Equals(other: ShaderTagId): boolean;
    GetHashCode(): number;


}
    
interface ShaderTagIdConstructor {
    readonly none: ShaderTagId;


    new(name: string): ShaderTagId;



}
declare const ShaderTagId: ShaderTagIdConstructor;
    
interface GlobalKeyword {
    readonly name: string;



    ToString(): string;


}
    
interface GlobalKeywordConstructor {


    new(name: string): GlobalKeyword;


    Create(name: string): GlobalKeyword;

}
declare const GlobalKeyword: GlobalKeywordConstructor;
    
interface RayTracingAccelerationStructure {



    AddInstance(targetRenderer: Renderer, subMeshFlags: CSArray<number>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): number;
    AddInstance(config: RayTracingAABBsInstanceConfig, matrix: Matrix4x4, id: number): number;
    AddInstance(config: unknown, matrix: Matrix4x4, prevMatrix: unknown, id: number): number;
    AddInstance(config: unknown, matrix: Matrix4x4, prevMatrix: unknown, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, id: number): number;
    AddVFXInstances(targetRenderer: Renderer, vfxSystemMasks: CSArray<number>): void;
    Build(): void;
    Build(relativeOrigin: Vector3): void;
    Build(buildSettings: BuildSettings): void;
    ClearInstances(): void;
    CullInstances(cullingConfig: unknown): RayTracingInstanceCullingResults;
    Dispose(): void;
    GetInstanceCount(): number;
    GetSize(): number;
    Release(): void;
    RemoveInstance(targetRenderer: Renderer): void;
    RemoveInstance(handle: number): void;
    RemoveVFXInstances(targetRenderer: Renderer): void;
    UpdateInstanceID(renderer: Renderer, instanceID: number): void;
    UpdateInstanceID(handle: number, instanceID: number): void;
    UpdateInstanceMask(renderer: Renderer, mask: number): void;
    UpdateInstanceMask(handle: number, mask: number): void;
    UpdateInstancePropertyBlock(handle: number, properties: MaterialPropertyBlock): void;
    UpdateInstanceTransform(renderer: Renderer): void;
    UpdateInstanceTransform(handle: number, matrix: Matrix4x4): void;


}
    
interface Renderer extends Component {
    bounds: Bounds;
    localBounds: Bounds;
    enabled: boolean;
    readonly isVisible: boolean;
    shadowCastingMode: ShadowCastingMode;
    receiveShadows: boolean;
    forceRenderingOff: boolean;
    staticShadowCaster: boolean;
    motionVectorGenerationMode: MotionVectorGenerationMode;
    lightProbeUsage: LightProbeUsage;
    reflectionProbeUsage: ReflectionProbeUsage;
    renderingLayerMask: number;
    rendererPriority: number;
    rayTracingMode: RayTracingMode;
    rayTracingAccelerationStructureBuildFlags: RayTracingAccelerationStructureBuildFlags;
    rayTracingAccelerationStructureBuildFlagsOverride: boolean;
    sortingLayerName: string;
    sortingLayerID: number;
    sortingOrder: number;
    allowOcclusionWhenDynamic: boolean;
    readonly isPartOfStaticBatch: boolean;
    readonly worldToLocalMatrix: Matrix4x4;
    readonly localToWorldMatrix: Matrix4x4;
    lightProbeProxyVolumeOverride: GameObject;
    probeAnchor: Transform;
    lightmapIndex: number;
    realtimeLightmapIndex: number;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;
    materials: CSArray<Material>;
    material: Material;
    sharedMaterial: Material;
    sharedMaterials: CSArray<Material>;



    GetClosestReflectionProbes(result: CSArray<ReflectionProbeBlendInfo>): void;
    GetMaterials(m: CSArray<Material>): void;
    GetPropertyBlock(properties: MaterialPropertyBlock): void;
    GetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    GetSharedMaterials(m: CSArray<Material>): void;
    HasPropertyBlock(): boolean;
    ResetBounds(): void;
    ResetLocalBounds(): void;
    SetMaterials(materials: CSArray<Material>): void;
    SetPropertyBlock(properties: MaterialPropertyBlock): void;
    SetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    SetSharedMaterials(materials: CSArray<Material>): void;


}
    
interface ReflectionProbeBlendInfo {
    probe: ReflectionProbe;
    weight: number;





}
    
interface ReflectionProbe extends Behaviour {
    size: Vector3;
    center: Vector3;
    nearClipPlane: number;
    farClipPlane: number;
    intensity: number;
    readonly bounds: Bounds;
    hdr: boolean;
    renderDynamicObjects: boolean;
    shadowDistance: number;
    resolution: number;
    cullingMask: number;
    clearFlags: ReflectionProbeClearFlags;
    backgroundColor: Color;
    blendDistance: number;
    boxProjection: boolean;
    mode: ReflectionProbeMode;
    importance: number;
    refreshMode: ReflectionProbeRefreshMode;
    timeSlicingMode: ReflectionProbeTimeSlicingMode;
    bakedTexture: Texture;
    customBakedTexture: Texture;
    realtimeTexture: RenderTexture;
    readonly texture: Texture;
    readonly textureHDRDecodeValues: Vector4;



    IsFinishedRendering(renderId: number): boolean;
    RenderProbe(): number;
    RenderProbe(targetTexture: RenderTexture): number;
    Reset(): void;


}
    
interface ReflectionProbeConstructor {
    readonly minBakedCubemapResolution: number;
    readonly maxBakedCubemapResolution: number;
    readonly defaultTextureHDRDecodeValues: Vector4;
    readonly defaultTexture: Texture;


    new(): ReflectionProbe;


    BlendCubemap(src: Texture, dst: Texture, blend: number, target: RenderTexture): boolean;
    UpdateCachedState(): void;

    readonly reflectionProbeChanged: MonoSignal<ReflectionProbe, ReflectionProbeEvent>;
    readonly defaultReflectionTexture: MonoSignal<Texture>;
}
declare const ReflectionProbe: ReflectionProbeConstructor;
    
interface MaterialPropertyBlock {
    readonly isEmpty: boolean;



    Clear(): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    GetColor(name: string): Color;
    GetColor(nameID: number): Color;
    GetFloat(name: string): number;
    GetFloat(nameID: number): number;
    GetFloatArray(name: string): CSArray<number>;
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    GetInt(name: string): number;
    GetInt(nameID: number): number;
    GetInteger(name: string): number;
    GetInteger(nameID: number): number;
    GetMatrix(name: string): Matrix4x4;
    GetMatrix(nameID: number): Matrix4x4;
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetTexture(name: string): Texture;
    GetTexture(nameID: number): Texture;
    GetVector(name: string): Vector4;
    GetVector(nameID: number): Vector4;
    GetVectorArray(name: string): CSArray<Vector4>;
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    HasBuffer(name: string): boolean;
    HasBuffer(nameID: number): boolean;
    HasColor(name: string): boolean;
    HasColor(nameID: number): boolean;
    HasConstantBuffer(name: string): boolean;
    HasConstantBuffer(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInteger(name: string): boolean;
    HasInteger(nameID: number): boolean;
    HasMatrix(name: string): boolean;
    HasMatrix(nameID: number): boolean;
    HasProperty(name: string): boolean;
    HasProperty(nameID: number): boolean;
    HasTexture(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasVector(name: string): boolean;
    HasVector(nameID: number): boolean;
    SetBuffer(name: string, value: ComputeBuffer): void;
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    SetBuffer(name: string, value: GraphicsBuffer): void;
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    SetColor(name: string, value: Color): void;
    SetColor(nameID: number, value: Color): void;
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(name: string, value: number): void;
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetInt(name: string, value: number): void;
    SetInt(nameID: number, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(nameID: number, value: number): void;
    SetMatrix(name: string, value: Matrix4x4): void;
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetTexture(name: string, value: Texture): void;
    SetTexture(nameID: number, value: Texture): void;
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetVector(name: string, value: Vector4): void;
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;


}
    
interface SphericalHarmonicsL2 {
    Item: number;



    AddAmbientLight(color: Color): void;
    AddDirectionalLight(direction: Vector3, color: Color, intensity: number): void;
    Clear(): void;
    Equals(other: unknown): boolean;
    Equals(other: SphericalHarmonicsL2): boolean;
    Evaluate(directions: CSArray<Vector3>, results: CSArray<Color>): void;
    GetHashCode(): number;


}
    
interface MaterialPropertyBlockConstructor {


    new(): MaterialPropertyBlock;



}
declare const MaterialPropertyBlock: MaterialPropertyBlockConstructor;
    
interface RendererConstructor {


    new(): Renderer;



}
declare const Renderer: RendererConstructor;
    
interface RayTracingAABBsInstanceConfig {
    aabbBuffer: GraphicsBuffer;
    aabbCount: number;
    aabbOffset: number;
    dynamicGeometry: boolean;
    opaqueMaterial: boolean;
    material: Material;
    materialProperties: MaterialPropertyBlock;
    layer: number;
    mask: number;
    accelerationStructureBuildFlags: RayTracingAccelerationStructureBuildFlags;
    accelerationStructureBuildFlagsOverride: boolean;





}
    
interface RayTracingAABBsInstanceConfigConstructor {


    new(): RayTracingAABBsInstanceConfig;
    new(aabbBuffer: GraphicsBuffer, aabbCount: number, dynamicGeometry: boolean, material: Material): RayTracingAABBsInstanceConfig;



}
declare const RayTracingAABBsInstanceConfig: RayTracingAABBsInstanceConfigConstructor;
    
interface BuildSettings {
    buildFlags: RayTracingAccelerationStructureBuildFlags;
    relativeOrigin: Vector3;





}
    
interface BuildSettingsConstructor {


    new(): BuildSettings;
    new(buildFlags: RayTracingAccelerationStructureBuildFlags, relativeOrigin: Vector3): BuildSettings;



}
declare const BuildSettings: BuildSettingsConstructor;
    
interface RayTracingInstanceCullingResults {
    materialsCRC: CSArray<RayTracingInstanceMaterialCRC>;
    transformsChanged: boolean;





}
    
interface RayTracingInstanceMaterialCRC {
    instanceID: number;
    crc: number;





}
    
interface RayTracingAccelerationStructureConstructor {


    new(settings: Settings): RayTracingAccelerationStructure;
    new(): RayTracingAccelerationStructure;



}
declare const RayTracingAccelerationStructure: RayTracingAccelerationStructureConstructor;
    
interface ShaderConstructor {
    maximumChunksOverride: number;
    globalMaximumLOD: number;
    globalRenderPipeline: string;
    readonly enabledGlobalKeywords: CSArray<GlobalKeyword>;
    readonly globalKeywords: CSArray<GlobalKeyword>;




    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    Find(name: string): Shader;
    GetGlobalColor(name: string): Color;
    GetGlobalColor(nameID: number): Color;
    GetGlobalFloat(name: string): number;
    GetGlobalFloat(nameID: number): number;
    GetGlobalFloatArray(name: string): CSArray<number>;
    GetGlobalFloatArray(nameID: number): CSArray<number>;
    GetGlobalFloatArray(name: string, values: CSArray<number>): void;
    GetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    GetGlobalInt(name: string): number;
    GetGlobalInt(nameID: number): number;
    GetGlobalInteger(name: string): number;
    GetGlobalInteger(nameID: number): number;
    GetGlobalMatrix(name: string): Matrix4x4;
    GetGlobalMatrix(nameID: number): Matrix4x4;
    GetGlobalMatrixArray(name: string): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetGlobalTexture(name: string): Texture;
    GetGlobalTexture(nameID: number): Texture;
    GetGlobalVector(name: string): Vector4;
    GetGlobalVector(nameID: number): Vector4;
    GetGlobalVectorArray(name: string): CSArray<Vector4>;
    GetGlobalVectorArray(nameID: number): CSArray<Vector4>;
    GetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    GetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    PropertyToID(name: string): number;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalRayTracingAccelerationStructure(name: string, value: RayTracingAccelerationStructure): void;
    SetGlobalRayTracingAccelerationStructure(nameID: number, value: RayTracingAccelerationStructure): void;
    SetGlobalTexture(name: string, value: Texture): void;
    SetGlobalTexture(nameID: number, value: Texture): void;
    SetGlobalTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    WarmupAllShaders(): void;

}
declare const Shader: ShaderConstructor;
    
interface MaterialConstructor {


    new(shader: Shader): Material;
    new(source: Material): Material;
    new(contents: string): Material;



}
declare const Material: MaterialConstructor;
    
interface GraphicsFence {
    readonly passed: boolean;





}
    
interface ComputeShader extends Object {
    readonly keywordSpace: LocalKeywordSpace;
    shaderKeywords: CSArray<string>;
    enabledKeywords: CSArray<LocalKeyword>;



    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    Dispatch(kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    FindKernel(name: string): number;
    GetKernelThreadGroupSizes(kernelIndex: number, x: unknown, y: unknown, z: unknown): void;
    HasKernel(name: string): boolean;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    IsSupported(kernelIndex: number): boolean;
    SetBool(name: string, val: boolean): void;
    SetBool(nameID: number, val: boolean): void;
    SetBuffer(kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    SetBuffer(kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    SetBuffer(kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    SetBuffer(kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(nameID: number, val: number): void;
    SetFloat(name: string, val: number): void;
    SetFloats(name: string, values: CSArray<number>): void;
    SetFloats(nameID: number, values: CSArray<number>): void;
    SetInt(nameID: number, val: number): void;
    SetInt(name: string, val: number): void;
    SetInts(name: string, values: CSArray<number>): void;
    SetInts(nameID: number, values: CSArray<number>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetMatrix(nameID: number, val: Matrix4x4): void;
    SetMatrix(name: string, val: Matrix4x4): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetRayTracingAccelerationStructure(kernelIndex: number, nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(kernelIndex: number, name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetTexture(kernelIndex: number, nameID: number, texture: Texture, mipLevel: number): void;
    SetTexture(kernelIndex: number, nameID: number, texture: Texture): void;
    SetTexture(kernelIndex: number, name: string, texture: Texture): void;
    SetTexture(kernelIndex: number, name: string, texture: Texture, mipLevel: number): void;
    SetTexture(kernelIndex: number, nameID: number, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    SetTexture(kernelIndex: number, name: string, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    SetTextureFromGlobal(kernelIndex: number, nameID: number, globalTextureNameID: number): void;
    SetTextureFromGlobal(kernelIndex: number, name: string, globalTextureName: string): void;
    SetVector(nameID: number, val: Vector4): void;
    SetVector(name: string, val: Vector4): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;


}
    
interface RayTracingShader extends Object {
    readonly maxRecursionDepth: number;



    Dispatch(rayGenFunctionName: string, width: number, height: number, depth: number, camera: Camera): void;
    SetAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetBool(name: string, val: boolean): void;
    SetBool(nameID: number, val: boolean): void;
    SetBuffer(nameID: number, buffer: ComputeBuffer): void;
    SetBuffer(nameID: number, buffer: GraphicsBuffer): void;
    SetBuffer(nameID: number, bufferHandle: GraphicsBufferHandle): void;
    SetBuffer(name: string, buffer: ComputeBuffer): void;
    SetBuffer(name: string, buffer: GraphicsBuffer): void;
    SetBuffer(name: string, bufferHandle: GraphicsBufferHandle): void;
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(nameID: number, val: number): void;
    SetFloat(name: string, val: number): void;
    SetFloats(name: string, values: CSArray<number>): void;
    SetFloats(nameID: number, values: CSArray<number>): void;
    SetInt(nameID: number, val: number): void;
    SetInt(name: string, val: number): void;
    SetInts(name: string, values: CSArray<number>): void;
    SetInts(nameID: number, values: CSArray<number>): void;
    SetMatrix(nameID: number, val: Matrix4x4): void;
    SetMatrix(name: string, val: Matrix4x4): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetShaderPass(passName: string): void;
    SetTexture(nameID: number, texture: Texture): void;
    SetTexture(name: string, texture: Texture): void;
    SetTextureFromGlobal(nameID: number, globalTextureNameID: number): void;
    SetTextureFromGlobal(name: string, globalTextureName: string): void;
    SetVector(nameID: number, val: Vector4): void;
    SetVector(name: string, val: Vector4): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;


}
    
interface RectInt {
    x: number;
    y: number;
    readonly center: Vector2;
    min: Vector2Int;
    max: Vector2Int;
    width: number;
    height: number;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    position: Vector2Int;
    size: Vector2Int;
    readonly allPositionsWithin: PositionEnumerator;



    ClampToBounds(bounds: RectInt): void;
    Contains(position: Vector2Int): boolean;
    Equals(other: unknown): boolean;
    Equals(other: RectInt): boolean;
    GetHashCode(): number;
    Overlaps(other: RectInt): boolean;
    SetMinMax(minPosition: Vector2Int, maxPosition: Vector2Int): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;


}
    
    
    
interface PositionEnumerator {
    readonly Current: Vector2Int;



    GetEnumerator(): PositionEnumerator;
    MoveNext(): boolean;
    Reset(): void;


}
    
interface PositionEnumeratorConstructor {


    new(min: Vector2Int, max: Vector2Int): PositionEnumerator;



}
declare const PositionEnumerator: PositionEnumeratorConstructor;
    
interface RectIntConstructor {
    readonly zero: RectInt;


    new(xMin: number, yMin: number, width: number, height: number): RectInt;
    new(position: Vector2Int, size: Vector2Int): RectInt;



}
declare const RectInt: RectIntConstructor;
    
interface RendererList {
    readonly isValid: boolean;





}
    
interface RendererListConstructor {
    readonly nullRendererList: RendererList;





}
declare const RendererList: RendererListConstructor;
    
interface RenderTargetBinding {
    colorRenderTargets: CSArray<RenderTargetIdentifier>;
    depthRenderTarget: RenderTargetIdentifier;
    colorLoadActions: CSArray<number>;
    colorStoreActions: CSArray<number>;
    depthLoadAction: RenderBufferLoadAction;
    depthStoreAction: RenderBufferStoreAction;
    flags: RenderTargetFlags;





}
    
interface RenderTargetBindingConstructor {


    new(colorRenderTargets: CSArray<RenderTargetIdentifier>, colorLoadActions: CSArray<number>, colorStoreActions: CSArray<number>, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    new(colorRenderTarget: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    new(setup: RenderTargetSetup): RenderTargetBinding;



}
declare const RenderTargetBinding: RenderTargetBindingConstructor;
    
interface CommandBufferConstructor {
    ThrowOnSetRenderTarget: boolean;


    new(): CommandBuffer;



}
declare const CommandBuffer: CommandBufferConstructor;
    
interface Cubemap extends Texture {
    readonly format: TextureFormat;
    readonly isReadable: boolean;
    readonly streamingMipmaps: boolean;
    readonly streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    readonly desiredMipmapLevel: number;
    readonly loadingMipmapLevel: number;
    readonly loadedMipmapLevel: number;



    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    ClearRequestedMipmapLevel(): void;
    GetPixel(face: CubemapFace, x: number, y: number): Color;
    GetPixel(face: CubemapFace, x: number, y: number, mip: number): Color;
    GetPixelData<T>(mipLevel: number, face: CubemapFace): CSArray<T>;
    GetPixels(face: CubemapFace, miplevel: number): CSArray<Color>;
    GetPixels(face: CubemapFace): CSArray<Color>;
    IsRequestedMipmapLevelLoaded(): boolean;
    SetPixel(face: CubemapFace, x: number, y: number, color: Color): void;
    SetPixel(face: CubemapFace, x: number, y: number, color: Color, mip: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixels(colors: CSArray<Color>, face: CubemapFace, miplevel: number): void;
    SetPixels(colors: CSArray<Color>, face: CubemapFace): void;
    SmoothEdges(smoothRegionWidthInPixels: number): void;
    SmoothEdges(): void;
    UpdateExternalTexture(nativeTexture: unknown): void;


}
    
interface CubemapConstructor {


    new(width: number, format: DefaultFormat, flags: TextureCreationFlags): Cubemap;
    new(width: number, format: DefaultFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    new(width: number, format: GraphicsFormat, flags: TextureCreationFlags): Cubemap;
    new(width: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    new(width: number, textureFormat: TextureFormat, mipChain: boolean): Cubemap;
    new(width: number, textureFormat: TextureFormat, mipChain: boolean, createUninitialized: boolean): Cubemap;
    new(width: number, format: TextureFormat, mipCount: number): Cubemap;
    new(width: number, format: TextureFormat, mipCount: number, createUninitialized: boolean): Cubemap;


    CreateExternalTexture(width: number, format: TextureFormat, mipmap: boolean, nativeTex: unknown): Cubemap;

}
declare const Cubemap: CubemapConstructor;
    
interface CameraCallback {



    BeginInvoke(cam: Camera, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(cam: Camera): void;


}
    
interface CameraCallbackConstructor {


    new(object: unknown, method: unknown): CameraCallback;



}
declare const CameraCallback: CameraCallbackConstructor;
    
interface GateFitParameters {
    mode: GateFitMode;
    aspect: number;





}
    
interface GateFitParametersConstructor {


    new(mode: GateFitMode, aspect: number): GateFitParameters;



}
declare const GateFitParameters: GateFitParametersConstructor;
    
interface CameraConstructor {
    kMinAperture: number;
    kMaxAperture: number;
    kMinBladeCount: number;
    kMaxBladeCount: number;
    onPreCull: CameraCallback;
    onPreRender: CameraCallback;
    onPostRender: CameraCallback;
    readonly main: Camera;
    readonly current: Camera;
    readonly allCamerasCount: number;
    readonly allCameras: CSArray<Camera>;


    new(): Camera;


    CalculateProjectionMatrixFromPhysicalProperties(output: unknown, focalLength: number, sensorSize: Vector2, lensShift: Vector2, nearClip: number, farClip: number, gateFitParameters: GateFitParameters): void;
    FieldOfViewToFocalLength(fieldOfView: number, sensorSize: number): number;
    FocalLengthToFieldOfView(focalLength: number, sensorSize: number): number;
    GetAllCameras(cameras: CSArray<Camera>): number;
    HorizontalToVerticalFieldOfView(horizontalFieldOfView: number, aspectRatio: number): number;
    SetupCurrent(cur: Camera): void;
    VerticalToHorizontalFieldOfView(verticalFieldOfView: number, aspectRatio: number): number;

}
declare const Camera: CameraConstructor;
    
interface Input {





}
    
interface LocationService {
    readonly isEnabledByUser: boolean;
    readonly status: LocationServiceStatus;
    readonly lastData: LocationInfo;



    Start(desiredAccuracyInMeters: number, updateDistanceInMeters: number): void;
    Start(desiredAccuracyInMeters: number): void;
    Start(): void;
    Stop(): void;


}
    
interface LocationInfo {
    readonly latitude: number;
    readonly longitude: number;
    readonly altitude: number;
    readonly horizontalAccuracy: number;
    readonly verticalAccuracy: number;
    readonly timestamp: number;





}
    
interface LocationServiceConstructor {


    new(): LocationService;



}
declare const LocationService: LocationServiceConstructor;
    
interface Compass {
    readonly magneticHeading: number;
    readonly trueHeading: number;
    readonly headingAccuracy: number;
    readonly rawVector: Vector3;
    readonly timestamp: number;
    enabled: boolean;





}
    
interface CompassConstructor {


    new(): Compass;



}
declare const Compass: CompassConstructor;
    
interface Gyroscope {
    readonly rotationRate: Vector3;
    readonly rotationRateUnbiased: Vector3;
    readonly gravity: Vector3;
    readonly userAcceleration: Vector3;
    readonly attitude: Quaternion;
    enabled: boolean;
    updateInterval: number;





}
    
interface Touch {
    fingerId: number;
    position: Vector2;
    rawPosition: Vector2;
    deltaPosition: Vector2;
    deltaTime: number;
    tapCount: number;
    phase: TouchPhase;
    pressure: number;
    maximumPossiblePressure: number;
    type: TouchType;
    altitudeAngle: number;
    azimuthAngle: number;
    radius: number;
    radiusVariance: number;





}
    
interface AccelerationEvent {
    readonly acceleration: Vector3;
    readonly deltaTime: number;





}
    
interface PenData {
    position: Vector2;
    tilt: Vector2;
    penStatus: PenStatus;
    twist: number;
    pressure: number;
    contactType: PenEventType;
    deltaPos: Vector2;





}
    
interface InputConstructor {
    simulateMouseWithTouches: boolean;
    readonly anyKey: boolean;
    readonly anyKeyDown: boolean;
    readonly inputString: string;
    readonly mousePosition: Vector3;
    readonly mousePositionDelta: Vector3;
    readonly mouseScrollDelta: Vector2;
    imeCompositionMode: IMECompositionMode;
    readonly compositionString: string;
    readonly imeIsSelected: boolean;
    compositionCursorPos: Vector2;
    readonly mousePresent: boolean;
    readonly penEventCount: number;
    readonly touchCount: number;
    readonly touchPressureSupported: boolean;
    readonly stylusTouchSupported: boolean;
    readonly touchSupported: boolean;
    multiTouchEnabled: boolean;
    readonly deviceOrientation: DeviceOrientation;
    readonly acceleration: Vector3;
    compensateSensors: boolean;
    readonly accelerationEventCount: number;
    backButtonLeavesApp: boolean;
    readonly location: LocationService;
    readonly compass: Compass;
    readonly gyro: Gyroscope;
    readonly touches: CSArray<Touch>;
    readonly accelerationEvents: CSArray<AccelerationEvent>;


    new(): Input;


    ClearLastPenContactEvent(): void;
    GetAccelerationEvent(index: number): AccelerationEvent;
    GetAxis(axisName: string): number;
    GetAxisRaw(axisName: string): number;
    GetButton(buttonName: string): boolean;
    GetButtonDown(buttonName: string): boolean;
    GetButtonUp(buttonName: string): boolean;
    GetJoystickNames(): CSArray<string>;
    GetKey(key: KeyCode): boolean;
    GetKey(name: string): boolean;
    GetKeyDown(key: KeyCode): boolean;
    GetKeyDown(name: string): boolean;
    GetKeyUp(key: KeyCode): boolean;
    GetKeyUp(name: string): boolean;
    GetLastPenContactEvent(): PenData;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetPenEvent(index: number): PenData;
    GetTouch(index: number): Touch;
    IsJoystickPreconfigured(joystickName: string): boolean;
    ResetInputAxes(): void;
    ResetPenEvents(): void;

}
declare const Input: InputConstructor;
    
interface IEventSystemHandler {





}
    
interface ISubmitHandler extends IEventSystemHandler {



    OnSubmit(eventData: BaseEventData): void;


}
    
interface AbstractEventData {
    readonly used: boolean;



    Reset(): void;
    Use(): void;


}
    
interface BaseEventData extends AbstractEventData {
    readonly currentInputModule: BaseInputModule;
    selectedObject: GameObject;





}
    
interface UIBehaviour extends MonoBehaviour {



    IsActive(): boolean;
    IsDestroyed(): boolean;


}
    
interface BaseInputModule extends UIBehaviour {
    readonly input: BaseInput;
    inputOverride: BaseInput;



    ActivateModule(): void;
    ConvertUIToolkitPointerId(sourcePointerData: PointerEventData): number;
    DeactivateModule(): void;
    IsModuleSupported(): boolean;
    IsPointerOverGameObject(pointerId: number): boolean;
    Process(): void;
    ShouldActivateModule(): boolean;
    UpdateModule(): void;


}
    
interface BaseInput extends UIBehaviour {
    readonly compositionString: string;
    imeCompositionMode: IMECompositionMode;
    compositionCursorPos: Vector2;
    readonly mousePresent: boolean;
    readonly mousePosition: Vector2;
    readonly mouseScrollDelta: Vector2;
    readonly touchSupported: boolean;
    readonly touchCount: number;



    GetAxisRaw(axisName: string): number;
    GetButtonDown(buttonName: string): boolean;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetTouch(index: number): Touch;


}
    
interface BaseInputConstructor {


    new(): BaseInput;



}
declare const BaseInput: BaseInputConstructor;
    
interface PointerEventData extends BaseEventData {
    hovered: CSArray<GameObject>;
    pointerEnter: GameObject;
    readonly lastPress: GameObject;
    rawPointerPress: GameObject;
    pointerDrag: GameObject;
    pointerClick: GameObject;
    pointerCurrentRaycast: RaycastResult;
    pointerPressRaycast: RaycastResult;
    eligibleForClick: boolean;
    displayIndex: number;
    pointerId: number;
    position: Vector2;
    delta: Vector2;
    pressPosition: Vector2;
    clickTime: number;
    clickCount: number;
    scrollDelta: Vector2;
    useDragThreshold: boolean;
    dragging: boolean;
    button: InputButton;
    pressure: number;
    tangentialPressure: number;
    altitudeAngle: number;
    azimuthAngle: number;
    twist: number;
    tilt: Vector2;
    penStatus: PenStatus;
    radius: Vector2;
    radiusVariance: Vector2;
    fullyExited: boolean;
    reentered: boolean;
    readonly enterEventCamera: Camera;
    readonly pressEventCamera: Camera;
    pointerPress: GameObject;



    IsPointerMoving(): boolean;
    IsScrolling(): boolean;
    ToString(): string;


}
    
interface RaycastResult {
    module: BaseRaycaster;
    distance: number;
    index: number;
    depth: number;
    sortingGroupID: number;
    sortingGroupOrder: number;
    sortingLayer: number;
    sortingOrder: number;
    worldPosition: Vector3;
    worldNormal: Vector3;
    screenPosition: Vector2;
    displayIndex: number;
    gameObject: GameObject;
    readonly isValid: boolean;



    Clear(): void;
    ToString(): string;


}
    
interface BaseRaycaster extends UIBehaviour {
    readonly eventCamera: Camera;
    readonly sortOrderPriority: number;
    readonly renderOrderPriority: number;
    readonly rootRaycaster: BaseRaycaster;



    Raycast(eventData: PointerEventData, resultAppendList: CSArray<RaycastResult>): void;
    ToString(): string;


}
    
interface PointerEventDataConstructor {


    new(eventSystem: EventSystem): PointerEventData;



}
declare const PointerEventData: PointerEventDataConstructor;
    
interface BaseEventDataConstructor {


    new(eventSystem: EventSystem): BaseEventData;



}
declare const BaseEventData: BaseEventDataConstructor;
    
interface IPointerClickHandler extends IEventSystemHandler {



    OnPointerClick(eventData: PointerEventData): void;


}
    
interface IPointerEnterHandler extends IEventSystemHandler {



    OnPointerEnter(eventData: PointerEventData): void;


}
    
interface ISelectHandler extends IEventSystemHandler {



    OnSelect(eventData: BaseEventData): void;


}
    
interface IPointerExitHandler extends IEventSystemHandler {



    OnPointerExit(eventData: PointerEventData): void;


}
    
interface IDeselectHandler extends IEventSystemHandler {



    OnDeselect(eventData: BaseEventData): void;


}
    
interface IPointerDownHandler extends IEventSystemHandler {



    OnPointerDown(eventData: PointerEventData): void;


}
    
interface IPointerUpHandler extends IEventSystemHandler {



    OnPointerUp(eventData: PointerEventData): void;


}
    
interface IMoveHandler extends IEventSystemHandler {



    OnMove(eventData: AxisEventData): void;


}
    
interface AxisEventData extends BaseEventData {
    moveVector: Vector2;
    moveDir: MoveDirection;





}
    
interface AxisEventDataConstructor {


    new(eventSystem: EventSystem): AxisEventData;



}
declare const AxisEventData: AxisEventDataConstructor;
    
interface Selectable extends UIBehaviour, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
    navigation: Navigation;
    transition: Transition;
    colors: ColorBlock;
    spriteState: SpriteState;
    animationTriggers: AnimationTriggers;
    targetGraphic: Graphic;
    interactable: boolean;
    image: Image;
    readonly animator: Animator;



    FindSelectable(dir: Vector3): Selectable;
    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    IsInteractable(): boolean;
    OnDeselect(eventData: BaseEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    Select(): void;


}
    
interface Navigation {
    mode: Mode;
    wrapAround: boolean;
    selectOnUp: Selectable;
    selectOnDown: Selectable;
    selectOnLeft: Selectable;
    selectOnRight: Selectable;



    Equals(other: Navigation): boolean;


}
    
interface NavigationConstructor {
    readonly defaultNavigation: Navigation;





}
declare const Navigation: NavigationConstructor;
    
interface ColorBlock {
    normalColor: Color;
    highlightedColor: Color;
    pressedColor: Color;
    selectedColor: Color;
    disabledColor: Color;
    colorMultiplier: number;
    fadeDuration: number;



    Equals(obj: unknown): boolean;
    Equals(other: ColorBlock): boolean;
    GetHashCode(): number;


}
    
interface ColorBlockConstructor {
    defaultColorBlock: ColorBlock;





}
declare const ColorBlock: ColorBlockConstructor;
    
interface SpriteState {
    highlightedSprite: Sprite;
    pressedSprite: Sprite;
    selectedSprite: Sprite;
    disabledSprite: Sprite;



    Equals(other: SpriteState): boolean;


}
    
interface AnimationTriggers {
    normalTrigger: string;
    highlightedTrigger: string;
    pressedTrigger: string;
    selectedTrigger: string;
    disabledTrigger: string;





}
    
interface AnimationTriggersConstructor {


    new(): AnimationTriggers;



}
declare const AnimationTriggers: AnimationTriggersConstructor;
    
interface ICanvasElement {
    readonly transform: Transform;



    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;


}
    
interface Graphic extends UIBehaviour, ICanvasElement {
    color: Color;
    raycastTarget: boolean;
    raycastPadding: Vector4;
    readonly depth: number;
    readonly rectTransform: RectTransform;
    readonly canvas: Canvas;
    readonly canvasRenderer: CanvasRenderer;
    readonly defaultMaterial: Material;
    material: Material;
    readonly materialForRendering: Material;
    readonly mainTexture: Texture;



    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean, useRGB: boolean): void;
    GetPixelAdjustedRect(): Rect;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnCullingChanged(): void;
    OnRebuildRequested(): void;
    PixelAdjustPoint(point: Vector2): Vector2;
    Raycast(sp: Vector2, eventCamera: Camera): boolean;
    Rebuild(update: CanvasUpdate): void;
    RegisterDirtyLayoutCallback(action: UnityAction): void;
    RegisterDirtyMaterialCallback(action: UnityAction): void;
    RegisterDirtyVerticesCallback(action: UnityAction): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetNativeSize(): void;
    SetRaycastDirty(): void;
    SetVerticesDirty(): void;
    UnregisterDirtyLayoutCallback(action: UnityAction): void;
    UnregisterDirtyMaterialCallback(action: UnityAction): void;
    UnregisterDirtyVerticesCallback(action: UnityAction): void;


}
    
interface RectTransform extends Transform {
    readonly rect: Rect;
    anchorMin: Vector2;
    anchorMax: Vector2;
    anchoredPosition: Vector2;
    sizeDelta: Vector2;
    pivot: Vector2;
    anchoredPosition3D: Vector3;
    offsetMin: Vector2;
    offsetMax: Vector2;
    readonly drivenByObject: Object;



    ForceUpdateRectTransforms(): void;
    GetLocalCorners(fourCornersArray: CSArray<Vector3>): void;
    GetWorldCorners(fourCornersArray: CSArray<Vector3>): void;
    SetInsetAndSizeFromParentEdge(edge: Edge, inset: number, size: number): void;
    SetSizeWithCurrentAnchors(axis: Axis, size: number): void;


}
    
interface RectTransformConstructor {


    new(): RectTransform;



    readonly reapplyDrivenProperties: MonoSignal<void>;
}
declare const RectTransform: RectTransformConstructor;
    
interface Canvas extends Behaviour {
    renderMode: RenderMode;
    readonly isRootCanvas: boolean;
    readonly pixelRect: Rect;
    scaleFactor: number;
    referencePixelsPerUnit: number;
    overridePixelPerfect: boolean;
    vertexColorAlwaysGammaSpace: boolean;
    pixelPerfect: boolean;
    planeDistance: number;
    readonly renderOrder: number;
    overrideSorting: boolean;
    sortingOrder: number;
    targetDisplay: number;
    sortingLayerID: number;
    readonly cachedSortingLayerValue: number;
    additionalShaderChannels: AdditionalCanvasShaderChannels;
    sortingLayerName: string;
    readonly rootCanvas: Canvas;
    readonly renderingDisplaySize: Vector2;
    updateRectTransformForStandalone: StandaloneRenderResize;
    worldCamera: Camera;
    normalizedSortingGridSize: number;





}
    
interface CanvasConstructor {


    new(): Canvas;


    ForceUpdateCanvases(): void;
    GetDefaultCanvasMaterial(): Material;
    GetETC1SupportedCanvasMaterial(): Material;

    readonly preWillRenderCanvases: MonoSignal<void>;
    readonly willRenderCanvases: MonoSignal<void>;
}
declare const Canvas: CanvasConstructor;
    
interface CanvasRenderer extends Component {
    hasPopInstruction: boolean;
    materialCount: number;
    popMaterialCount: number;
    readonly absoluteDepth: number;
    readonly hasMoved: boolean;
    cullTransparentMesh: boolean;
    readonly hasRectClipping: boolean;
    readonly relativeDepth: number;
    cull: boolean;
    clippingSoftness: Vector2;



    Clear(): void;
    DisableRectClipping(): void;
    EnableRectClipping(rect: Rect): void;
    GetAlpha(): number;
    GetColor(): Color;
    GetInheritedAlpha(): number;
    GetMaterial(index: number): Material;
    GetMaterial(): Material;
    GetMesh(): Mesh;
    GetPopMaterial(index: number): Material;
    SetAlpha(alpha: number): void;
    SetAlphaTexture(texture: Texture): void;
    SetColor(color: Color): void;
    SetMaterial(material: Material, index: number): void;
    SetMaterial(material: Material, texture: Texture): void;
    SetMesh(mesh: Mesh): void;
    SetPopMaterial(material: Material, index: number): void;
    SetTexture(texture: Texture): void;


}
    
interface UIVertex {
    position: Vector3;
    normal: Vector3;
    tangent: Vector4;
    color: Color32;
    uv0: Vector4;
    uv1: Vector4;
    uv2: Vector4;
    uv3: Vector4;





}
    
interface UIVertexConstructor {
    simpleVert: UIVertex;





}
declare const UIVertex: UIVertexConstructor;
    
interface CanvasRendererConstructor {


    new(): CanvasRenderer;


    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;

    readonly onRequestRebuild: MonoSignal<void>;
}
declare const CanvasRenderer: CanvasRendererConstructor;
    
interface UnityAction {



    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;


}
    
interface UnityActionConstructor {


    new(object: unknown, method: unknown): UnityAction;



}
declare const UnityAction: UnityActionConstructor;
    
interface GraphicConstructor {
    readonly defaultGraphicMaterial: Material;





}
declare const Graphic: GraphicConstructor;
    
interface ICanvasRaycastFilter {



    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;


}
    
interface ILayoutElement {
    readonly minWidth: number;
    readonly preferredWidth: number;
    readonly flexibleWidth: number;
    readonly minHeight: number;
    readonly preferredHeight: number;
    readonly flexibleHeight: number;
    readonly layoutPriority: number;



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;


}
    
interface ISerializationCallbackReceiver {



    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;


}
    
interface IClippable {
    readonly gameObject: GameObject;
    readonly rectTransform: RectTransform;



    Cull(clipRect: Rect, validRect: boolean): void;
    RecalculateClipping(): void;
    SetClipRect(value: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;


}
    
interface IMaterialModifier {



    GetModifiedMaterial(baseMaterial: Material): Material;


}
    
interface IMaskable {



    RecalculateMasking(): void;


}
    
interface MaskableGraphic extends Graphic, IClippable, IMaterialModifier, IMaskable {
    maskable: boolean;
    isMaskingGraphic: boolean;

    readonly onCullStateChanged: MonoSignal<void>;


    Cull(clipRect: Rect, validRect: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    RecalculateClipping(): void;
    RecalculateMasking(): void;
    SetClipRect(clipRect: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;


}
    
interface Image extends MaskableGraphic, ICanvasRaycastFilter, ILayoutElement, ISerializationCallbackReceiver {
    sprite: Sprite;
    overrideSprite: Sprite;
    type: Type;
    preserveAspect: boolean;
    fillCenter: boolean;
    fillMethod: FillMethod;
    fillAmount: number;
    fillClockwise: boolean;
    fillOrigin: number;
    alphaHitTestMinimumThreshold: number;
    useSpriteMesh: boolean;
    readonly mainTexture: Texture;
    readonly hasBorder: boolean;
    pixelsPerUnitMultiplier: number;
    readonly pixelsPerUnit: number;
    material: Material;
    readonly minWidth: number;
    readonly preferredWidth: number;
    readonly flexibleWidth: number;
    readonly minHeight: number;
    readonly preferredHeight: number;
    readonly flexibleHeight: number;
    readonly layoutPriority: number;



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DisableSpriteOptimizations(): void;
    IsRaycastLocationValid(screenPoint: Vector2, eventCamera: Camera): boolean;
    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;
    SetNativeSize(): void;


}
    
interface ImageConstructor {
    readonly defaultETC1GraphicMaterial: Material;





}
declare const Image: ImageConstructor;
    
interface Animator extends Behaviour {
    readonly isOptimizable: boolean;
    readonly isHuman: boolean;
    readonly hasRootMotion: boolean;
    readonly humanScale: number;
    readonly isInitialized: boolean;
    readonly deltaPosition: Vector3;
    readonly deltaRotation: Quaternion;
    readonly velocity: Vector3;
    readonly angularVelocity: Vector3;
    rootPosition: Vector3;
    rootRotation: Quaternion;
    applyRootMotion: boolean;
    animatePhysics: boolean;
    updateMode: AnimatorUpdateMode;
    readonly hasTransformHierarchy: boolean;
    readonly gravityWeight: number;
    bodyPosition: Vector3;
    bodyRotation: Quaternion;
    stabilizeFeet: boolean;
    readonly layerCount: number;
    readonly parameters: CSArray<AnimatorControllerParameter>;
    readonly parameterCount: number;
    feetPivotActive: number;
    readonly pivotWeight: number;
    readonly pivotPosition: Vector3;
    readonly isMatchingTarget: boolean;
    speed: number;
    readonly targetPosition: Vector3;
    readonly targetRotation: Quaternion;
    readonly avatarRoot: Transform;
    cullingMode: AnimatorCullingMode;
    playbackTime: number;
    recorderStartTime: number;
    recorderStopTime: number;
    readonly recorderMode: AnimatorRecorderMode;
    runtimeAnimatorController: RuntimeAnimatorController;
    readonly hasBoundPlayables: boolean;
    avatar: Avatar;
    readonly playableGraph: PlayableGraph;
    layersAffectMassCenter: boolean;
    readonly leftFeetBottomHeight: number;
    readonly rightFeetBottomHeight: number;
    logWarnings: boolean;
    fireEvents: boolean;
    keepAnimatorStateOnDisable: boolean;
    writeDefaultValuesOnDisable: boolean;



    ApplyBuiltinRootMotion(): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    GetBehaviour<T>(): T;
    GetBehaviours<T>(): CSArray<T>;
    GetBehaviours(fullPathHash: number, layerIndex: number): CSArray<StateMachineBehaviour>;
    GetBoneTransform(humanBoneId: HumanBodyBones): Transform;
    GetBool(name: string): boolean;
    GetBool(id: number): boolean;
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetFloat(name: string): number;
    GetFloat(id: number): number;
    GetIKHintPosition(hint: AvatarIKHint): Vector3;
    GetIKHintPositionWeight(hint: AvatarIKHint): number;
    GetIKPosition(goal: AvatarIKGoal): Vector3;
    GetIKPositionWeight(goal: AvatarIKGoal): number;
    GetIKRotation(goal: AvatarIKGoal): Quaternion;
    GetIKRotationWeight(goal: AvatarIKGoal): number;
    GetInteger(name: string): number;
    GetInteger(id: number): number;
    GetLayerIndex(layerName: string): number;
    GetLayerName(layerIndex: number): string;
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetParameter(index: number): AnimatorControllerParameter;
    HasState(layerIndex: number, stateID: number): boolean;
    InterruptMatchTarget(): void;
    InterruptMatchTarget(completeMatch: boolean): void;
    IsInTransition(layerIndex: number): boolean;
    IsParameterControlledByCurve(name: string): boolean;
    IsParameterControlledByCurve(id: number): boolean;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number, completeMatch: boolean): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string): void;
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    Rebind(): void;
    ResetTrigger(name: string): void;
    ResetTrigger(id: number): void;
    SetBoneLocalRotation(humanBoneId: HumanBodyBones, rotation: Quaternion): void;
    SetBool(name: string, value: boolean): void;
    SetBool(id: number, value: boolean): void;
    SetFloat(name: string, value: number): void;
    SetFloat(name: string, value: number, dampTime: number, deltaTime: number): void;
    SetFloat(id: number, value: number): void;
    SetFloat(id: number, value: number, dampTime: number, deltaTime: number): void;
    SetIKHintPosition(hint: AvatarIKHint, hintPosition: Vector3): void;
    SetIKHintPositionWeight(hint: AvatarIKHint, value: number): void;
    SetIKPosition(goal: AvatarIKGoal, goalPosition: Vector3): void;
    SetIKPositionWeight(goal: AvatarIKGoal, value: number): void;
    SetIKRotation(goal: AvatarIKGoal, goalRotation: Quaternion): void;
    SetIKRotationWeight(goal: AvatarIKGoal, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(id: number, value: number): void;
    SetLayerWeight(layerIndex: number, weight: number): void;
    SetLookAtPosition(lookAtPosition: Vector3): void;
    SetLookAtWeight(weight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number, clampWeight: number): void;
    SetTarget(targetIndex: AvatarTarget, targetNormalizedTime: number): void;
    SetTrigger(name: string): void;
    SetTrigger(id: number): void;
    StartPlayback(): void;
    StartRecording(frameCount: number): void;
    StopPlayback(): void;
    StopRecording(): void;
    Update(deltaTime: number): void;
    WriteDefaultValues(): void;


}
    
interface AnimatorControllerParameter {
    name: string;
    readonly nameHash: number;
    type: AnimatorControllerParameterType;
    defaultFloat: number;
    defaultInt: number;
    defaultBool: boolean;



    Equals(o: unknown): boolean;
    GetHashCode(): number;


}
    
interface AnimatorControllerParameterConstructor {


    new(): AnimatorControllerParameter;



}
declare const AnimatorControllerParameter: AnimatorControllerParameterConstructor;
    
interface RuntimeAnimatorController extends Object {
    readonly animationClips: CSArray<AnimationClip>;





}
    
interface Motion extends Object {
    readonly averageDuration: number;
    readonly averageAngularSpeed: number;
    readonly averageSpeed: Vector3;
    readonly apparentSpeed: number;
    readonly isLooping: boolean;
    readonly legacy: boolean;
    readonly isHumanMotion: boolean;





}
    
interface AnimationClip extends Motion {
    readonly length: number;
    frameRate: number;
    wrapMode: WrapMode;
    localBounds: Bounds;
    legacy: boolean;
    readonly humanMotion: boolean;
    readonly empty: boolean;
    readonly hasGenericRootTransform: boolean;
    readonly hasMotionFloatCurves: boolean;
    readonly hasMotionCurves: boolean;
    readonly hasRootCurves: boolean;
    events: CSArray<AnimationEvent>;



    AddEvent(evt: AnimationEvent): void;
    ClearCurves(): void;
    EnsureQuaternionContinuity(): void;
    SampleAnimation(go: GameObject, time: number): void;
    SetCurve(relativePath: string, type: unknown, propertyName: string, curve: AnimationCurve): void;


}
    
interface AnimationEvent {
    stringParameter: string;
    floatParameter: number;
    intParameter: number;
    objectReferenceParameter: Object;
    functionName: string;
    time: number;
    messageOptions: SendMessageOptions;
    readonly isFiredByLegacy: boolean;
    readonly isFiredByAnimator: boolean;
    readonly animationState: AnimationState;
    readonly animatorStateInfo: AnimatorStateInfo;
    readonly animatorClipInfo: AnimatorClipInfo;





}
    
interface TrackedReference {



    Equals(o: unknown): boolean;
    GetHashCode(): number;


}
    
interface AnimationState extends TrackedReference {
    enabled: boolean;
    weight: number;
    wrapMode: WrapMode;
    time: number;
    normalizedTime: number;
    speed: number;
    normalizedSpeed: number;
    readonly length: number;
    layer: number;
    readonly clip: AnimationClip;
    name: string;
    blendMode: AnimationBlendMode;



    AddMixingTransform(mix: Transform): void;
    AddMixingTransform(mix: Transform, recursive: boolean): void;
    RemoveMixingTransform(mix: Transform): void;


}
    
interface AnimationStateConstructor {


    new(): AnimationState;



}
declare const AnimationState: AnimationStateConstructor;
    
interface AnimatorStateInfo {
    readonly fullPathHash: number;
    readonly shortNameHash: number;
    readonly normalizedTime: number;
    readonly length: number;
    readonly speed: number;
    readonly speedMultiplier: number;
    readonly tagHash: number;
    readonly loop: boolean;



    IsName(name: string): boolean;
    IsTag(tag: string): boolean;


}
    
interface AnimatorClipInfo {
    readonly clip: AnimationClip;
    readonly weight: number;





}
    
interface AnimationEventConstructor {


    new(): AnimationEvent;



}
declare const AnimationEvent: AnimationEventConstructor;
    
interface AnimationCurve {
    keys: CSArray<Keyframe>;
    readonly Item: Keyframe;
    readonly length: number;
    preWrapMode: WrapMode;
    postWrapMode: WrapMode;



    AddKey(time: number, value: number): number;
    AddKey(key: Keyframe): number;
    ClearKeys(): void;
    CopyFrom(other: AnimationCurve): void;
    Equals(o: unknown): boolean;
    Equals(other: AnimationCurve): boolean;
    Evaluate(time: number): number;
    GetHashCode(): number;
    MoveKey(index: number, key: Keyframe): number;
    RemoveKey(index: number): void;
    SmoothTangents(index: number, weight: number): void;


}
    
interface Keyframe {
    time: number;
    value: number;
    inTangent: number;
    outTangent: number;
    inWeight: number;
    outWeight: number;
    weightedMode: WeightedMode;





}
    
interface KeyframeConstructor {


    new(time: number, value: number): Keyframe;
    new(time: number, value: number, inTangent: number, outTangent: number): Keyframe;
    new(time: number, value: number, inTangent: number, outTangent: number, inWeight: number, outWeight: number): Keyframe;



}
declare const Keyframe: KeyframeConstructor;
    
interface AnimationCurveConstructor {


    new(keys: CSArray<Keyframe>): AnimationCurve;
    new(): AnimationCurve;


    Constant(timeStart: number, timeEnd: number, value: number): AnimationCurve;
    EaseInOut(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
    Linear(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;

}
declare const AnimationCurve: AnimationCurveConstructor;
    
interface AnimationClipConstructor {


    new(): AnimationClip;



}
declare const AnimationClip: AnimationClipConstructor;
    
interface Avatar extends Object {
    readonly isValid: boolean;
    readonly isHuman: boolean;
    readonly humanDescription: HumanDescription;





}
    
interface HumanDescription {
    human: CSArray<HumanBone>;
    skeleton: CSArray<SkeletonBone>;
    upperArmTwist: number;
    lowerArmTwist: number;
    upperLegTwist: number;
    lowerLegTwist: number;
    armStretch: number;
    legStretch: number;
    feetSpacing: number;
    hasTranslationDoF: boolean;





}
    
interface HumanBone {
    limit: HumanLimit;
    boneName: string;
    humanName: string;





}
    
interface HumanLimit {
    useDefaultValues: boolean;
    min: Vector3;
    max: Vector3;
    center: Vector3;
    axisLength: number;





}
    
interface SkeletonBone {
    name: string;
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;





}
    
interface PlayableGraph {



    Connect<U, V>(source: U, sourceOutputPort: number, destination: V, destinationInputPort: number): boolean;
    Destroy(): void;
    DestroyOutput<U>(output: U): void;
    DestroyPlayable<U>(playable: U): void;
    DestroySubgraph<U>(playable: U): void;
    Disconnect<U>(input: U, inputPort: number): void;
    Evaluate(): void;
    Evaluate(deltaTime: number): void;
    GetEditorName(): string;
    GetOutput(index: number): PlayableOutput;
    GetOutputByType<T>(index: number): PlayableOutput;
    GetOutputCount(): number;
    GetOutputCountByType<T>(): number;
    GetPlayableCount(): number;
    GetResolver(): IExposedPropertyTable;
    GetRootPlayable(index: number): Playable;
    GetRootPlayableCount(): number;
    GetTimeUpdateMode(): DirectorUpdateMode;
    IsDone(): boolean;
    IsPlaying(): boolean;
    IsValid(): boolean;
    Play(): void;
    SetResolver(value: IExposedPropertyTable): void;
    SetTimeUpdateMode(value: DirectorUpdateMode): void;
    Stop(): void;


}
    
interface IPlayableOutput {



    GetHandle(): PlayableOutputHandle;


}
    
interface PlayableOutputHandle {



    Equals(p: unknown): boolean;
    Equals(other: PlayableOutputHandle): boolean;
    GetHashCode(): number;


}
    
interface PlayableOutputHandleConstructor {
    readonly Null: PlayableOutputHandle;





}
declare const PlayableOutputHandle: PlayableOutputHandleConstructor;
    
interface PlayableOutput extends IPlayableOutput {



    Equals(other: PlayableOutput): boolean;
    GetHandle(): PlayableOutputHandle;
    GetPlayableOutputType(): unknown;
    IsPlayableOutputOfType<T>(): boolean;


}
    
interface PlayableOutputConstructor {
    readonly Null: PlayableOutput;





}
declare const PlayableOutput: PlayableOutputConstructor;
    
interface IExposedPropertyTable {



    ClearReferenceValue(id: PropertyName): void;
    GetReferenceValue(id: PropertyName, idValid: unknown): Object;
    SetReferenceValue(id: PropertyName, value: Object): void;


}
    
interface PropertyName {



    Equals(other: unknown): boolean;
    Equals(other: PropertyName): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface PropertyNameConstructor {


    new(name: string): PropertyName;
    new(other: PropertyName): PropertyName;
    new(id: number): PropertyName;


    IsNullOrEmpty(prop: PropertyName): boolean;

}
declare const PropertyName: PropertyNameConstructor;
    
interface IPlayable {



    GetHandle(): PlayableHandle;


}
    
interface PlayableHandle {



    Equals(p: unknown): boolean;
    Equals(other: PlayableHandle): boolean;
    GetHashCode(): number;


}
    
interface PlayableHandleConstructor {
    readonly Null: PlayableHandle;





}
declare const PlayableHandle: PlayableHandleConstructor;
    
interface Playable extends IPlayable {



    Equals(other: Playable): boolean;
    GetHandle(): PlayableHandle;
    GetPlayableType(): unknown;
    IsPlayableOfType<T>(): boolean;


}
    
interface PlayableConstructor {
    readonly Null: Playable;




    Create(graph: PlayableGraph, inputCount: number): Playable;

}
declare const Playable: PlayableConstructor;
    
interface PlayableGraphConstructor {




    Create(): PlayableGraph;
    Create(name: string): PlayableGraph;

}
declare const PlayableGraph: PlayableGraphConstructor;
    
interface AnimatorTransitionInfo {
    readonly fullPathHash: number;
    readonly nameHash: number;
    readonly userNameHash: number;
    readonly durationUnit: DurationUnit;
    readonly duration: number;
    readonly normalizedTime: number;
    readonly anyState: boolean;



    IsName(name: string): boolean;
    IsUserName(name: string): boolean;


}
    
interface StateMachineBehaviour extends ScriptableObject {



    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;


}
    
interface AnimatorControllerPlayable extends IPlayable {



    CrossFade(stateName: string, transitionDuration: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number, fixedTime: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number, fixedTime: number): void;
    Equals(other: AnimatorControllerPlayable): boolean;
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    GetBool(name: string): boolean;
    GetBool(id: number): boolean;
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetFloat(name: string): number;
    GetFloat(id: number): number;
    GetHandle(): PlayableHandle;
    GetInteger(name: string): number;
    GetInteger(id: number): number;
    GetLayerCount(): number;
    GetLayerIndex(layerName: string): number;
    GetLayerName(layerIndex: number): string;
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetParameter(index: number): AnimatorControllerParameter;
    GetParameterCount(): number;
    HasState(layerIndex: number, stateID: number): boolean;
    IsInTransition(layerIndex: number): boolean;
    IsParameterControlledByCurve(name: string): boolean;
    IsParameterControlledByCurve(id: number): boolean;
    Play(stateName: string): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    ResetTrigger(name: string): void;
    ResetTrigger(id: number): void;
    SetBool(name: string, value: boolean): void;
    SetBool(id: number, value: boolean): void;
    SetFloat(name: string, value: number): void;
    SetFloat(id: number, value: number): void;
    SetHandle(handle: PlayableHandle): void;
    SetInteger(name: string, value: number): void;
    SetInteger(id: number, value: number): void;
    SetLayerWeight(layerIndex: number, weight: number): void;
    SetTrigger(name: string): void;
    SetTrigger(id: number): void;


}
    
interface AnimatorControllerPlayableConstructor {
    readonly Null: AnimatorControllerPlayable;




    Create(graph: PlayableGraph, controller: RuntimeAnimatorController): AnimatorControllerPlayable;

}
declare const AnimatorControllerPlayable: AnimatorControllerPlayableConstructor;
    
interface MatchTargetWeightMask {
    positionXYZWeight: Vector3;
    rotationWeight: number;





}
    
interface MatchTargetWeightMaskConstructor {


    new(positionXYZWeight: Vector3, rotationWeight: number): MatchTargetWeightMask;



}
declare const MatchTargetWeightMask: MatchTargetWeightMaskConstructor;
    
interface AnimatorConstructor {


    new(): Animator;


    StringToHash(name: string): number;

}
declare const Animator: AnimatorConstructor;
    
interface SelectableConstructor {
    readonly allSelectablesArray: CSArray<Selectable>;
    readonly allSelectableCount: number;




    AllSelectablesNoAlloc(selectables: CSArray<Selectable>): number;

}
declare const Selectable: SelectableConstructor;
    
interface Button extends Selectable, ISubmitHandler, IPointerClickHandler {

    readonly onClick: MonoSignal<void>;


    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;


}
    
interface MeshRenderer extends Renderer {
    additionalVertexStreams: Mesh;
    enlightenVertexStream: Mesh;
    readonly subMeshStartIndex: number;
    scaleInLightmap: number;
    receiveGI: ReceiveGI;
    stitchLightmapSeams: boolean;





}
    
interface MeshRendererConstructor {


    new(): MeshRenderer;



}
declare const MeshRenderer: MeshRendererConstructor;
    
interface MeshFilter extends Component {
    sharedMesh: Mesh;
    mesh: Mesh;





}
    
interface MeshFilterConstructor {


    new(): MeshFilter;



}
declare const MeshFilter: MeshFilterConstructor;
    
interface TMP_Text extends MaskableGraphic {
    text: string;
    textPreprocessor: ITextPreprocessor;
    isRightToLeftText: boolean;
    font: TMP_FontAsset;
    fontSharedMaterial: Material;
    fontSharedMaterials: CSArray<Material>;
    fontMaterial: Material;
    fontMaterials: CSArray<Material>;
    color: Color;
    alpha: number;
    enableVertexGradient: boolean;
    colorGradient: VertexGradient;
    colorGradientPreset: TMP_ColorGradient;
    spriteAsset: TMP_SpriteAsset;
    tintAllSprites: boolean;
    styleSheet: TMP_StyleSheet;
    textStyle: TMP_Style;
    overrideColorTags: boolean;
    faceColor: Color32;
    outlineColor: Color32;
    outlineWidth: number;
    fontSize: number;
    fontWeight: FontWeight;
    readonly pixelsPerUnit: number;
    enableAutoSizing: boolean;
    fontSizeMin: number;
    fontSizeMax: number;
    fontStyle: FontStyles;
    readonly isUsingBold: boolean;
    horizontalAlignment: HorizontalAlignmentOptions;
    verticalAlignment: VerticalAlignmentOptions;
    alignment: TextAlignmentOptions;
    characterSpacing: number;
    wordSpacing: number;
    lineSpacing: number;
    lineSpacingAdjustment: number;
    paragraphSpacing: number;
    characterWidthAdjustment: number;
    textWrappingMode: TextWrappingModes;
    wordWrappingRatios: number;
    overflowMode: TextOverflowModes;
    readonly isTextOverflowing: boolean;
    readonly firstOverflowCharacterIndex: number;
    linkedTextComponent: TMP_Text;
    readonly isTextTruncated: boolean;
    fontFeatures: CSArray<OTL_FeatureTag>;
    extraPadding: boolean;
    richText: boolean;
    emojiFallbackSupport: boolean;
    parseCtrlCharacters: boolean;
    isOverlay: boolean;
    isOrthographic: boolean;
    enableCulling: boolean;
    ignoreVisibility: boolean;
    horizontalMapping: TextureMappingOptions;
    verticalMapping: TextureMappingOptions;
    mappingUvLineOffset: number;
    renderMode: TextRenderFlags;
    geometrySortingOrder: VertexSortingOrder;
    isTextObjectScaleStatic: boolean;
    vertexBufferAutoSizeReduction: boolean;
    firstVisibleCharacter: number;
    maxVisibleCharacters: number;
    maxVisibleWords: number;
    maxVisibleLines: number;
    useMaxVisibleDescender: boolean;
    pageToDisplay: number;
    margin: Vector4;
    readonly textInfo: TMP_TextInfo;
    havePropertiesChanged: boolean;
    isUsingLegacyAnimationComponent: boolean;
    readonly transform: Transform;
    readonly rectTransform: RectTransform;
    autoSizeTextContainer: boolean;
    readonly mesh: Mesh;
    isVolumetricText: boolean;
    readonly bounds: Bounds;
    readonly textBounds: Bounds;
    readonly flexibleHeight: number;
    readonly flexibleWidth: number;
    readonly minWidth: number;
    readonly minHeight: number;
    readonly maxWidth: number;
    readonly maxHeight: number;
    readonly preferredWidth: number;
    readonly preferredHeight: number;
    readonly renderedWidth: number;
    readonly renderedHeight: number;
    readonly layoutPriority: number;

    readonly OnPreRenderText: MonoSignal<TMP_TextInfo>;


    ClearMesh(): void;
    ClearMesh(uploadGeometry: boolean): void;
    ComputeMarginSize(): void;
    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetParsedText(): string;
    GetPreferredValues(): Vector2;
    GetPreferredValues(width: number, height: number): Vector2;
    GetPreferredValues(text: string): Vector2;
    GetPreferredValues(text: string, width: number, height: number): Vector2;
    GetRenderedValues(): Vector2;
    GetRenderedValues(onlyVisibleCharacters: boolean): Vector2;
    GetTextInfo(text: string): TMP_TextInfo;
    SetCharArray(sourceText: CSArray<string>): void;
    SetCharArray(sourceText: CSArray<string>, start: number, length: number): void;
    SetText(sourceText: string): void;
    SetText(sourceText: string, arg0: number): void;
    SetText(sourceText: string, arg0: number, arg1: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
    SetText(sourceText: unknown): void;
    SetText(sourceText: CSArray<string>): void;
    SetText(sourceText: CSArray<string>, start: number, length: number): void;
    SetVertices(vertices: CSArray<Vector3>): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;


}
    
interface ITextPreprocessor {



    PreprocessText(text: string): string;


}
    
interface TMP_Asset extends ScriptableObject {
    readonly version: string;
    readonly instanceID: number;
    hashCode: number;
    faceInfo: FaceInfo;
    material: Material;
    materialHashCode: number;





}
    
interface FaceInfo {
    familyName: string;
    styleName: string;
    pointSize: number;
    scale: number;
    lineHeight: number;
    ascentLine: number;
    capLine: number;
    meanLine: number;
    baseline: number;
    descentLine: number;
    superscriptOffset: number;
    superscriptSize: number;
    subscriptOffset: number;
    subscriptSize: number;
    underlineOffset: number;
    underlineThickness: number;
    strikethroughOffset: number;
    strikethroughThickness: number;
    tabWidth: number;



    Compare(other: FaceInfo): boolean;


}
    
interface TMP_FontAsset extends TMP_Asset {
    normalStyle: number;
    normalSpacingOffset: number;
    boldStyle: number;
    boldSpacing: number;
    italicStyle: number;
    tabSize: number;
    atlas: Texture2D;
    creationSettings: FontAssetCreationSettings;
    readonly sourceFontFile: Font;
    atlasPopulationMode: AtlasPopulationMode;
    readonly glyphTable: CSArray<Glyph>;
    readonly glyphLookupTable: CSDictionary<number, Glyph>;
    readonly characterTable: CSArray<TMP_Character>;
    readonly characterLookupTable: CSDictionary<number, TMP_Character>;
    readonly atlasTexture: Texture2D;
    atlasTextures: CSArray<Texture2D>;
    readonly atlasTextureCount: number;
    isMultiAtlasTexturesEnabled: boolean;
    getFontFeatures: boolean;
    readonly atlasWidth: number;
    readonly atlasHeight: number;
    readonly atlasPadding: number;
    readonly atlasRenderMode: GlyphRenderMode;
    readonly fontFeatureTable: TMP_FontFeatureTable;
    fallbackFontAssetTable: CSArray<TMP_FontAsset>;
    readonly fontWeightTable: CSArray<TMP_FontWeightPair>;



    ClearFontAssetData(setAtlasSizeToZero: boolean): void;
    HasCharacter(character: number): boolean;
    HasCharacter(character: string, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<string>): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<number>, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string): boolean;
    ReadFontAssetDefinition(): void;
    TryAddCharacters(unicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(unicodes: CSArray<number>, missingUnicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, missingCharacters: CSArray<string>, includeFontFeatures: boolean): boolean;


}
    
interface FontAssetCreationSettings {
    sourceFontFileName: string;
    sourceFontFileGUID: string;
    faceIndex: number;
    pointSizeSamplingMode: number;
    pointSize: number;
    padding: number;
    paddingMode: number;
    packingMode: number;
    atlasWidth: number;
    atlasHeight: number;
    characterSetSelectionMode: number;
    characterSequence: string;
    referencedFontAssetGUID: string;
    referencedTextAssetGUID: string;
    fontStyle: number;
    fontStyleModifier: number;
    renderMode: number;
    includeFontFeatures: boolean;





}
    
interface Font extends Object {
    material: Material;
    fontNames: CSArray<string>;
    readonly dynamic: boolean;
    readonly ascent: number;
    readonly fontSize: number;
    characterInfo: CSArray<CharacterInfo>;
    readonly lineHeight: number;



    GetCharacterInfo(ch: string, info: unknown, size: number, style: FontStyle): boolean;
    GetCharacterInfo(ch: string, info: unknown, size: number): boolean;
    GetCharacterInfo(ch: string, info: unknown): boolean;
    HasCharacter(c: string): boolean;
    RequestCharactersInTexture(characters: string, size: number, style: FontStyle): void;
    RequestCharactersInTexture(characters: string, size: number): void;
    RequestCharactersInTexture(characters: string): void;


}
    
interface CharacterInfo {
    index: number;
    size: number;
    style: FontStyle;
    advance: number;
    glyphWidth: number;
    glyphHeight: number;
    bearing: number;
    minY: number;
    maxY: number;
    minX: number;
    maxX: number;
    uvBottomLeft: Vector2;
    uvBottomRight: Vector2;
    uvTopRight: Vector2;
    uvTopLeft: Vector2;





}
    
interface FontConstructor {


    new(): Font;
    new(name: string): Font;


    CreateDynamicFontFromOSFont(fontname: string, size: number): Font;
    CreateDynamicFontFromOSFont(fontnames: CSArray<string>, size: number): Font;
    GetMaxVertsForString(str: string): number;
    GetOSInstalledFontNames(): CSArray<string>;
    GetPathsToOSFonts(): CSArray<string>;

    readonly textureRebuilt: MonoSignal<Font>;
}
declare const Font: FontConstructor;
    
interface Glyph {
    index: number;
    metrics: GlyphMetrics;
    glyphRect: GlyphRect;
    scale: number;
    atlasIndex: number;
    classDefinitionType: GlyphClassDefinitionType;



    Compare(other: Glyph): boolean;


}
    
interface GlyphMetrics {
    width: number;
    height: number;
    horizontalBearingX: number;
    horizontalBearingY: number;
    horizontalAdvance: number;



    Equals(obj: unknown): boolean;
    Equals(other: GlyphMetrics): boolean;
    GetHashCode(): number;


}
    
interface GlyphMetricsConstructor {


    new(width: number, height: number, bearingX: number, bearingY: number, advance: number): GlyphMetrics;



}
declare const GlyphMetrics: GlyphMetricsConstructor;
    
interface GlyphRect {
    x: number;
    y: number;
    width: number;
    height: number;



    Equals(obj: unknown): boolean;
    Equals(other: GlyphRect): boolean;
    GetHashCode(): number;


}
    
interface GlyphRectConstructor {
    readonly zero: GlyphRect;


    new(x: number, y: number, width: number, height: number): GlyphRect;
    new(rect: Rect): GlyphRect;



}
declare const GlyphRect: GlyphRectConstructor;
    
interface GlyphConstructor {


    new(): Glyph;
    new(glyph: Glyph): Glyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect): Glyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): Glyph;



}
declare const Glyph: GlyphConstructor;
    
interface TMP_TextElement {
    readonly elementType: TextElementType;
    unicode: number;
    textAsset: TMP_Asset;
    glyph: Glyph;
    glyphIndex: number;
    scale: number;





}
    
interface TMP_TextElementConstructor {


    new(): TMP_TextElement;



}
declare const TMP_TextElement: TMP_TextElementConstructor;
    
interface TMP_Character extends TMP_TextElement {





}
    
interface TMP_CharacterConstructor {


    new(): TMP_Character;
    new(unicode: number, glyph: Glyph): TMP_Character;
    new(unicode: number, fontAsset: TMP_FontAsset, glyph: Glyph): TMP_Character;



}
declare const TMP_Character: TMP_CharacterConstructor;
    
interface TMP_FontFeatureTable {
    multipleSubstitutionRecords: CSArray<MultipleSubstitutionRecord>;
    ligatureRecords: CSArray<LigatureSubstitutionRecord>;
    glyphPairAdjustmentRecords: CSArray<GlyphPairAdjustmentRecord>;
    MarkToBaseAdjustmentRecords: CSArray<MarkToBaseAdjustmentRecord>;
    MarkToMarkAdjustmentRecords: CSArray<MarkToMarkAdjustmentRecord>;



    SortGlyphPairAdjustmentRecords(): void;
    SortMarkToBaseAdjustmentRecords(): void;
    SortMarkToMarkAdjustmentRecords(): void;


}
    
interface MultipleSubstitutionRecord {
    targetGlyphID: number;
    substituteGlyphIDs: CSArray<number>;





}
    
interface LigatureSubstitutionRecord {
    componentGlyphIDs: CSArray<number>;
    ligatureGlyphID: number;





}
    
interface GlyphPairAdjustmentRecord {
    firstAdjustmentRecord: GlyphAdjustmentRecord;
    secondAdjustmentRecord: GlyphAdjustmentRecord;
    featureLookupFlags: FontFeatureLookupFlags;



    Equals(obj: unknown): boolean;
    Equals(other: GlyphPairAdjustmentRecord): boolean;
    GetHashCode(): number;


}
    
interface GlyphAdjustmentRecord {
    glyphIndex: number;
    glyphValueRecord: GlyphValueRecord;



    Equals(obj: unknown): boolean;
    Equals(other: GlyphAdjustmentRecord): boolean;
    GetHashCode(): number;


}
    
interface GlyphValueRecord {
    xPlacement: number;
    yPlacement: number;
    xAdvance: number;
    yAdvance: number;



    Equals(obj: unknown): boolean;
    Equals(other: GlyphValueRecord): boolean;
    GetHashCode(): number;


}
    
interface GlyphValueRecordConstructor {


    new(xPlacement: number, yPlacement: number, xAdvance: number, yAdvance: number): GlyphValueRecord;



}
declare const GlyphValueRecord: GlyphValueRecordConstructor;
    
interface GlyphAdjustmentRecordConstructor {


    new(glyphIndex: number, glyphValueRecord: GlyphValueRecord): GlyphAdjustmentRecord;



}
declare const GlyphAdjustmentRecord: GlyphAdjustmentRecordConstructor;
    
interface GlyphPairAdjustmentRecordConstructor {


    new(firstAdjustmentRecord: GlyphAdjustmentRecord, secondAdjustmentRecord: GlyphAdjustmentRecord): GlyphPairAdjustmentRecord;



}
declare const GlyphPairAdjustmentRecord: GlyphPairAdjustmentRecordConstructor;
    
interface MarkToBaseAdjustmentRecord {
    baseGlyphID: number;
    baseGlyphAnchorPoint: GlyphAnchorPoint;
    markGlyphID: number;
    markPositionAdjustment: MarkPositionAdjustment;





}
    
interface GlyphAnchorPoint {
    xCoordinate: number;
    yCoordinate: number;





}
    
interface MarkPositionAdjustment {
    xPositionAdjustment: number;
    yPositionAdjustment: number;





}
    
interface MarkPositionAdjustmentConstructor {


    new(x: number, y: number): MarkPositionAdjustment;



}
declare const MarkPositionAdjustment: MarkPositionAdjustmentConstructor;
    
interface MarkToMarkAdjustmentRecord {
    baseMarkGlyphID: number;
    baseMarkGlyphAnchorPoint: GlyphAnchorPoint;
    combiningMarkGlyphID: number;
    combiningMarkPositionAdjustment: MarkPositionAdjustment;





}
    
interface TMP_FontFeatureTableConstructor {


    new(): TMP_FontFeatureTable;



}
declare const TMP_FontFeatureTable: TMP_FontFeatureTableConstructor;
    
interface TMP_FontWeightPair {
    regularTypeface: TMP_FontAsset;
    italicTypeface: TMP_FontAsset;





}
    
interface TMP_FontAssetConstructor {


    new(): TMP_FontAsset;


    CreateFontAsset(familyName: string, styleName: string, pointSize: number): TMP_FontAsset;
    CreateFontAsset(fontFilePath: string, faceIndex: number, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number): TMP_FontAsset;
    CreateFontAsset(font: Font): TMP_FontAsset;
    CreateFontAsset(font: Font, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number, atlasPopulationMode: AtlasPopulationMode, enableMultiAtlasSupport: boolean): TMP_FontAsset;
    GetCharacters(fontAsset: TMP_FontAsset): string;
    GetCharactersArray(fontAsset: TMP_FontAsset): CSArray<number>;

}
declare const TMP_FontAsset: TMP_FontAssetConstructor;
    
interface VertexGradient {
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;





}
    
interface VertexGradientConstructor {


    new(color: Color): VertexGradient;
    new(color0: Color, color1: Color, color2: Color, color3: Color): VertexGradient;



}
declare const VertexGradient: VertexGradientConstructor;
    
interface TMP_ColorGradient extends ScriptableObject {
    colorMode: ColorMode;
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;





}
    
interface TMP_ColorGradientConstructor {


    new(): TMP_ColorGradient;
    new(color: Color): TMP_ColorGradient;
    new(color0: Color, color1: Color, color2: Color, color3: Color): TMP_ColorGradient;



}
declare const TMP_ColorGradient: TMP_ColorGradientConstructor;
    
interface TMP_SpriteAsset extends TMP_Asset {
    spriteSheet: Texture;
    spriteInfoList: CSArray<TMP_Sprite>;
    fallbackSpriteAssets: CSArray<TMP_SpriteAsset>;
    readonly spriteCharacterTable: CSArray<TMP_SpriteCharacter>;
    readonly spriteCharacterLookupTable: CSDictionary<number, TMP_SpriteCharacter>;
    readonly spriteGlyphTable: CSArray<TMP_SpriteGlyph>;



    GetSpriteIndexFromHashcode(hashCode: number): number;
    GetSpriteIndexFromName(name: string): number;
    GetSpriteIndexFromUnicode(unicode: number): number;
    SortGlyphTable(): void;
    UpdateLookupTables(): void;


}
    
interface TMP_TextElement_Legacy {
    id: number;
    x: number;
    y: number;
    width: number;
    height: number;
    xOffset: number;
    yOffset: number;
    xAdvance: number;
    scale: number;





}
    
interface TMP_TextElement_LegacyConstructor {


    new(): TMP_TextElement_Legacy;



}
declare const TMP_TextElement_Legacy: TMP_TextElement_LegacyConstructor;
    
interface TMP_Sprite extends TMP_TextElement_Legacy {
    name: string;
    hashCode: number;
    unicode: number;
    pivot: Vector2;
    sprite: Sprite;





}
    
interface TMP_SpriteConstructor {


    new(): TMP_Sprite;



}
declare const TMP_Sprite: TMP_SpriteConstructor;
    
interface TMP_SpriteCharacter extends TMP_TextElement {
    name: string;





}
    
interface TMP_SpriteCharacterConstructor {


    new(): TMP_SpriteCharacter;
    new(unicode: number, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;
    new(unicode: number, spriteAsset: TMP_SpriteAsset, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;



}
declare const TMP_SpriteCharacter: TMP_SpriteCharacterConstructor;
    
interface TMP_SpriteGlyph extends Glyph {
    sprite: Sprite;





}
    
interface TMP_SpriteGlyphConstructor {


    new(): TMP_SpriteGlyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): TMP_SpriteGlyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number, sprite: Sprite): TMP_SpriteGlyph;



}
declare const TMP_SpriteGlyph: TMP_SpriteGlyphConstructor;
    
interface TMP_SpriteAssetConstructor {


    new(): TMP_SpriteAsset;


    SearchForSpriteByHashCode(spriteAsset: TMP_SpriteAsset, hashCode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
    SearchForSpriteByUnicode(spriteAsset: TMP_SpriteAsset, unicode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;

}
declare const TMP_SpriteAsset: TMP_SpriteAssetConstructor;
    
interface TMP_StyleSheet extends ScriptableObject {



    GetStyle(hashCode: number): TMP_Style;
    GetStyle(name: string): TMP_Style;
    RefreshStyles(): void;


}
    
interface TMP_Style {
    name: string;
    hashCode: number;
    readonly styleOpeningDefinition: string;
    readonly styleClosingDefinition: string;
    readonly styleOpeningTagArray: CSArray<number>;
    readonly styleClosingTagArray: CSArray<number>;



    RefreshStyle(): void;


}
    
interface TMP_StyleConstructor {
    readonly NormalStyle: TMP_Style;





}
declare const TMP_Style: TMP_StyleConstructor;
    
interface TMP_StyleSheetConstructor {


    new(): TMP_StyleSheet;



}
declare const TMP_StyleSheet: TMP_StyleSheetConstructor;
    
interface TMP_TextInfo {
    textComponent: TMP_Text;
    characterCount: number;
    spriteCount: number;
    spaceCount: number;
    wordCount: number;
    linkCount: number;
    lineCount: number;
    pageCount: number;
    materialCount: number;
    characterInfo: CSArray<TMP_CharacterInfo>;
    wordInfo: CSArray<TMP_WordInfo>;
    linkInfo: CSArray<TMP_LinkInfo>;
    lineInfo: CSArray<TMP_LineInfo>;
    pageInfo: CSArray<TMP_PageInfo>;
    meshInfo: CSArray<TMP_MeshInfo>;



    ClearAllMeshInfo(): void;
    ClearMeshInfo(updateMesh: boolean): void;
    ClearUnusedVertices(materials: CSArray<MaterialReference>): void;
    CopyMeshInfoVertexData(): CSArray<TMP_MeshInfo>;
    ResetVertexLayout(isVolumetric: boolean): void;


}
    
interface TMP_CharacterInfo {
    elementType: TMP_TextElementType;
    character: string;
    index: number;
    stringLength: number;
    textElement: TMP_TextElement;
    alternativeGlyph: Glyph;
    fontAsset: TMP_FontAsset;
    material: Material;
    materialReferenceIndex: number;
    isUsingAlternateTypeface: boolean;
    pointSize: number;
    lineNumber: number;
    pageNumber: number;
    vertexIndex: number;
    vertex_BL: TMP_Vertex;
    vertex_TL: TMP_Vertex;
    vertex_TR: TMP_Vertex;
    vertex_BR: TMP_Vertex;
    topLeft: Vector3;
    bottomLeft: Vector3;
    topRight: Vector3;
    bottomRight: Vector3;
    origin: number;
    xAdvance: number;
    ascender: number;
    baseLine: number;
    descender: number;
    aspectRatio: number;
    scale: number;
    color: Color32;
    underlineColor: Color32;
    underlineVertexIndex: number;
    strikethroughColor: Color32;
    strikethroughVertexIndex: number;
    highlightColor: Color32;
    highlightState: HighlightState;
    style: FontStyles;
    isVisible: boolean;





}
    
interface TMP_Vertex {
    position: Vector3;
    uv: Vector4;
    uv2: Vector2;
    color: Color32;





}
    
interface TMP_VertexConstructor {
    readonly zero: TMP_Vertex;





}
declare const TMP_Vertex: TMP_VertexConstructor;
    
interface HighlightState {
    color: Color32;
    padding: TMP_Offset;



    Equals(obj: unknown): boolean;
    Equals(other: HighlightState): boolean;
    GetHashCode(): number;


}
    
interface TMP_Offset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    horizontal: number;
    vertical: number;



    Equals(obj: unknown): boolean;
    Equals(other: TMP_Offset): boolean;
    GetHashCode(): number;


}
    
interface TMP_OffsetConstructor {
    readonly zero: TMP_Offset;


    new(left: number, right: number, top: number, bottom: number): TMP_Offset;
    new(horizontal: number, vertical: number): TMP_Offset;



}
declare const TMP_Offset: TMP_OffsetConstructor;
    
interface HighlightStateConstructor {


    new(color: Color32, padding: TMP_Offset): HighlightState;



}
declare const HighlightState: HighlightStateConstructor;
    
interface TMP_WordInfo {
    textComponent: TMP_Text;
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    characterCount: number;



    GetWord(): string;


}
    
interface TMP_LinkInfo {
    textComponent: TMP_Text;
    hashCode: number;
    linkIdFirstCharacterIndex: number;
    linkIdLength: number;
    linkTextfirstCharacterIndex: number;
    linkTextLength: number;



    GetLink(): string;
    GetLinkID(): string;
    GetLinkText(): string;


}
    
interface TMP_LineInfo {
    characterCount: number;
    visibleCharacterCount: number;
    spaceCount: number;
    visibleSpaceCount: number;
    wordCount: number;
    firstCharacterIndex: number;
    firstVisibleCharacterIndex: number;
    lastCharacterIndex: number;
    lastVisibleCharacterIndex: number;
    length: number;
    lineHeight: number;
    ascender: number;
    baseline: number;
    descender: number;
    maxAdvance: number;
    width: number;
    marginLeft: number;
    marginRight: number;
    alignment: HorizontalAlignmentOptions;
    lineExtents: Extents;





}
    
interface Extents {
    min: Vector2;
    max: Vector2;



    ToString(): string;


}
    
interface ExtentsConstructor {


    new(min: Vector2, max: Vector2): Extents;



}
declare const Extents: ExtentsConstructor;
    
interface TMP_PageInfo {
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    ascender: number;
    baseLine: number;
    descender: number;





}
    
interface TMP_MeshInfo {
    mesh: Mesh;
    vertexCount: number;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uvs0: CSArray<Vector4>;
    uvs2: CSArray<Vector2>;
    colors32: CSArray<Color32>;
    triangles: CSArray<number>;
    material: Material;



    Clear(): void;
    Clear(uploadChanges: boolean): void;
    ClearUnusedVertices(): void;
    ClearUnusedVertices(startIndex: number): void;
    ClearUnusedVertices(startIndex: number, updateMesh: boolean): void;
    ResizeMeshInfo(size: number): void;
    ResizeMeshInfo(size: number, isVolumetric: boolean): void;
    SortGeometry(order: VertexSortingOrder): void;
    SortGeometry(sortingOrder: CSArray<number>): void;
    SwapVertexData(src: number, dst: number): void;


}
    
interface TMP_MeshInfoConstructor {


    new(mesh: Mesh, size: number): TMP_MeshInfo;
    new(mesh: Mesh, size: number, isVolumetric: boolean): TMP_MeshInfo;



}
declare const TMP_MeshInfo: TMP_MeshInfoConstructor;
    
interface MaterialReference {
    index: number;
    fontAsset: TMP_FontAsset;
    spriteAsset: TMP_SpriteAsset;
    material: Material;
    isDefaultMaterial: boolean;
    isFallbackMaterial: boolean;
    fallbackMaterial: Material;
    padding: number;
    referenceCount: number;





}
    
interface MaterialReferenceConstructor {


    new(index: number, fontAsset: TMP_FontAsset, spriteAsset: TMP_SpriteAsset, material: Material, padding: number): MaterialReference;


    AddMaterialReference(material: Material, fontAsset: TMP_FontAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    AddMaterialReference(material: Material, spriteAsset: TMP_SpriteAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    Contains(materialReferences: CSArray<MaterialReference>, fontAsset: TMP_FontAsset): boolean;

}
declare const MaterialReference: MaterialReferenceConstructor;
    
interface TMP_TextInfoConstructor {


    new(): TMP_TextInfo;
    new(textComponent: TMP_Text): TMP_TextInfo;


    Resize<T>(array: CSArray<T>, size: number): void;
    Resize<T>(array: CSArray<T>, size: number, isBlockAllocated: boolean): void;

}
declare const TMP_TextInfo: TMP_TextInfoConstructor;
    
interface TMP_TextConstructor {





    readonly OnFontAssetRequest: MonoSignal<number, string, TMP_FontAsset>;
    readonly OnSpriteAssetRequest: MonoSignal<number, string, TMP_SpriteAsset>;
    readonly OnMissingCharacter: MonoSignal<void>;
}
declare const TMP_Text: TMP_TextConstructor;
    
interface TextMeshProUGUI extends TMP_Text, ILayoutElement {
    readonly materialForRendering: Material;
    autoSizeTextContainer: boolean;
    readonly mesh: Mesh;
    readonly canvasRenderer: CanvasRenderer;
    maskOffset: Vector4;

    readonly OnPreRenderText: MonoSignal<TMP_TextInfo>;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    ClearMesh(): void;
    ComputeMarginSize(): void;
    Cull(clipRect: Rect, validRect: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    GetTextInfo(text: string): TMP_TextInfo;
    Rebuild(update: CanvasUpdate): void;
    RecalculateClipping(): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetVerticesDirty(): void;
    UpdateFontAsset(): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;


}
    
interface TextMeshProUGUIConstructor {


    new(): TextMeshProUGUI;



}
declare const TextMeshProUGUI: TextMeshProUGUIConstructor;
    
interface Animation extends Behaviour {
    clip: AnimationClip;
    playAutomatically: boolean;
    wrapMode: WrapMode;
    readonly isPlaying: boolean;
    readonly Item: AnimationState;
    animatePhysics: boolean;
    updateMode: AnimationUpdateMode;
    cullingType: AnimationCullingType;
    localBounds: Bounds;



    AddClip(clip: AnimationClip, newName: string): void;
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number): void;
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number, addLoopFrame: boolean): void;
    Blend(animation: string): void;
    Blend(animation: string, targetWeight: number): void;
    Blend(animation: string, targetWeight: number, fadeLength: number): void;
    CrossFade(animation: string): void;
    CrossFade(animation: string, fadeLength: number): void;
    CrossFade(animation: string, fadeLength: number, mode: PlayMode): void;
    CrossFadeQueued(animation: string): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode, mode: PlayMode): AnimationState;
    GetClip(name: string): AnimationClip;
    GetClipCount(): number;
    GetEnumerator(): unknown;
    IsPlaying(name: string): boolean;
    Play(): boolean;
    Play(mode: PlayMode): boolean;
    Play(animation: string): boolean;
    Play(animation: string, mode: PlayMode): boolean;
    PlayQueued(animation: string): AnimationState;
    PlayQueued(animation: string, queue: QueueMode): AnimationState;
    PlayQueued(animation: string, queue: QueueMode, mode: PlayMode): AnimationState;
    RemoveClip(clip: AnimationClip): void;
    RemoveClip(clipName: string): void;
    Rewind(): void;
    Rewind(name: string): void;
    Sample(): void;
    Stop(): void;
    Stop(name: string): void;
    SyncLayer(layer: number): void;


}
    
interface AnimationConstructor {


    new(): Animation;



}
declare const Animation: AnimationConstructor;
    
interface ClientSceneListener extends MonoBehaviour {
    IsGameSceneLoaded: boolean;
    SceneLoadPercent: number;

    readonly sceneLoadedEvent: MonoSignal<void>;
    readonly sceneLoadPercentChanged: MonoSignal<void>;




}
    
interface ClientSceneListenerConstructor {


    new(): ClientSceneListener;



}
declare const ClientSceneListener: ClientSceneListenerConstructor;
    
interface BundleLoadingScreen extends MonoBehaviour {
    showContinueButton: boolean;



    SetError(msg: string): void;
    SetProgress(text: string, percent: number): void;
    SetTotalDownloadSize(sizeBytes: number): void;


}
    
interface CoreLoadingScreen extends BundleLoadingScreen {
    progressText: TMP_Text;
    disconnectButton: Button;
    continueButton: Button;
    spinner: GameObject;
    gameImage: RawImage;
    editorGameImageColor: Color;
    voiceChatCard: RectTransform;
    voiceChatToggle: InternalToggle;
    updatedByGame: boolean;



    ClickContinueButton(): void;
    Close(): void;
    SetProgress(text: string, percent: number): void;
    SetTotalDownloadSize(sizeBytes: number): void;


}
    
interface RawImage extends MaskableGraphic {
    readonly mainTexture: Texture;
    texture: Texture;
    uvRect: Rect;



    SetNativeSize(): void;


}
    
interface InternalToggle extends MonoBehaviour {
    onValueChanged: unknown;
    bgImage: Image;
    handle: RectTransform;
    activeColor: Color;
    inactiveColor: Color;



    Button_OnClick(): void;
    SetValue(val: boolean): void;
    Start(): void;


}
    
interface InternalToggleConstructor {


    new(): InternalToggle;



}
declare const InternalToggle: InternalToggleConstructor;
    
interface CoreLoadingScreenConstructor {
    gameImageCache: CSDictionary<string, Texture2D>;


    new(): CoreLoadingScreen;



}
declare const CoreLoadingScreen: CoreLoadingScreenConstructor;
    
interface IDelayedField {
    readonly isDelayed: boolean;





}
    
interface IMixedValueSupport {
    showMixedValue: boolean;





}
    
interface INotifyValueChanged<T> {
    value: T;



    SetValueWithoutNotify(newValue: T): void;


}
    
interface IPrefixLabel {
    readonly label: string;
    readonly labelElement: Label;





}
    
interface ITextElement {
    text: string;





}
    
interface ITextEdition {
    isReadOnly: boolean;
    maxLength: number;
    placeholder: string;
    isDelayed: boolean;
    maskChar: string;
    isPassword: boolean;
    hidePlaceholderOnFocus: boolean;
    autoCorrection: boolean;
    hideMobileInput: boolean;
    readonly touchScreenKeyboard: TouchScreenKeyboard;
    keyboardType: TouchScreenKeyboardType;





}
    
interface TouchScreenKeyboard {
    text: string;
    active: boolean;
    readonly status: Status;
    characterLimit: number;
    readonly canGetSelection: boolean;
    readonly canSetSelection: boolean;
    selection: RangeInt;
    readonly type: TouchScreenKeyboardType;
    targetDisplay: number;





}
    
interface RangeInt {
    start: number;
    length: number;
    readonly end: number;





}
    
interface RangeIntConstructor {


    new(start: number, length: number): RangeInt;



}
declare const RangeInt: RangeIntConstructor;
    
interface TouchScreenKeyboardConstructor {
    readonly isSupported: boolean;
    readonly isInPlaceEditingAllowed: boolean;
    hideInput: boolean;
    readonly area: Rect;
    readonly visible: boolean;


    new(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, characterLimit: number): TouchScreenKeyboard;


    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, characterLimit: number): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType): TouchScreenKeyboard;
    Open(text: string): TouchScreenKeyboard;

}
declare const TouchScreenKeyboard: TouchScreenKeyboardConstructor;
    
interface IExperimentalFeatures {
    readonly animation: ITransitionAnimations;





}
    
interface ITransitionAnimations {



    Layout(to: Rect, durationMs: number): ValueAnimation<Rect>;
    Position(to: Vector3, duration: number): ValueAnimation<Vector3>;
    Rotation(to: Quaternion, duration: number): ValueAnimation<Quaternion>;
    Scale(to: number, duration: number): ValueAnimation<number>;
    Size(to: Vector2, durationMs: number): ValueAnimation<Vector2>;
    Start(from: number, to: number, durationMs: number, onValueChanged: unknown): ValueAnimation<number>;
    Start(from: Rect, to: Rect, durationMs: number, onValueChanged: unknown): ValueAnimation<Rect>;
    Start(from: Color, to: Color, durationMs: number, onValueChanged: unknown): ValueAnimation<Color>;
    Start(from: Vector3, to: Vector3, durationMs: number, onValueChanged: unknown): ValueAnimation<Vector3>;
    Start(from: Vector2, to: Vector2, durationMs: number, onValueChanged: unknown): ValueAnimation<Vector2>;
    Start(from: Quaternion, to: Quaternion, durationMs: number, onValueChanged: unknown): ValueAnimation<Quaternion>;
    Start(from: StyleValues, to: StyleValues, durationMs: number): ValueAnimation<StyleValues>;
    Start(to: StyleValues, durationMs: number): ValueAnimation<StyleValues>;
    Start(fromValueGetter: unknown, to: number, durationMs: number, onValueChanged: unknown): ValueAnimation<number>;
    Start(fromValueGetter: unknown, to: Rect, durationMs: number, onValueChanged: unknown): ValueAnimation<Rect>;
    Start(fromValueGetter: unknown, to: Color, durationMs: number, onValueChanged: unknown): ValueAnimation<Color>;
    Start(fromValueGetter: unknown, to: Vector3, durationMs: number, onValueChanged: unknown): ValueAnimation<Vector3>;
    Start(fromValueGetter: unknown, to: Vector2, durationMs: number, onValueChanged: unknown): ValueAnimation<Vector2>;
    Start(fromValueGetter: unknown, to: Quaternion, durationMs: number, onValueChanged: unknown): ValueAnimation<Quaternion>;
    TopLeft(to: Vector2, durationMs: number): ValueAnimation<Vector2>;


}
    
interface IValueAnimationUpdate {



    Tick(currentTimeMs: number): void;


}
    
interface IValueAnimation {
    readonly isRunning: boolean;
    durationMs: number;



    Recycle(): void;
    Start(): void;
    Stop(): void;


}
    
    
interface IStylePropertyAnimations {
    runningAnimationCount: number;
    completedAnimationCount: number;



    CancelAllAnimations(): void;
    CancelAnimation(id: StylePropertyId): void;
    GetAllAnimations(outPropertyIds: CSArray<StylePropertyId>): void;
    HasRunningAnimation(id: StylePropertyId): boolean;
    Start(id: StylePropertyId, from: number, to: number, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: number, to: number, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Length, to: Length, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Color, to: Color, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Background, to: Background, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: FontDefinition, to: FontDefinition, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Font, to: Font, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: TextShadow, to: TextShadow, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Scale, to: Scale, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Translate, to: Translate, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Rotate, to: Rotate, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: TransformOrigin, to: TransformOrigin, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: BackgroundPosition, to: BackgroundPosition, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: BackgroundRepeat, to: BackgroundRepeat, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: BackgroundSize, to: BackgroundSize, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    StartEnum(id: StylePropertyId, from: number, to: number, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    UpdateAnimation(id: StylePropertyId): void;


}
    
interface Length {
    value: number;
    unit: LengthUnit;



    Equals(other: Length): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    IsAuto(): boolean;
    IsNone(): boolean;
    ToString(): string;


}
    
interface LengthConstructor {


    new(value: number): Length;
    new(value: number, unit: LengthUnit): Length;


    Auto(): Length;
    None(): Length;
    Percent(value: number): Length;

}
declare const Length: LengthConstructor;
    
interface Background {
    texture: Texture2D;
    sprite: Sprite;
    renderTexture: RenderTexture;
    vectorImage: VectorImage;



    Equals(other: Background): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetSelectedImage(): Object;
    IsEmpty(): boolean;
    ToString(): string;


}
    
interface VectorImage extends ScriptableObject {
    readonly width: number;
    readonly height: number;





}
    
interface VectorImageConstructor {


    new(): VectorImage;



}
declare const VectorImage: VectorImageConstructor;
    
interface BackgroundConstructor {


    new(t: Texture2D): Background;


    FromRenderTexture(rt: RenderTexture): Background;
    FromSprite(s: Sprite): Background;
    FromTexture2D(t: Texture2D): Background;
    FromVectorImage(vi: VectorImage): Background;

}
declare const Background: BackgroundConstructor;
    
interface FontDefinition {
    font: Font;
    fontAsset: FontAsset;



    Equals(other: FontDefinition): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface TextAsset extends ScriptableObject {
    readonly version: string;
    readonly instanceID: number;
    hashCode: number;
    material: Material;
    materialHashCode: number;





}
    
interface FontAsset extends TextAsset {
    fontAssetCreationEditorSettings: FontAssetCreationEditorSettings;
    readonly sourceFontFile: Font;
    atlasPopulationMode: AtlasPopulationMode;
    faceInfo: FaceInfo;
    readonly glyphTable: CSArray<Glyph>;
    readonly glyphLookupTable: CSDictionary<number, Glyph>;
    readonly characterTable: CSArray<Character>;
    readonly characterLookupTable: CSDictionary<number, Character>;
    readonly atlasTexture: Texture2D;
    atlasTextures: CSArray<Texture2D>;
    readonly atlasTextureCount: number;
    isMultiAtlasTexturesEnabled: boolean;
    getFontFeatures: boolean;
    readonly atlasWidth: number;
    readonly atlasHeight: number;
    readonly atlasPadding: number;
    readonly atlasRenderMode: GlyphRenderMode;
    readonly fontFeatureTable: FontFeatureTable;
    fallbackFontAssetTable: CSArray<FontAsset>;
    readonly fontWeightTable: CSArray<FontWeightPair>;
    regularStyleWeight: number;
    regularStyleSpacing: number;
    boldStyleWeight: number;
    boldStyleSpacing: number;
    italicStyleSlant: number;
    tabMultiple: number;



    ClearFontAssetData(setAtlasSizeToZero: boolean): void;
    HasCharacter(character: number): boolean;
    HasCharacter(character: string, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacter(character: number, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<string>): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<number>, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string): boolean;
    ReadFontAssetDefinition(): void;
    TryAddCharacters(unicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(unicodes: CSArray<number>, missingUnicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, missingCharacters: CSArray<string>, includeFontFeatures: boolean): boolean;


}
    
interface FontAssetCreationEditorSettings {
    sourceFontFileGUID: string;
    faceIndex: number;
    pointSizeSamplingMode: number;
    pointSize: number;
    padding: number;
    paddingMode: number;
    packingMode: number;
    atlasWidth: number;
    atlasHeight: number;
    characterSetSelectionMode: number;
    characterSequence: string;
    referencedFontAssetGUID: string;
    referencedTextAssetGUID: string;
    fontStyle: number;
    fontStyleModifier: number;
    renderMode: number;
    includeFontFeatures: boolean;





}
    
interface TextElement {
    readonly elementType: TextElementType;
    unicode: number;
    textAsset: TextAsset;
    glyph: Glyph;
    glyphIndex: number;
    scale: number;





}
    
    
    
interface FontFeatureTable {



    SortGlyphPairAdjustmentRecords(): void;
    SortMarkToBaseAdjustmentRecords(): void;
    SortMarkToMarkAdjustmentRecords(): void;


}
    
interface FontWeightPair {
    regularTypeface: FontAsset;
    italicTypeface: FontAsset;





}
    
interface FontAssetConstructor {


    new(): FontAsset;


    CreateFontAsset(familyName: string, styleName: string, pointSize: number): FontAsset;
    CreateFontAsset(fontFilePath: string, faceIndex: number, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number): FontAsset;
    CreateFontAsset(font: Font): FontAsset;
    CreateFontAsset(font: Font, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number, atlasPopulationMode: AtlasPopulationMode, enableMultiAtlasSupport: boolean): FontAsset;
    GetCharacters(fontAsset: FontAsset): string;
    GetCharactersArray(fontAsset: FontAsset): CSArray<number>;

}
declare const FontAsset: FontAssetConstructor;
    
interface FontDefinitionConstructor {




    FromFont(f: Font): FontDefinition;
    FromSDFFont(f: FontAsset): FontDefinition;

}
declare const FontDefinition: FontDefinitionConstructor;
    
interface TextShadow {
    offset: Vector2;
    blurRadius: number;
    color: Color;



    Equals(obj: unknown): boolean;
    Equals(other: TextShadow): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface Scale {
    value: Vector3;



    Equals(other: Scale): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface ScaleConstructor {


    new(scale: Vector2): Scale;
    new(scale: Vector3): Scale;


    None(): Scale;

}
declare const Scale: ScaleConstructor;
    
interface Translate {
    x: Length;
    y: Length;
    z: number;



    Equals(other: Translate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface TranslateConstructor {


    new(x: Length, y: Length, z: number): Translate;
    new(x: Length, y: Length): Translate;


    None(): Translate;

}
declare const Translate: TranslateConstructor;
    
interface Rotate {
    angle: Angle;



    Equals(other: Rotate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface Angle {
    value: number;
    unit: AngleUnit;



    Equals(other: Angle): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToDegrees(): number;
    ToGradians(): number;
    ToRadians(): number;
    ToString(): string;
    ToTurns(): number;


}
    
interface AngleConstructor {


    new(value: number): Angle;
    new(value: number, unit: AngleUnit): Angle;


    Degrees(value: number): Angle;
    Gradians(value: number): Angle;
    Radians(value: number): Angle;
    Turns(value: number): Angle;

}
declare const Angle: AngleConstructor;
    
interface RotateConstructor {


    new(angle: Angle): Rotate;


    None(): Rotate;

}
declare const Rotate: RotateConstructor;
    
interface TransformOrigin {
    x: Length;
    y: Length;
    z: number;



    Equals(other: TransformOrigin): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface TransformOriginConstructor {


    new(x: Length, y: Length, z: number): TransformOrigin;
    new(x: Length, y: Length): TransformOrigin;


    Initial(): TransformOrigin;

}
declare const TransformOrigin: TransformOriginConstructor;
    
interface BackgroundPosition {
    keyword: BackgroundPositionKeyword;
    offset: Length;



    Equals(obj: unknown): boolean;
    Equals(other: BackgroundPosition): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface BackgroundPositionConstructor {


    new(keyword: BackgroundPositionKeyword): BackgroundPosition;
    new(keyword: BackgroundPositionKeyword, offset: Length): BackgroundPosition;



}
declare const BackgroundPosition: BackgroundPositionConstructor;
    
interface BackgroundRepeat {
    x: Repeat;
    y: Repeat;



    Equals(obj: unknown): boolean;
    Equals(other: BackgroundRepeat): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface BackgroundRepeatConstructor {


    new(repeatX: Repeat, repeatY: Repeat): BackgroundRepeat;



}
declare const BackgroundRepeat: BackgroundRepeatConstructor;
    
interface BackgroundSize {
    sizeType: BackgroundSizeType;
    x: Length;
    y: Length;



    Equals(obj: unknown): boolean;
    Equals(other: BackgroundSize): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface BackgroundSizeConstructor {


    new(sizeX: Length, sizeY: Length): BackgroundSize;
    new(sizeType: BackgroundSizeType): BackgroundSize;



}
declare const BackgroundSize: BackgroundSizeConstructor;
    
interface IVisualElementScheduler {



    Execute(timerUpdateEvent: unknown): IVisualElementScheduledItem;
    Execute(updateEvent: unknown): IVisualElementScheduledItem;


}
    
interface IVisualElementScheduledItem {
    readonly element: VisualElement;
    readonly isActive: boolean;



    Every(intervalMs: number): IVisualElementScheduledItem;
    ExecuteLater(delayMs: number): void;
    ForDuration(durationMs: number): IVisualElementScheduledItem;
    Pause(): void;
    Resume(): void;
    StartingIn(delayMs: number): IVisualElementScheduledItem;
    Until(stopCondition: unknown): IVisualElementScheduledItem;


}
    
interface IResolvedStyle {
    readonly alignContent: Align;
    readonly alignItems: Align;
    readonly alignSelf: Align;
    readonly backgroundColor: Color;
    readonly backgroundImage: Background;
    readonly backgroundPositionX: BackgroundPosition;
    readonly backgroundPositionY: BackgroundPosition;
    readonly backgroundRepeat: BackgroundRepeat;
    readonly backgroundSize: BackgroundSize;
    readonly borderBottomColor: Color;
    readonly borderBottomLeftRadius: number;
    readonly borderBottomRightRadius: number;
    readonly borderBottomWidth: number;
    readonly borderLeftColor: Color;
    readonly borderLeftWidth: number;
    readonly borderRightColor: Color;
    readonly borderRightWidth: number;
    readonly borderTopColor: Color;
    readonly borderTopLeftRadius: number;
    readonly borderTopRightRadius: number;
    readonly borderTopWidth: number;
    readonly bottom: number;
    readonly color: Color;
    readonly display: DisplayStyle;
    readonly flexBasis: StyleFloat;
    readonly flexDirection: FlexDirection;
    readonly flexGrow: number;
    readonly flexShrink: number;
    readonly flexWrap: Wrap;
    readonly fontSize: number;
    readonly height: number;
    readonly justifyContent: Justify;
    readonly left: number;
    readonly letterSpacing: number;
    readonly marginBottom: number;
    readonly marginLeft: number;
    readonly marginRight: number;
    readonly marginTop: number;
    readonly maxHeight: StyleFloat;
    readonly maxWidth: StyleFloat;
    readonly minHeight: StyleFloat;
    readonly minWidth: StyleFloat;
    readonly opacity: number;
    readonly paddingBottom: number;
    readonly paddingLeft: number;
    readonly paddingRight: number;
    readonly paddingTop: number;
    readonly position: Position;
    readonly right: number;
    readonly rotate: Rotate;
    readonly scale: Scale;
    readonly textOverflow: TextOverflow;
    readonly top: number;
    readonly transformOrigin: Vector3;
    readonly transitionDelay: CSArray<TimeValue>;
    readonly transitionDuration: CSArray<TimeValue>;
    readonly transitionProperty: CSArray<StylePropertyName>;
    readonly transitionTimingFunction: CSArray<EasingFunction>;
    readonly translate: Vector3;
    readonly unityBackgroundImageTintColor: Color;
    readonly unityFont: Font;
    readonly unityFontDefinition: FontDefinition;
    readonly unityFontStyleAndWeight: FontStyle;
    readonly unityParagraphSpacing: number;
    readonly unitySliceBottom: number;
    readonly unitySliceLeft: number;
    readonly unitySliceRight: number;
    readonly unitySliceScale: number;
    readonly unitySliceTop: number;
    readonly unityTextAlign: TextAnchor;
    readonly unityTextOutlineColor: Color;
    readonly unityTextOutlineWidth: number;
    readonly unityTextOverflowPosition: TextOverflowPosition;
    readonly visibility: Visibility;
    readonly whiteSpace: WhiteSpace;
    readonly width: number;
    readonly wordSpacing: number;





}
    
interface IStyleValue<T> {
    value: T;
    keyword: StyleKeyword;





}
    
interface StyleFloat extends IStyleValue<number> {
    value: number;
    keyword: StyleKeyword;



    Equals(other: StyleFloat): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleFloatConstructor {


    new(v: number): StyleFloat;
    new(keyword: StyleKeyword): StyleFloat;



}
declare const StyleFloat: StyleFloatConstructor;
    
interface TimeValue {
    value: number;
    unit: TimeUnit;



    Equals(other: TimeValue): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface TimeValueConstructor {


    new(value: number): TimeValue;
    new(value: number, unit: TimeUnit): TimeValue;



}
declare const TimeValue: TimeValueConstructor;
    
interface StylePropertyName {



    Equals(other: unknown): boolean;
    Equals(other: StylePropertyName): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StylePropertyNameConstructor {


    new(name: string): StylePropertyName;


    IsNullOrEmpty(propertyName: StylePropertyName): boolean;

}
declare const StylePropertyName: StylePropertyNameConstructor;
    
interface EasingFunction {
    mode: EasingMode;



    Equals(other: EasingFunction): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface EasingFunctionConstructor {


    new(mode: EasingMode): EasingFunction;



}
declare const EasingFunction: EasingFunctionConstructor;
    
interface ITransform {
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    readonly matrix: Matrix4x4;





}
    
interface IEventHandler {



    HandleEvent(evt: EventBase): void;
    HasBubbleUpHandlers(): boolean;
    HasTrickleDownHandlers(): boolean;
    SendEvent(e: EventBase): void;


}
    
interface EventBase {
    readonly eventTypeId: number;
    readonly timestamp: number;
    readonly bubbles: boolean;
    readonly tricklesDown: boolean;
    target: IEventHandler;
    readonly isPropagationStopped: boolean;
    readonly isImmediatePropagationStopped: boolean;
    readonly propagationPhase: PropagationPhase;
    readonly currentTarget: IEventHandler;
    readonly dispatch: boolean;
    readonly imguiEvent: Event;
    readonly originalMousePosition: Vector2;



    Dispose(): void;
    StopImmediatePropagation(): void;
    StopPropagation(): void;


}
    
interface Event {
    readonly rawType: EventType;
    mousePosition: Vector2;
    delta: Vector2;
    pointerType: PointerType;
    button: number;
    modifiers: EventModifiers;
    pressure: number;
    twist: number;
    tilt: Vector2;
    penStatus: PenStatus;
    clickCount: number;
    character: string;
    keyCode: KeyCode;
    displayIndex: number;
    type: EventType;
    commandName: string;
    shift: boolean;
    control: boolean;
    alt: boolean;
    command: boolean;
    capsLock: boolean;
    numeric: boolean;
    readonly functionKey: boolean;
    readonly isKey: boolean;
    readonly isMouse: boolean;
    readonly isScrollWheel: boolean;



    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetTypeForControl(controlID: number): EventType;
    ToString(): string;
    Use(): void;


}
    
interface EventConstructor {
    current: Event;


    new(): Event;
    new(displayIndex: number): Event;
    new(other: Event): Event;


    GetEventCount(): number;
    KeyboardEvent(key: string): Event;
    PopEvent(outEvent: Event): boolean;

}
declare const Event: EventConstructor;
    
interface CallbackEventHandler extends IEventHandler {



    HasBubbleUpHandlers(): boolean;
    HasTrickleDownHandlers(): boolean;
    RegisterCallback<TEventType>(callback: EventCallback<TEventType>, useTrickleDown: TrickleDown): void;
    RegisterCallback<TEventType, TUserArgsType>(callback: EventCallback<TEventType, TUserArgsType>, userArgs: TUserArgsType, useTrickleDown: TrickleDown): void;
    RegisterCallbackOnce<TEventType>(callback: EventCallback<TEventType>, useTrickleDown: TrickleDown): void;
    RegisterCallbackOnce<TEventType, TUserArgsType>(callback: EventCallback<TEventType, TUserArgsType>, userArgs: TUserArgsType, useTrickleDown: TrickleDown): void;
    SendEvent(e: EventBase): void;
    UnregisterCallback<TEventType>(callback: EventCallback<TEventType>, useTrickleDown: TrickleDown): void;
    UnregisterCallback<TEventType, TUserArgsType>(callback: EventCallback<TEventType, TUserArgsType>, useTrickleDown: TrickleDown): void;


}
    
interface EventCallback<TEventType> {



    BeginInvoke(evt: TEventType, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(evt: TEventType): void;


}
    
interface EventCallbackConstructor {


    new(object: unknown, method: unknown): EventCallback<TEventType>;



}
declare const EventCallback: EventCallbackConstructor;
    
interface EventCallback<TEventType, TCallbackArgs> {



    BeginInvoke(evt: TEventType, userArgs: TCallbackArgs, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(evt: TEventType, userArgs: TCallbackArgs): void;


}
    
interface EventCallbackConstructor {


    new(object: unknown, method: unknown): EventCallback<TEventType, TCallbackArgs>;



}
declare const EventCallback: EventCallbackConstructor;
    
interface Focusable extends CallbackEventHandler {
    readonly focusController: FocusController;
    focusable: boolean;
    tabIndex: number;
    delegatesFocus: boolean;
    readonly canGrabFocus: boolean;



    Blur(): void;
    Focus(): void;


}
    
interface FocusController {
    readonly focusedElement: Focusable;



    IgnoreEvent(evt: EventBase): void;


}
    
interface FocusControllerConstructor {


    new(focusRing: IFocusRing): FocusController;



}
declare const FocusController: FocusControllerConstructor;
    
    
interface PropertyPath {
    readonly Length: number;
    readonly IsEmpty: boolean;
    readonly Item: PropertyPathPart;



    Equals(other: PropertyPath): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface PropertyPathPart {
    readonly IsName: boolean;
    readonly IsIndex: boolean;
    readonly IsKey: boolean;
    readonly Kind: PropertyPathPartKind;
    readonly Name: string;
    readonly Index: number;
    readonly Key: unknown;



    Equals(other: PropertyPathPart): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface PropertyPathPartConstructor {


    new(name: string): PropertyPathPart;
    new(index: number): PropertyPathPart;
    new(key: unknown): PropertyPathPart;



}
declare const PropertyPathPart: PropertyPathPartConstructor;
    
interface IProperty {
    readonly Name: string;
    readonly IsReadOnly: boolean;



    DeclaredValueType(): unknown;
    GetAttribute<TAttribute>(): TAttribute;
    GetAttributes<TAttribute>(): CSArray<TAttribute>;
    GetAttributes(): CSArray<unknown>;
    HasAttribute<TAttribute>(): boolean;


}
    
interface PropertyPathConstructor {


    new(path: string): PropertyPath;


    AppendIndex(path: unknown, index: number): PropertyPath;
    AppendKey(path: unknown, key: unknown): PropertyPath;
    AppendName(path: unknown, name: string): PropertyPath;
    AppendPart(path: unknown, part: unknown): PropertyPath;
    AppendProperty(path: unknown, property: IProperty): PropertyPath;
    Combine(path: unknown, pathToAppend: unknown): PropertyPath;
    Combine(path: unknown, pathToAppend: string): PropertyPath;
    FromIndex(index: number): PropertyPath;
    FromKey(key: unknown): PropertyPath;
    FromName(name: string): PropertyPath;
    FromPart(part: unknown): PropertyPath;
    Pop(path: unknown): PropertyPath;
    SubPath(path: unknown, startIndex: number): PropertyPath;
    SubPath(path: unknown, startIndex: number, length: number): PropertyPath;

}
declare const PropertyPath: PropertyPathConstructor;
    
interface Hierarchy {
    readonly parent: VisualElement;
    readonly childCount: number;
    readonly Item: VisualElement;



    Add(child: VisualElement): void;
    Children(): CSArray<VisualElement>;
    Clear(): void;
    ElementAt(index: number): VisualElement;
    Equals(other: Hierarchy): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    IndexOf(element: VisualElement): number;
    Insert(index: number, child: VisualElement): void;
    Remove(child: VisualElement): void;
    RemoveAt(index: number): void;
    Sort(comp: unknown): void;


}
    
interface IPanel {
    readonly visualTree: VisualElement;
    readonly dispatcher: EventDispatcher;
    readonly contextType: ContextType;
    readonly focusController: FocusController;
    readonly contextualMenuManager: ContextualMenuManager;
    readonly isDirty: boolean;



    Pick(point: Vector2): VisualElement;
    PickAll(point: Vector2, picked: CSArray<VisualElement>): VisualElement;


}
    
interface EventDispatcher {





}
    
interface ContextualMenuManager {



    DisplayMenu(triggerEvent: EventBase, target: IEventHandler): void;
    DisplayMenuIfEventMatches(evt: EventBase, eventHandler: IEventHandler): void;


}
    
interface VisualTreeAsset extends ScriptableObject {
    readonly importedWithErrors: boolean;
    readonly importedWithWarnings: boolean;
    readonly templateDependencies: CSArray<VisualTreeAsset>;
    readonly stylesheets: CSArray<StyleSheet>;
    contentHash: number;



    CloneTree(): TemplateContainer;
    CloneTree(bindingPath: string): TemplateContainer;
    CloneTree(target: VisualElement): void;
    CloneTree(target: VisualElement, firstElementIndex: unknown, elementAddedCount: unknown): void;
    Instantiate(): TemplateContainer;
    Instantiate(bindingPath: string): TemplateContainer;


}
    
interface StyleSheet extends ScriptableObject {
    readonly importedWithErrors: boolean;
    readonly importedWithWarnings: boolean;
    contentHash: number;





}
    
interface StyleSheetConstructor {


    new(): StyleSheet;



}
declare const StyleSheet: StyleSheetConstructor;
    
interface IBindable {
    binding: IBinding;
    bindingPath: string;





}
    
interface IBinding {



    PreUpdate(): void;
    Release(): void;
    Update(): void;


}
    
interface BindableElement extends VisualElement, IBindable {
    binding: IBinding;
    bindingPath: string;





}
    
interface BindableElementConstructor {


    new(): BindableElement;



}
declare const BindableElement: BindableElementConstructor;
    
interface TemplateContainer extends BindableElement {
    readonly templateId: string;
    readonly templateSource: VisualTreeAsset;
    readonly contentContainer: VisualElement;





}
    
interface TemplateContainerConstructor {


    new(): TemplateContainer;
    new(templateId: string): TemplateContainer;



}
declare const TemplateContainer: TemplateContainerConstructor;
    
interface VisualTreeAssetConstructor {


    new(): VisualTreeAsset;



}
declare const VisualTreeAsset: VisualTreeAssetConstructor;
    
    
interface StyleEnum<T> extends IStyleValue<T> {
    value: T;
    keyword: StyleKeyword;



    Equals(other: StyleEnum<T>): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleEnumConstructor {


    new(v: T): StyleEnum<T>;
    new(keyword: StyleKeyword): StyleEnum<T>;



}
declare const StyleEnum: StyleEnumConstructor;
    
interface StyleColor extends IStyleValue<Color> {
    value: Color;
    keyword: StyleKeyword;



    Equals(other: StyleColor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleColorConstructor {


    new(v: Color): StyleColor;
    new(keyword: StyleKeyword): StyleColor;



}
declare const StyleColor: StyleColorConstructor;
    
interface StyleBackground extends IStyleValue<Background> {
    value: Background;
    keyword: StyleKeyword;



    Equals(other: StyleBackground): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleBackgroundConstructor {


    new(v: Background): StyleBackground;
    new(v: Texture2D): StyleBackground;
    new(v: Sprite): StyleBackground;
    new(v: VectorImage): StyleBackground;
    new(keyword: StyleKeyword): StyleBackground;



}
declare const StyleBackground: StyleBackgroundConstructor;
    
interface StyleBackgroundPosition extends IStyleValue<BackgroundPosition> {
    value: BackgroundPosition;
    keyword: StyleKeyword;



    Equals(other: StyleBackgroundPosition): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleBackgroundPositionConstructor {


    new(v: BackgroundPosition): StyleBackgroundPosition;
    new(keyword: StyleKeyword): StyleBackgroundPosition;



}
declare const StyleBackgroundPosition: StyleBackgroundPositionConstructor;
    
interface StyleBackgroundRepeat extends IStyleValue<BackgroundRepeat> {
    value: BackgroundRepeat;
    keyword: StyleKeyword;



    Equals(other: StyleBackgroundRepeat): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleBackgroundRepeatConstructor {


    new(v: BackgroundRepeat): StyleBackgroundRepeat;
    new(keyword: StyleKeyword): StyleBackgroundRepeat;



}
declare const StyleBackgroundRepeat: StyleBackgroundRepeatConstructor;
    
interface StyleBackgroundSize extends IStyleValue<BackgroundSize> {
    value: BackgroundSize;
    keyword: StyleKeyword;



    Equals(other: StyleBackgroundSize): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleBackgroundSizeConstructor {


    new(v: BackgroundSize): StyleBackgroundSize;
    new(keyword: StyleKeyword): StyleBackgroundSize;



}
declare const StyleBackgroundSize: StyleBackgroundSizeConstructor;
    
interface StyleLength extends IStyleValue<Length> {
    value: Length;
    keyword: StyleKeyword;



    Equals(other: StyleLength): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleLengthConstructor {


    new(v: number): StyleLength;
    new(v: Length): StyleLength;
    new(keyword: StyleKeyword): StyleLength;



}
declare const StyleLength: StyleLengthConstructor;
    
interface Cursor {
    texture: Texture2D;
    hotspot: Vector2;



    Equals(obj: unknown): boolean;
    Equals(other: Cursor): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleCursor extends IStyleValue<Cursor> {
    value: Cursor;
    keyword: StyleKeyword;



    Equals(other: StyleCursor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleCursorConstructor {


    new(v: Cursor): StyleCursor;
    new(keyword: StyleKeyword): StyleCursor;



}
declare const StyleCursor: StyleCursorConstructor;
    
interface StyleRotate extends IStyleValue<Rotate> {
    value: Rotate;
    keyword: StyleKeyword;



    Equals(other: StyleRotate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleRotateConstructor {


    new(v: Rotate): StyleRotate;
    new(keyword: StyleKeyword): StyleRotate;



}
declare const StyleRotate: StyleRotateConstructor;
    
interface StyleScale extends IStyleValue<Scale> {
    value: Scale;
    keyword: StyleKeyword;



    Equals(other: StyleScale): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleScaleConstructor {


    new(v: Scale): StyleScale;
    new(keyword: StyleKeyword): StyleScale;
    new(scale: Vector2): StyleScale;



}
declare const StyleScale: StyleScaleConstructor;
    
interface StyleTextShadow extends IStyleValue<TextShadow> {
    value: TextShadow;
    keyword: StyleKeyword;



    Equals(other: StyleTextShadow): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleTextShadowConstructor {


    new(v: TextShadow): StyleTextShadow;
    new(keyword: StyleKeyword): StyleTextShadow;



}
declare const StyleTextShadow: StyleTextShadowConstructor;
    
interface StyleTransformOrigin extends IStyleValue<TransformOrigin> {
    value: TransformOrigin;
    keyword: StyleKeyword;



    Equals(other: StyleTransformOrigin): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleTransformOriginConstructor {


    new(v: TransformOrigin): StyleTransformOrigin;
    new(keyword: StyleKeyword): StyleTransformOrigin;



}
declare const StyleTransformOrigin: StyleTransformOriginConstructor;
    
interface StyleList<T> extends IStyleValue<CSArray<T>> {
    value: CSArray<T>;
    keyword: StyleKeyword;



    Equals(other: StyleList<T>): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleListConstructor {


    new(v: CSArray<T>): StyleList<T>;
    new(keyword: StyleKeyword): StyleList<T>;



}
declare const StyleList: StyleListConstructor;
    
interface StyleTranslate extends IStyleValue<Translate> {
    value: Translate;
    keyword: StyleKeyword;



    Equals(other: StyleTranslate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleTranslateConstructor {


    new(v: Translate): StyleTranslate;
    new(keyword: StyleKeyword): StyleTranslate;



}
declare const StyleTranslate: StyleTranslateConstructor;
    
interface StyleFont extends IStyleValue<Font> {
    value: Font;
    keyword: StyleKeyword;



    Equals(other: StyleFont): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleFontConstructor {


    new(v: Font): StyleFont;
    new(keyword: StyleKeyword): StyleFont;



}
declare const StyleFont: StyleFontConstructor;
    
interface StyleFontDefinition extends IStyleValue<FontDefinition> {
    value: FontDefinition;
    keyword: StyleKeyword;



    Equals(other: StyleFontDefinition): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;


}
    
interface StyleFontDefinitionConstructor {


    new(f: FontDefinition): StyleFontDefinition;
    new(f: FontAsset): StyleFontDefinition;
    new(f: Font): StyleFontDefinition;
    new(keyword: StyleKeyword): StyleFontDefinition;



}
declare const StyleFontDefinition: StyleFontDefinitionConstructor;
    
interface StyleInt extends IStyleValue<number> {
    value: number;
    keyword: StyleKeyword;



    Equals(other: StyleInt): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StyleIntConstructor {


    new(v: number): StyleInt;
    new(keyword: StyleKeyword): StyleInt;



}
declare const StyleInt: StyleIntConstructor;
    
interface ICustomStyle {



    TryGetValue(property: CustomStyleProperty<number>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<number>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<boolean>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<Color>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<Texture2D>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<Sprite>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<VectorImage>, value: unknown): boolean;
    TryGetValue<T>(property: CustomStyleProperty<T>, value: unknown): boolean;
    TryGetValue(property: CustomStyleProperty<string>, value: CSArray<string>): boolean;


}
    
interface CustomStyleProperty<T> {
    readonly name: string;



    Equals(obj: unknown): boolean;
    Equals(other: CustomStyleProperty<T>): boolean;
    GetHashCode(): number;


}
    
interface CustomStylePropertyConstructor {


    new(propertyName: string): CustomStyleProperty<T>;



}
declare const CustomStyleProperty: CustomStylePropertyConstructor;
    
interface VisualElementStyleSheetSet {
    readonly count: number;
    readonly Item: StyleSheet;



    Add(styleSheet: StyleSheet): void;
    Clear(): void;
    Contains(styleSheet: StyleSheet): boolean;
    Equals(other: VisualElementStyleSheetSet): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    Remove(styleSheet: StyleSheet): boolean;


}
    
interface BindingId {



    Equals(other: BindingId): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface BindingIdConstructor {
    readonly Invalid: BindingId;


    new(path: string): BindingId;
    new(path: unknown): BindingId;



}
declare const BindingId: BindingIdConstructor;
    
interface Binding {
    readonly isDirty: boolean;
    updateTrigger: BindingUpdateTrigger;



    MarkDirty(): void;


}
    
interface BindingConstructor {




    ResetPanelLogLevel(panel: IPanel): void;
    SetGlobalLogLevel(logLevel: BindingLogLevel): void;
    SetPanelLogLevel(panel: IPanel, logLevel: BindingLogLevel): void;

}
declare const Binding: BindingConstructor;
    
interface BindingInfo {
    readonly targetElement: VisualElement;
    readonly bindingId: BindingId;
    readonly binding: Binding;





}
    
interface DataSourceContext {
    readonly dataSource: unknown;
    readonly dataSourcePath: PropertyPath;





}
    
interface DataSourceContextConstructor {


    new(dataSource: unknown, dataSourcePath: unknown): DataSourceContext;



}
declare const DataSourceContext: DataSourceContextConstructor;
    
    
    
    
    
interface StyleValues {
    top: number;
    left: number;
    width: number;
    height: number;
    right: number;
    bottom: number;
    color: Color;
    backgroundColor: Color;
    unityBackgroundImageTintColor: Color;
    borderColor: Color;
    marginLeft: number;
    marginTop: number;
    marginRight: number;
    marginBottom: number;
    paddingLeft: number;
    paddingTop: number;
    paddingRight: number;
    paddingBottom: number;
    borderLeftWidth: number;
    borderRightWidth: number;
    borderTopWidth: number;
    borderBottomWidth: number;
    borderTopLeftRadius: number;
    borderTopRightRadius: number;
    borderBottomLeftRadius: number;
    borderBottomRightRadius: number;
    opacity: number;
    flexGrow: number;
    flexShrink: number;





}
    
interface ITextElementExperimentalFeatures extends IExperimentalFeatures {



    SetRenderedText(renderedText: string): void;


}
    
interface ITextSelection {
    isSelectable: boolean;
    cursorColor: Color;
    selectionColor: Color;
    cursorIndex: number;
    doubleClickSelectsWord: boolean;
    selectIndex: number;
    tripleClickSelectsLine: boolean;
    selectAllOnFocus: boolean;
    selectAllOnMouseUp: boolean;
    readonly cursorPosition: Vector2;



    HasSelection(): boolean;
    SelectAll(): void;
    SelectNone(): void;
    SelectRange(cursorIndex: number, selectionIndex: number): void;


}
    
interface TextElement extends BindableElement, INotifyValueChanged<string>, ITextElement, ITextEdition, ITextElementExperimentalFeatures, ITextSelection {
    text: string;
    enableRichText: boolean;
    emojiFallbackSupport: boolean;
    parseEscapeSequences: boolean;
    displayTooltipWhenElided: boolean;
    readonly isElided: boolean;
    readonly experimental: ITextElementExperimentalFeatures;
    readonly selection: ITextSelection;



    MeasureTextSize(textToMeasure: string, width: number, widthMode: MeasureMode, height: number, heightMode: MeasureMode): Vector2;


}
    
interface TextElementConstructor {
    readonly ussClassName: string;
    readonly selectableUssClassName: string;


    new(): TextElement;



}
declare const TextElement: TextElementConstructor;
    
interface Label extends TextElement {





}
    
interface LabelConstructor {
    readonly ussClassName: string;


    new(): Label;
    new(text: string): Label;



}
declare const Label: LabelConstructor;
    
interface IEditableElement {





}
    
interface BaseField<TValueType> extends BindableElement, IMixedValueSupport, INotifyValueChanged<TValueType>, IPrefixLabel, IEditableElement {
    value: TValueType;
    readonly labelElement: Label;
    label: string;
    showMixedValue: boolean;



    SetValueWithoutNotify(newValue: TValueType): void;


}
    
interface BaseFieldConstructor {
    readonly ussClassName: string;
    readonly labelUssClassName: string;
    readonly inputUssClassName: string;
    readonly noLabelVariantUssClassName: string;
    readonly labelDraggerVariantUssClassName: string;
    readonly mixedValueLabelUssClassName: string;
    readonly alignedFieldUssClassName: string;





}
declare const BaseField: BaseFieldConstructor;
    
interface TextInputBaseField<TValueType> extends BaseField<TValueType>, IDelayedField {
    readonly textSelection: ITextSelection;
    readonly textEdition: ITextEdition;
    isReadOnly: boolean;
    isPasswordField: boolean;
    autoCorrection: boolean;
    hideMobileInput: boolean;
    keyboardType: TouchScreenKeyboardType;
    readonly touchScreenKeyboard: TouchScreenKeyboard;
    maxLength: number;
    isDelayed: boolean;
    maskChar: string;
    readonly selectionColor: Color;
    readonly cursorColor: Color;
    cursorIndex: number;
    readonly cursorPosition: Vector2;
    selectIndex: number;
    selectAllOnFocus: boolean;
    selectAllOnMouseUp: boolean;
    doubleClickSelectsWord: boolean;
    tripleClickSelectsLine: boolean;
    readonly text: string;
    emojiFallbackSupport: boolean;
    verticalScrollerVisibility: ScrollerVisibility;



    MeasureTextSize(textToMeasure: string, width: number, widthMode: MeasureMode, height: number, heightMode: MeasureMode): Vector2;
    SelectAll(): void;
    SelectNone(): void;
    SelectRange(cursorIndex: number, selectionIndex: number): void;


}
    
interface TextInputBaseFieldConstructor {
    readonly ussClassName: string;
    readonly labelUssClassName: string;
    readonly inputUssClassName: string;
    readonly singleLineInputUssClassName: string;
    readonly multilineInputUssClassName: string;
    readonly placeholderUssClassName: string;
    readonly textInputUssName: string;





}
declare const TextInputBaseField: TextInputBaseFieldConstructor;
    
interface TextField extends TextInputBaseField<string> {
    multiline: boolean;
    value: string;



    SetValueWithoutNotify(newValue: string): void;


}
    
interface TextFieldConstructor {
    readonly ussClassName: string;
    readonly labelUssClassName: string;
    readonly inputUssClassName: string;


    new(): TextField;
    new(maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;
    new(label: string): TextField;
    new(label: string, maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;



}
declare const TextField: TextFieldConstructor;
    
interface GameConfig extends ScriptableObject {
    gameId: string;
    startingScene: SceneAsset;
    gameScenes: CSArray<Object>;
    packages: CSArray<AirshipPackageDocument>;
    tags: CSArray<string>;
    gameLayers: CSArray<string>;
    gameTags: CSArray<string>;
    physicsMatrix: CSArray<boolean>;
    gravity: Vector3;
    bounceThreshold: number;
    defaultMaxDepenetrationVelocity: number;
    sleepThreshold: number;
    defaultContactOffset: number;
    defaultSolverIterations: number;
    defaultSolverVelocityIterations: number;
    queriesHitBackfaces: boolean;
    queriesHitTriggers: boolean;



    DeserializeSettings(): void;
    SerializeSettings(): void;
    ToJson(): string;
    TryGetRuntimeTag(userTag: string, runtimeTag: CSArray<string>): boolean;
    TryGetUserTag(runtimeTag: string, userTag: CSArray<string>): boolean;


}
    
interface SceneAsset extends Object {





}
    
interface AirshipPackageDocument {
    id: string;
    assetVersion: string;
    codeVersion: string;
    publishVersionNumber: string;
    game: boolean;
    localSource: boolean;
    disabled: boolean;
    defaultPackage: boolean;
    forceLatestVersion: boolean;



    IsDownloaded(): boolean;


}
    
interface AirshipPackageDocumentConstructor {


    new(): AirshipPackageDocument;


    FindPathFromDocument(document: AirshipPackageDocument): string;

}
declare const AirshipPackageDocument: AirshipPackageDocumentConstructor;
    
interface GameConfigConstructor {
    MaximumTags: number;


    new(): GameConfig;


    Load(): GameConfig;

}
declare const GameConfig: GameConfigConstructor;
    
interface RenderSettings extends Object {





}
    
interface Light extends Behaviour {
    type: LightType;
    spotAngle: number;
    innerSpotAngle: number;
    color: Color;
    colorTemperature: number;
    useColorTemperature: boolean;
    intensity: number;
    bounceIntensity: number;
    useBoundingSphereOverride: boolean;
    boundingSphereOverride: Vector4;
    useViewFrustumForShadowCasterCull: boolean;
    shadowCustomResolution: number;
    shadowBias: number;
    shadowNormalBias: number;
    shadowNearPlane: number;
    useShadowMatrixOverride: boolean;
    shadowMatrixOverride: Matrix4x4;
    range: number;
    readonly dilatedRange: number;
    flare: Flare;
    bakingOutput: LightBakingOutput;
    cullingMask: number;
    renderingLayerMask: number;
    lightShadowCasterMode: LightShadowCasterMode;
    shadowRadius: number;
    shadowAngle: number;
    shadows: LightShadows;
    shadowStrength: number;
    shadowResolution: LightShadowResolution;
    layerShadowCullDistances: CSArray<number>;
    cookieSize: number;
    cookie: Texture;
    renderMode: LightRenderMode;
    areaSize: Vector2;
    lightmapBakeType: LightmapBakeType;
    readonly commandBufferCount: number;



    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass): void;
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass, queueType: ComputeQueueType): void;
    GetCommandBuffers(evt: LightEvent): CSArray<CommandBuffer>;
    RemoveAllCommandBuffers(): void;
    RemoveCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    RemoveCommandBuffers(evt: LightEvent): void;
    Reset(): void;
    SetLightDirty(): void;


}
    
interface Flare extends Object {





}
    
interface FlareConstructor {


    new(): Flare;



}
declare const Flare: FlareConstructor;
    
interface LightBakingOutput {
    probeOcclusionLightIndex: number;
    occlusionMaskChannel: number;
    lightmapBakeType: LightmapBakeType;
    mixedLightingMode: MixedLightingMode;
    isBaked: boolean;





}
    
interface LightConstructor {


    new(): Light;



}
declare const Light: LightConstructor;
    
interface RenderSettingsConstructor {
    fog: boolean;
    fogStartDistance: number;
    fogEndDistance: number;
    fogMode: FogMode;
    fogColor: Color;
    fogDensity: number;
    ambientMode: AmbientMode;
    ambientSkyColor: Color;
    ambientEquatorColor: Color;
    ambientGroundColor: Color;
    ambientIntensity: number;
    ambientLight: Color;
    subtractiveShadowColor: Color;
    skybox: Material;
    sun: Light;
    ambientProbe: SphericalHarmonicsL2;
    customReflectionTexture: Texture;
    reflectionIntensity: number;
    reflectionBounces: number;
    defaultReflectionMode: DefaultReflectionMode;
    defaultReflectionResolution: number;
    haloStrength: number;
    flareStrength: number;
    flareFadeSpeed: number;





}
declare const RenderSettings: RenderSettingsConstructor;
    
interface ServerBootstrap extends MonoBehaviour {
    startupConfig: StartupConfig;
    overrideGameBundleId: string;
    overrideGameBundleVersion: string;
    airshipJWT: string;
    agones: AgonesBetaSdk;
    allocatedByAgones: boolean;
    gameId: string;
    serverId: string;
    organizationId: string;
    serverContext: ServerContext;
    isServerReady: boolean;
    isStartupConfigReady: boolean;

    readonly OnStartLoadingGame: MonoSignal<void>;
    readonly OnServerReady: MonoSignal<void>;
    readonly OnStartupConfigReady: MonoSignal<void>;
    readonly onProcessExit: MonoSignal<void>;


    FinishedSetup(): void;
    GetJoinCode(): string;
    InvokeOnProcessExit(): void;
    IsAgonesEnvironment(): boolean;
    OnGameServerChange(server: GameServer): void;
    Shutdown(): void;


}
    
interface StartupConfig {
    GameBundleId: string;
    GameAssetVersion: string;
    GameCodeVersion: string;
    StartingSceneName: string;
    GamePublishVersion: string;
    CdnUrl: string;
    packages: CSArray<AirshipPackageDocument>;





}
    
interface AgonesSdk extends MonoBehaviour {
    healthIntervalSecond: number;
    healthEnabled: boolean;
    logEnabled: boolean;



    Allocate(): boolean;
    Connect(): boolean;
    GameServer(): GameServer;
    Ready(): boolean;
    Reserve(duration: unknown): boolean;
    SetAnnotation(key: string, value: string): boolean;
    SetLabel(key: string, value: string): boolean;
    Shutdown(): boolean;
    WatchGameServer(callback: WatchGameServerCallback): void;


}
    
interface GameServer {
    ObjectMeta: GameServerObjectMeta;
    Spec: GameServerSpec;
    Status: GameServerStatus;



    Equals(input: unknown): boolean;
    Equals(input: GameServer): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface GameServerObjectMeta {
    readonly Name: string;
    readonly Namespace: string;
    readonly Uid: string;
    readonly ResourceVersion: string;
    readonly Generation: number;
    readonly CreationTimestamp: string;
    readonly DeletionTimestamp?: string;
    readonly Annotations: CSDictionary<string, string>;
    readonly Labels: CSDictionary<string, string>;



    Equals(input: unknown): boolean;
    Equals(input: GameServerObjectMeta): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface GameServerObjectMetaConstructor {


    new(data: CSDictionary<string, unknown>): GameServerObjectMeta;



}
declare const GameServerObjectMeta: GameServerObjectMetaConstructor;
    
interface GameServerSpec {
    Health: SpecHealth;



    Equals(input: unknown): boolean;
    Equals(input: GameServerSpec): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface SpecHealth {
    readonly Disabled: boolean;
    readonly PeriodSeconds: number;
    readonly FailureThreshold: number;
    readonly InitialDelaySeconds: number;



    Equals(input: unknown): boolean;
    Equals(input: SpecHealth): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface SpecHealthConstructor {


    new(data: CSDictionary<string, unknown>): SpecHealth;



}
declare const SpecHealth: SpecHealthConstructor;
    
interface GameServerSpecConstructor {


    new(data: CSDictionary<string, unknown>): GameServerSpec;



}
declare const GameServerSpec: GameServerSpecConstructor;
    
interface GameServerStatus {
    readonly State: string;
    readonly Address: string;
    readonly Addresses: CSArray<StatusAddresses>;
    readonly Ports: CSArray<StatusPort>;



    Equals(input: unknown): boolean;
    Equals(input: GameServerStatus): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StatusAddresses {
    readonly Address: string;
    readonly Type: string;



    Equals(input: unknown): boolean;
    Equals(input: StatusAddresses): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StatusAddressesConstructor {


    new(data: CSDictionary<string, unknown>): StatusAddresses;



}
declare const StatusAddresses: StatusAddressesConstructor;
    
interface StatusPort {
    readonly Name: string;
    readonly Port: number;



    Equals(input: unknown): boolean;
    Equals(input: StatusPort): boolean;
    GetHashCode(): number;
    ToString(): string;


}
    
interface StatusPortConstructor {


    new(data: CSDictionary<string, unknown>): StatusPort;



}
declare const StatusPort: StatusPortConstructor;
    
interface GameServerStatusConstructor {


    new(data: CSDictionary<string, unknown>): GameServerStatus;



}
declare const GameServerStatus: GameServerStatusConstructor;
    
interface GameServerConstructor {


    new(data: CSDictionary<string, unknown>): GameServer;



}
declare const GameServer: GameServerConstructor;
    
interface WatchGameServerCallback {



    BeginInvoke(gameServer: GameServer, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(gameServer: GameServer): void;


}
    
interface WatchGameServerCallbackConstructor {


    new(object: unknown, method: unknown): WatchGameServerCallback;



}
declare const WatchGameServerCallback: WatchGameServerCallbackConstructor;
    
interface AgonesSdkConstructor {


    new(): AgonesSdk;



}
declare const AgonesSdk: AgonesSdkConstructor;
    
interface AgonesBetaSdk extends AgonesSdk {



    AppendListValue(key: string, value: string): boolean;
    DecrementCounter(key: string, amount: number): boolean;
    DeleteListValue(key: string, value: string): boolean;
    GetCounterCapacity(key: string): number;
    GetCounterCount(key: string): number;
    GetListCapacity(key: string): number;
    GetListLength(key: string): number;
    GetListValues(key: string): CSArray<string>;
    IncrementCounter(key: string, amount: number): boolean;
    ListContains(key: string, value: string): boolean;
    SetCounterCapacity(key: string, amount: number): boolean;
    SetCounterCount(key: string, amount: number): boolean;
    SetListCapacity(key: string, amount: number): boolean;


}
    
interface AgonesBetaSdkConstructor {


    new(): AgonesBetaSdk;



}
declare const AgonesBetaSdk: AgonesBetaSdkConstructor;
    
    
interface NetworkConnection {
    readonly connectionId: number;
    isAuthenticated: boolean;
    authenticationData: unknown;
    isReady: boolean;
    lastMessageTime: number;
    readonly owned: CSArray<NetworkIdentity>;
    readonly identity: NetworkIdentity;
    readonly remoteTimeStamp: number;



    Cleanup(): void;
    Disconnect(): void;
    Send<T>(message: T, channelId: number): void;
    ToString(): string;


}
    
    
interface NetworkConnectionToClient extends NetworkConnection {
    readonly observing: CSArray<NetworkIdentity>;
    unbatcher: Unbatcher;
    remoteTimeline: number;
    remoteTimescale: number;
    snapshotBufferSizeLimit: number;
    readonly address: string;
    readonly rtt: number;



    Disconnect(): void;
    OnTimeSnapshot(snapshot: TimeSnapshot): void;
    UpdateTimeInterpolation(): void;


}
    
interface Unbatcher {
    readonly BatchesCount: number;



    AddBatch(batch: CSArray<number>): boolean;
    GetNextMessage(message: CSArray<number>, remoteTimeStamp: unknown): boolean;


}
    
interface UnbatcherConstructor {


    new(): Unbatcher;



}
declare const Unbatcher: UnbatcherConstructor;
    
interface Snapshot {
    remoteTime: number;
    localTime: number;





}
    
interface TimeSnapshot extends Snapshot {
    remoteTime: number;
    localTime: number;





}
    
interface TimeSnapshotConstructor {


    new(remoteTime: number, localTime: number): TimeSnapshot;



}
declare const TimeSnapshot: TimeSnapshotConstructor;
    
interface NetworkConnectionToClientConstructor {


    new(networkConnectionId: number, clientAddress: string): NetworkConnectionToClient;



}
declare const NetworkConnectionToClient: NetworkConnectionToClientConstructor;
    
    
interface NetworkConnectionConstructor {
    LocalConnectionId: number;





}
declare const NetworkConnection: NetworkConnectionConstructor;
    
interface NetworkReader {
    Position: number;
    readonly Remaining: number;
    readonly Capacity: number;



    Read<T>(): T;
    ReadByte(): number;
    ReadBytes(bytes: CSArray<number>, count: number): CSArray<number>;
    ReadBytesSegment(count: number): CSArray<number>;
    SetBuffer(segment: CSArray<number>): void;
    ToString(): string;


}
    
interface NetworkReaderConstructor {
    AllocationLimit: number;


    new(segment: CSArray<number>): NetworkReader;



}
declare const NetworkReader: NetworkReaderConstructor;
    
interface NetworkWriter {
    Position: number;
    readonly Capacity: number;



    Reset(): void;
    ToArray(): CSArray<number>;
    ToArraySegment(): CSArray<number>;
    ToString(): string;
    Write<T>(value: T): void;
    WriteByte(value: number): void;
    WriteBytes(array: CSArray<number>, offset: number, count: number): void;
    WriteBytes(ptr: unknown, offset: number, size: number): boolean;


}
    
interface NetworkWriterConstructor {
    MaxStringLength: number;
    DefaultCapacity: number;


    new(): NetworkWriter;



}
declare const NetworkWriter: NetworkWriterConstructor;
    
    
interface ServerContext extends NetworkBehaviour {
    serverId: string;
    gameId: string;
    organizationId: string;
    NetworkserverId: string;
    NetworkgameId: string;
    NetworkorganizationId: string;



    DeserializeSyncVars(reader: NetworkReader, initialState: boolean): void;
    SerializeSyncVars(writer: NetworkWriter, forceAll: boolean): void;
    Weaved(): boolean;


}
    
interface ServerContextConstructor {


    new(): ServerContext;



}
declare const ServerContext: ServerContextConstructor;
    
interface ServerBootstrapConstructor {
    editorStartingSceneIntent: string;


    new(): ServerBootstrap;



}
declare const ServerBootstrap: ServerBootstrapConstructor;
    
    
interface CreateSceneParameters {
    localPhysicsMode: LocalPhysicsMode;





}
    
interface CreateSceneParametersConstructor {


    new(physicsMode: LocalPhysicsMode): CreateSceneParameters;



}
declare const CreateSceneParameters: CreateSceneParametersConstructor;
    
interface LoadSceneParameters {
    loadSceneMode: LoadSceneMode;
    localPhysicsMode: LocalPhysicsMode;





}
    
interface LoadSceneParametersConstructor {


    new(mode: LoadSceneMode): LoadSceneParameters;
    new(mode: LoadSceneMode, physicsMode: LocalPhysicsMode): LoadSceneParameters;



}
declare const LoadSceneParameters: LoadSceneParametersConstructor;
    
    
interface AvatarMask extends Object {
    transformCount: number;



    AddTransformPath(transform: Transform): void;
    AddTransformPath(transform: Transform, recursive: boolean): void;
    GetHumanoidBodyPartActive(index: AvatarMaskBodyPart): boolean;
    GetTransformActive(index: number): boolean;
    GetTransformPath(index: number): string;
    RemoveTransformPath(transform: Transform): void;
    RemoveTransformPath(transform: Transform, recursive: boolean): void;
    SetHumanoidBodyPartActive(index: AvatarMaskBodyPart, value: boolean): void;
    SetTransformActive(index: number, value: boolean): void;
    SetTransformPath(index: number, path: string): void;


}
    
interface AvatarMaskConstructor {


    new(): AvatarMask;



}
declare const AvatarMask: AvatarMaskConstructor;
    
interface SkinnedMeshRenderer extends Renderer {
    quality: SkinQuality;
    updateWhenOffscreen: boolean;
    forceMatrixRecalculationPerRender: boolean;
    rootBone: Transform;
    bones: CSArray<Transform>;
    sharedMesh: Mesh;
    skinnedMotionVectors: boolean;
    vertexBufferTarget: Target;



    BakeMesh(mesh: Mesh): void;
    BakeMesh(mesh: Mesh, useScale: boolean): void;
    GetBlendShapeWeight(index: number): number;
    GetPreviousVertexBuffer(): GraphicsBuffer;
    GetVertexBuffer(): GraphicsBuffer;
    SetBlendShapeWeight(index: number, value: number): void;


}
    
interface SkinnedMeshRendererConstructor {


    new(): SkinnedMeshRenderer;



}
declare const SkinnedMeshRenderer: SkinnedMeshRendererConstructor;
    
interface GizmoUtils extends Debug {





}
    
interface GizmoUtilsConstructor {


    new(): GizmoUtils;


    DrawArc(startAngle: number, endAngle: number, position: Vector3, orientation: Quaternion, radius: number, color: Color, drawChord: boolean, drawSector: boolean, arcSegments: number, durationSec: number): void;
    DrawBox(position: Vector3, orientation: Quaternion, halfSize: Vector3, color: Color, durationSec: number): void;
    DrawCircle(position: Vector3, rotation: Quaternion, radius: number, segments: number, color: Color, durationSec: number): void;
    DrawQuad(pointA: Vector3, pointB: Vector3, pointC: Vector3, pointD: Vector3, color: Color, durationSec: number): void;
    DrawRect(origin: Vector3, orientation: Quaternion, extent: Vector2, color: Color, durationSec: number): void;
    DrawSingleLine(startPosition: Vector3, endPosition: Vector3, color: Color, durationSec: number): void;
    DrawSphere(position: Vector3, radius: number, color: Color, segments: number, durationSec: number): void;
    TogglePauseEngine(): void;

}
declare const GizmoUtils: GizmoUtilsConstructor;
    
interface CollisionWatcher extends MonoBehaviour {

    readonly OnCollide: MonoSignal<Collision>;




}
    
interface Collision {
    readonly impulse: Vector3;
    readonly relativeVelocity: Vector3;
    readonly rigidbody: Rigidbody;
    readonly articulationBody: ArticulationBody;
    readonly body: Component;
    readonly collider: Collider;
    readonly transform: Transform;
    readonly gameObject: GameObject;
    readonly contactCount: number;
    readonly contacts: CSArray<ContactPoint>;



    GetContact(index: number): ContactPoint;
    GetContacts(contacts: CSArray<ContactPoint>): number;
    GetContacts(contacts: CSArray<ContactPoint>): number;


}
    
interface ContactPoint {
    readonly point: Vector3;
    readonly normal: Vector3;
    readonly impulse: Vector3;
    readonly thisCollider: Collider;
    readonly otherCollider: Collider;
    readonly separation: number;





}
    
interface CollisionConstructor {


    new(): Collision;



}
declare const Collision: CollisionConstructor;
    
interface CollisionWatcherConstructor {


    new(): CollisionWatcher;



}
declare const CollisionWatcher: CollisionWatcherConstructor;
    
interface TriggerWatcher extends MonoBehaviour {

    readonly OnEnter: MonoSignal<Collider>;




}
    
interface TriggerWatcherConstructor {


    new(): TriggerWatcher;



}
declare const TriggerWatcher: TriggerWatcherConstructor;
    
interface PhysicsExt {





}
    
interface SphereCastReturnData {
    readonly HitCount: number;
    readonly RaycastHits: CSArray<RaycastHit>;





}
    
interface SphereCastReturnDataConstructor {


    new(hitCount: number, raycastHits: CSArray<RaycastHit>): SphereCastReturnData;



}
declare const SphereCastReturnData: SphereCastReturnDataConstructor;
    
interface PhysicsExtConstructor {


    new(): PhysicsExt;


    EasySphereCast(start: Vector3, direction: Vector3, radius: number, distance: number, layerMask: number): SphereCastReturnData;

}
declare const PhysicsExt: PhysicsExtConstructor;
    
interface Joint extends Component {
    connectedBody: Rigidbody;
    connectedArticulationBody: ArticulationBody;
    axis: Vector3;
    anchor: Vector3;
    connectedAnchor: Vector3;
    autoConfigureConnectedAnchor: boolean;
    breakForce: number;
    breakTorque: number;
    enableCollision: boolean;
    enablePreprocessing: boolean;
    massScale: number;
    connectedMassScale: number;
    readonly currentForce: Vector3;
    readonly currentTorque: Vector3;





}
    
interface JointConstructor {


    new(): Joint;



}
declare const Joint: JointConstructor;
    
interface CharacterJoint extends Joint {
    swingAxis: Vector3;
    twistLimitSpring: SoftJointLimitSpring;
    swingLimitSpring: SoftJointLimitSpring;
    lowTwistLimit: SoftJointLimit;
    highTwistLimit: SoftJointLimit;
    swing1Limit: SoftJointLimit;
    swing2Limit: SoftJointLimit;
    enableProjection: boolean;
    projectionDistance: number;
    projectionAngle: number;





}
    
interface SoftJointLimitSpring {
    spring: number;
    damper: number;





}
    
interface SoftJointLimit {
    limit: number;
    bounciness: number;
    contactDistance: number;





}
    
interface CharacterJointConstructor {


    new(): CharacterJoint;



}
declare const CharacterJoint: CharacterJointConstructor;
    
interface ServerConsole extends MonoBehaviour {



    Cleanup(): void;
    OnClientConnectedToServer(): void;
    OnStartServer(): void;


}
    
interface ServerConsoleConstructor {


    new(): ServerConsole;



}
declare const ServerConsole: ServerConsoleConstructor;
    
interface Application {





}
    
interface AdvertisingIdentifierCallback {



    BeginInvoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string): void;


}
    
interface AdvertisingIdentifierCallbackConstructor {


    new(object: unknown, method: unknown): AdvertisingIdentifierCallback;



}
declare const AdvertisingIdentifierCallback: AdvertisingIdentifierCallbackConstructor;
    
interface ApplicationConstructor {
    readonly isPlaying: boolean;
    readonly isFocused: boolean;
    readonly buildGUID: string;
    runInBackground: boolean;
    readonly isBatchMode: boolean;
    readonly dataPath: string;
    readonly streamingAssetsPath: string;
    readonly persistentDataPath: string;
    readonly temporaryCachePath: string;
    readonly absoluteURL: string;
    readonly unityVersion: string;
    readonly version: string;
    readonly installerName: string;
    readonly identifier: string;
    readonly installMode: ApplicationInstallMode;
    readonly sandboxType: ApplicationSandboxType;
    readonly productName: string;
    readonly companyName: string;
    readonly cloudProjectId: string;
    targetFrameRate: number;
    readonly consoleLogPath: string;
    backgroundLoadingPriority: ThreadPriority;
    readonly genuine: boolean;
    readonly genuineCheckAvailable: boolean;
    readonly platform: RuntimePlatform;
    readonly isMobilePlatform: boolean;
    readonly isConsolePlatform: boolean;
    readonly systemLanguage: SystemLanguage;
    readonly internetReachability: NetworkReachability;
    readonly exitCancellationToken: unknown;
    readonly isEditor: boolean;


    new(): Application;


    CanStreamedLevelBeLoaded(levelIndex: number): boolean;
    CanStreamedLevelBeLoaded(levelName: string): boolean;
    GetStackTraceLogType(logType: LogType): StackTraceLogType;
    HasProLicense(): boolean;
    HasUserAuthorization(mode: UserAuthorization): boolean;
    IsPlaying(obj: Object): boolean;
    OpenURL(url: string): void;
    Quit(exitCode: number): void;
    Quit(): void;
    RequestAdvertisingIdentifierAsync(delegateMethod: AdvertisingIdentifierCallback): boolean;
    RequestUserAuthorization(mode: UserAuthorization): AsyncOperation;
    SetStackTraceLogType(logType: LogType, stackTraceType: StackTraceLogType): void;
    Unload(): void;

    readonly lowMemory: MonoSignal<void>;
    readonly memoryUsageChanged: MonoSignal<void>;
    readonly logMessageReceived: MonoSignal<void>;
    readonly logMessageReceivedThreaded: MonoSignal<void>;
    readonly onBeforeRender: MonoSignal<void>;
    readonly focusChanged: MonoSignal<boolean>;
    readonly deepLinkActivated: MonoSignal<string>;
    readonly wantsToQuit: MonoSignal<boolean>;
    readonly quitting: MonoSignal<void>;
    readonly unloading: MonoSignal<void>;
}
declare const Application: ApplicationConstructor;
    
interface ClientNetworkConnector extends MonoBehaviour {
    expectingDisconnect: boolean;
    reconnectAttempt: number;



    NetworkClient_OnConnected(): void;
    NetworkClient_OnDisconnected(): void;


}
    
interface ClientNetworkConnectorConstructor {


    new(): ClientNetworkConnector;



}
declare const ClientNetworkConnector: ClientNetworkConnectorConstructor;
    
interface ParticleSystem extends Component {
    readonly isPlaying: boolean;
    readonly isEmitting: boolean;
    readonly isStopped: boolean;
    readonly isPaused: boolean;
    readonly particleCount: number;
    time: number;
    readonly totalTime: number;
    randomSeed: number;
    useAutoRandomSeed: boolean;
    readonly proceduralSimulationSupported: boolean;
    readonly has3DParticleRotations: boolean;
    readonly hasNonUniformParticleSizes: boolean;
    readonly main: MainModule;
    readonly emission: EmissionModule;
    readonly shape: ShapeModule;
    readonly velocityOverLifetime: VelocityOverLifetimeModule;
    readonly limitVelocityOverLifetime: LimitVelocityOverLifetimeModule;
    readonly inheritVelocity: InheritVelocityModule;
    readonly lifetimeByEmitterSpeed: LifetimeByEmitterSpeedModule;
    readonly forceOverLifetime: ForceOverLifetimeModule;
    readonly colorOverLifetime: ColorOverLifetimeModule;
    readonly colorBySpeed: ColorBySpeedModule;
    readonly sizeOverLifetime: SizeOverLifetimeModule;
    readonly sizeBySpeed: SizeBySpeedModule;
    readonly rotationOverLifetime: RotationOverLifetimeModule;
    readonly rotationBySpeed: RotationBySpeedModule;
    readonly externalForces: ExternalForcesModule;
    readonly noise: NoiseModule;
    readonly collision: CollisionModule;
    readonly trigger: TriggerModule;
    readonly subEmitters: SubEmittersModule;
    readonly textureSheetAnimation: TextureSheetAnimationModule;
    readonly lights: LightsModule;
    readonly trails: TrailModule;
    readonly customData: CustomDataModule;



    AllocateAxisOfRotationAttribute(): void;
    AllocateCustomDataAttribute(stream: ParticleSystemCustomData): void;
    AllocateMeshIndexAttribute(): void;
    Clear(withChildren: boolean): void;
    Clear(): void;
    Emit(count: number): void;
    Emit(emitParams: EmitParams, count: number): void;
    GetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetPlaybackState(): PlaybackState;
    GetTrails(): Trails;
    GetTrails(trailData: unknown): number;
    IsAlive(withChildren: boolean): boolean;
    IsAlive(): boolean;
    Pause(withChildren: boolean): void;
    Pause(): void;
    Play(withChildren: boolean): void;
    Play(): void;
    SetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetPlaybackState(playbackState: PlaybackState): void;
    SetTrails(trailData: Trails): void;
    Simulate(t: number, withChildren: boolean, restart: boolean, fixedTimeStep: boolean): void;
    Simulate(t: number, withChildren: boolean, restart: boolean): void;
    Simulate(t: number, withChildren: boolean): void;
    Simulate(t: number): void;
    Stop(withChildren: boolean, stopBehavior: ParticleSystemStopBehavior): void;
    Stop(withChildren: boolean): void;
    Stop(): void;
    TriggerSubEmitter(subEmitterIndex: number): void;
    TriggerSubEmitter(subEmitterIndex: number, particle: unknown): void;
    TriggerSubEmitter(subEmitterIndex: number, particles: CSArray<Particle>): void;


}
    
interface MainModule {
    emitterVelocity: Vector3;
    duration: number;
    loop: boolean;
    prewarm: boolean;
    startDelay: MinMaxCurve;
    startDelayMultiplier: number;
    startLifetime: MinMaxCurve;
    startLifetimeMultiplier: number;
    startSpeed: MinMaxCurve;
    startSpeedMultiplier: number;
    startSize3D: boolean;
    startSize: MinMaxCurve;
    startSizeMultiplier: number;
    startSizeX: MinMaxCurve;
    startSizeXMultiplier: number;
    startSizeY: MinMaxCurve;
    startSizeYMultiplier: number;
    startSizeZ: MinMaxCurve;
    startSizeZMultiplier: number;
    startRotation3D: boolean;
    startRotation: MinMaxCurve;
    startRotationMultiplier: number;
    startRotationX: MinMaxCurve;
    startRotationXMultiplier: number;
    startRotationY: MinMaxCurve;
    startRotationYMultiplier: number;
    startRotationZ: MinMaxCurve;
    startRotationZMultiplier: number;
    flipRotation: number;
    startColor: MinMaxGradient;
    gravitySource: ParticleSystemGravitySource;
    gravityModifier: MinMaxCurve;
    gravityModifierMultiplier: number;
    simulationSpace: ParticleSystemSimulationSpace;
    customSimulationSpace: Transform;
    simulationSpeed: number;
    useUnscaledTime: boolean;
    scalingMode: ParticleSystemScalingMode;
    playOnAwake: boolean;
    maxParticles: number;
    emitterVelocityMode: ParticleSystemEmitterVelocityMode;
    stopAction: ParticleSystemStopAction;
    ringBufferMode: ParticleSystemRingBufferMode;
    ringBufferLoopRange: Vector2;
    cullingMode: ParticleSystemCullingMode;





}
    
interface MinMaxCurve {
    mode: ParticleSystemCurveMode;
    curveMultiplier: number;
    curveMax: AnimationCurve;
    curveMin: AnimationCurve;
    constantMax: number;
    constantMin: number;
    constant: number;
    curve: AnimationCurve;



    Evaluate(time: number): number;
    Evaluate(time: number, lerpFactor: number): number;


}
    
interface MinMaxCurveConstructor {


    new(constant: number): MinMaxCurve;
    new(multiplier: number, curve: AnimationCurve): MinMaxCurve;
    new(multiplier: number, min: AnimationCurve, max: AnimationCurve): MinMaxCurve;
    new(min: number, max: number): MinMaxCurve;



}
declare const MinMaxCurve: MinMaxCurveConstructor;
    
interface MinMaxGradient {
    mode: ParticleSystemGradientMode;
    gradientMax: Gradient;
    gradientMin: Gradient;
    colorMax: Color;
    colorMin: Color;
    color: Color;
    gradient: Gradient;



    Evaluate(time: number): Color;
    Evaluate(time: number, lerpFactor: number): Color;


}
    
interface Gradient {
    colorKeys: CSArray<GradientColorKey>;
    alphaKeys: CSArray<GradientAlphaKey>;
    mode: GradientMode;
    colorSpace: ColorSpace;



    Equals(o: unknown): boolean;
    Equals(other: Gradient): boolean;
    Evaluate(time: number): Color;
    GetHashCode(): number;
    SetKeys(colorKeys: CSArray<GradientColorKey>, alphaKeys: CSArray<GradientAlphaKey>): void;


}
    
interface GradientColorKey {
    color: Color;
    time: number;





}
    
interface GradientColorKeyConstructor {


    new(col: Color, time: number): GradientColorKey;



}
declare const GradientColorKey: GradientColorKeyConstructor;
    
interface GradientAlphaKey {
    alpha: number;
    time: number;





}
    
interface GradientAlphaKeyConstructor {


    new(alpha: number, time: number): GradientAlphaKey;



}
declare const GradientAlphaKey: GradientAlphaKeyConstructor;
    
interface GradientConstructor {


    new(): Gradient;



}
declare const Gradient: GradientConstructor;
    
interface MinMaxGradientConstructor {


    new(color: Color): MinMaxGradient;
    new(gradient: Gradient): MinMaxGradient;
    new(min: Color, max: Color): MinMaxGradient;
    new(min: Gradient, max: Gradient): MinMaxGradient;



}
declare const MinMaxGradient: MinMaxGradientConstructor;
    
interface EmissionModule {
    enabled: boolean;
    rateOverTime: MinMaxCurve;
    rateOverTimeMultiplier: number;
    rateOverDistance: MinMaxCurve;
    rateOverDistanceMultiplier: number;
    burstCount: number;



    GetBurst(index: number): Burst;
    GetBursts(bursts: CSArray<Burst>): number;
    SetBurst(index: number, burst: Burst): void;
    SetBursts(bursts: CSArray<Burst>): void;
    SetBursts(bursts: CSArray<Burst>, size: number): void;


}
    
interface Burst {
    time: number;
    count: MinMaxCurve;
    minCount: number;
    maxCount: number;
    cycleCount: number;
    repeatInterval: number;
    probability: number;





}
    
interface BurstConstructor {


    new(_time: number, _count: number): Burst;
    new(_time: number, _minCount: number, _maxCount: number): Burst;
    new(_time: number, _minCount: number, _maxCount: number, _cycleCount: number, _repeatInterval: number): Burst;
    new(_time: number, _count: MinMaxCurve): Burst;
    new(_time: number, _count: MinMaxCurve, _cycleCount: number, _repeatInterval: number): Burst;



}
declare const Burst: BurstConstructor;
    
interface ShapeModule {
    enabled: boolean;
    shapeType: ParticleSystemShapeType;
    randomDirectionAmount: number;
    sphericalDirectionAmount: number;
    randomPositionAmount: number;
    alignToDirection: boolean;
    radius: number;
    radiusMode: ParticleSystemShapeMultiModeValue;
    radiusSpread: number;
    radiusSpeed: MinMaxCurve;
    radiusSpeedMultiplier: number;
    radiusThickness: number;
    angle: number;
    length: number;
    boxThickness: Vector3;
    meshShapeType: ParticleSystemMeshShapeType;
    mesh: Mesh;
    meshRenderer: MeshRenderer;
    skinnedMeshRenderer: SkinnedMeshRenderer;
    sprite: Sprite;
    spriteRenderer: SpriteRenderer;
    useMeshMaterialIndex: boolean;
    meshMaterialIndex: number;
    useMeshColors: boolean;
    normalOffset: number;
    meshSpawnMode: ParticleSystemShapeMultiModeValue;
    meshSpawnSpread: number;
    meshSpawnSpeed: MinMaxCurve;
    meshSpawnSpeedMultiplier: number;
    arc: number;
    arcMode: ParticleSystemShapeMultiModeValue;
    arcSpread: number;
    arcSpeed: MinMaxCurve;
    arcSpeedMultiplier: number;
    donutRadius: number;
    position: Vector3;
    rotation: Vector3;
    scale: Vector3;
    texture: Texture2D;
    textureClipChannel: ParticleSystemShapeTextureChannel;
    textureClipThreshold: number;
    textureColorAffectsParticles: boolean;
    textureAlphaAffectsParticles: boolean;
    textureBilinearFiltering: boolean;
    textureUVChannel: number;





}
    
interface SpriteRenderer extends Renderer {
    sprite: Sprite;
    drawMode: SpriteDrawMode;
    size: Vector2;
    adaptiveModeThreshold: number;
    tileMode: SpriteTileMode;
    color: Color;
    maskInteraction: SpriteMaskInteraction;
    flipX: boolean;
    flipY: boolean;
    spriteSortPoint: SpriteSortPoint;



    RegisterSpriteChangeCallback(callback: UnityAction<SpriteRenderer>): void;
    UnregisterSpriteChangeCallback(callback: UnityAction<SpriteRenderer>): void;


}
    
interface UnityAction<T0> {



    BeginInvoke(arg0: T0, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(arg0: T0): void;


}
    
interface UnityActionConstructor {


    new(object: unknown, method: unknown): UnityAction<T0>;



}
declare const UnityAction: UnityActionConstructor;
    
interface SpriteRendererConstructor {


    new(): SpriteRenderer;



}
declare const SpriteRenderer: SpriteRendererConstructor;
    
interface VelocityOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    orbitalX: MinMaxCurve;
    orbitalY: MinMaxCurve;
    orbitalZ: MinMaxCurve;
    orbitalXMultiplier: number;
    orbitalYMultiplier: number;
    orbitalZMultiplier: number;
    orbitalOffsetX: MinMaxCurve;
    orbitalOffsetY: MinMaxCurve;
    orbitalOffsetZ: MinMaxCurve;
    orbitalOffsetXMultiplier: number;
    orbitalOffsetYMultiplier: number;
    orbitalOffsetZMultiplier: number;
    radial: MinMaxCurve;
    radialMultiplier: number;
    speedModifier: MinMaxCurve;
    speedModifierMultiplier: number;
    space: ParticleSystemSimulationSpace;





}
    
interface LimitVelocityOverLifetimeModule {
    enabled: boolean;
    limitX: MinMaxCurve;
    limitXMultiplier: number;
    limitY: MinMaxCurve;
    limitYMultiplier: number;
    limitZ: MinMaxCurve;
    limitZMultiplier: number;
    limit: MinMaxCurve;
    limitMultiplier: number;
    dampen: number;
    separateAxes: boolean;
    space: ParticleSystemSimulationSpace;
    drag: MinMaxCurve;
    dragMultiplier: number;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;





}
    
interface InheritVelocityModule {
    enabled: boolean;
    mode: ParticleSystemInheritVelocityMode;
    curve: MinMaxCurve;
    curveMultiplier: number;





}
    
interface LifetimeByEmitterSpeedModule {
    enabled: boolean;
    curve: MinMaxCurve;
    curveMultiplier: number;
    range: Vector2;





}
    
interface ForceOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    space: ParticleSystemSimulationSpace;
    randomized: boolean;





}
    
interface ColorOverLifetimeModule {
    enabled: boolean;
    color: MinMaxGradient;





}
    
interface ColorBySpeedModule {
    enabled: boolean;
    color: MinMaxGradient;
    range: Vector2;





}
    
interface SizeOverLifetimeModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;





}
    
interface SizeBySpeedModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;





}
    
interface RotationOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;





}
    
interface RotationBySpeedModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;





}
    
interface ExternalForcesModule {
    enabled: boolean;
    multiplier: number;
    multiplierCurve: MinMaxCurve;
    influenceFilter: ParticleSystemGameObjectFilter;
    influenceMask: LayerMask;
    readonly influenceCount: number;



    AddInfluence(field: ParticleSystemForceField): void;
    GetInfluence(index: number): ParticleSystemForceField;
    IsAffectedBy(field: ParticleSystemForceField): boolean;
    RemoveAllInfluences(): void;
    RemoveInfluence(index: number): void;
    RemoveInfluence(field: ParticleSystemForceField): void;
    SetInfluence(index: number, field: ParticleSystemForceField): void;


}
    
interface ParticleSystemForceField extends Behaviour {
    shape: ParticleSystemForceFieldShape;
    startRange: number;
    endRange: number;
    length: number;
    gravityFocus: number;
    rotationRandomness: Vector2;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;
    vectorField: Texture3D;
    directionX: MinMaxCurve;
    directionY: MinMaxCurve;
    directionZ: MinMaxCurve;
    gravity: MinMaxCurve;
    rotationSpeed: MinMaxCurve;
    rotationAttraction: MinMaxCurve;
    drag: MinMaxCurve;
    vectorFieldSpeed: MinMaxCurve;
    vectorFieldAttraction: MinMaxCurve;





}
    
interface Texture3D extends Texture {
    readonly depth: number;
    readonly format: TextureFormat;
    readonly isReadable: boolean;



    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    GetPixel(x: number, y: number, z: number): Color;
    GetPixel(x: number, y: number, z: number, mipLevel: number): Color;
    GetPixelBilinear(u: number, v: number, w: number): Color;
    GetPixelBilinear(u: number, v: number, w: number, mipLevel: number): Color;
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    SetPixel(x: number, y: number, z: number, color: Color): void;
    SetPixel(x: number, y: number, z: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(colors: CSArray<Color32>): void;
    UpdateExternalTexture(nativeTex: unknown): void;


}
    
interface Texture3DConstructor {


    new(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags): Texture3D;
    new(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture3D;
    new(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown, createUninitialized: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, createUninitialized: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;


    CreateExternalTexture(width: number, height: number, depth: number, format: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;

}
declare const Texture3D: Texture3DConstructor;
    
interface ParticleSystemForceFieldConstructor {


    new(): ParticleSystemForceField;


    FindAll(): CSArray<ParticleSystemForceField>;

}
declare const ParticleSystemForceField: ParticleSystemForceFieldConstructor;
    
interface NoiseModule {
    enabled: boolean;
    separateAxes: boolean;
    strength: MinMaxCurve;
    strengthMultiplier: number;
    strengthX: MinMaxCurve;
    strengthXMultiplier: number;
    strengthY: MinMaxCurve;
    strengthYMultiplier: number;
    strengthZ: MinMaxCurve;
    strengthZMultiplier: number;
    frequency: number;
    damping: boolean;
    octaveCount: number;
    octaveMultiplier: number;
    octaveScale: number;
    quality: ParticleSystemNoiseQuality;
    scrollSpeed: MinMaxCurve;
    scrollSpeedMultiplier: number;
    remapEnabled: boolean;
    remap: MinMaxCurve;
    remapMultiplier: number;
    remapX: MinMaxCurve;
    remapXMultiplier: number;
    remapY: MinMaxCurve;
    remapYMultiplier: number;
    remapZ: MinMaxCurve;
    remapZMultiplier: number;
    positionAmount: MinMaxCurve;
    rotationAmount: MinMaxCurve;
    sizeAmount: MinMaxCurve;





}
    
interface CollisionModule {
    enabled: boolean;
    type: ParticleSystemCollisionType;
    mode: ParticleSystemCollisionMode;
    dampen: MinMaxCurve;
    dampenMultiplier: number;
    bounce: MinMaxCurve;
    bounceMultiplier: number;
    lifetimeLoss: MinMaxCurve;
    lifetimeLossMultiplier: number;
    minKillSpeed: number;
    maxKillSpeed: number;
    collidesWith: LayerMask;
    enableDynamicColliders: boolean;
    maxCollisionShapes: number;
    quality: ParticleSystemCollisionQuality;
    voxelSize: number;
    radiusScale: number;
    sendCollisionMessages: boolean;
    colliderForce: number;
    multiplyColliderForceByCollisionAngle: boolean;
    multiplyColliderForceByParticleSpeed: boolean;
    multiplyColliderForceByParticleSize: boolean;
    readonly planeCount: number;



    AddPlane(transform: Transform): void;
    GetPlane(index: number): Transform;
    RemovePlane(index: number): void;
    RemovePlane(transform: Transform): void;
    SetPlane(index: number, transform: Transform): void;


}
    
interface TriggerModule {
    enabled: boolean;
    inside: ParticleSystemOverlapAction;
    outside: ParticleSystemOverlapAction;
    enter: ParticleSystemOverlapAction;
    exit: ParticleSystemOverlapAction;
    colliderQueryMode: ParticleSystemColliderQueryMode;
    radiusScale: number;
    readonly colliderCount: number;



    AddCollider(collider: Component): void;
    GetCollider(index: number): Component;
    RemoveCollider(index: number): void;
    RemoveCollider(collider: Component): void;
    SetCollider(index: number, collider: Component): void;


}
    
interface SubEmittersModule {
    enabled: boolean;
    readonly subEmittersCount: number;



    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties, emitProbability: number): void;
    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties): void;
    GetSubEmitterEmitProbability(index: number): number;
    GetSubEmitterProperties(index: number): ParticleSystemSubEmitterProperties;
    GetSubEmitterSystem(index: number): ParticleSystem;
    GetSubEmitterType(index: number): ParticleSystemSubEmitterType;
    RemoveSubEmitter(index: number): void;
    RemoveSubEmitter(subEmitter: ParticleSystem): void;
    SetSubEmitterEmitProbability(index: number, emitProbability: number): void;
    SetSubEmitterProperties(index: number, properties: ParticleSystemSubEmitterProperties): void;
    SetSubEmitterSystem(index: number, subEmitter: ParticleSystem): void;
    SetSubEmitterType(index: number, type: ParticleSystemSubEmitterType): void;


}
    
interface TextureSheetAnimationModule {
    enabled: boolean;
    mode: ParticleSystemAnimationMode;
    timeMode: ParticleSystemAnimationTimeMode;
    fps: number;
    numTilesX: number;
    numTilesY: number;
    animation: ParticleSystemAnimationType;
    rowMode: ParticleSystemAnimationRowMode;
    frameOverTime: MinMaxCurve;
    frameOverTimeMultiplier: number;
    startFrame: MinMaxCurve;
    startFrameMultiplier: number;
    cycleCount: number;
    rowIndex: number;
    uvChannelMask: UVChannelFlags;
    readonly spriteCount: number;
    speedRange: Vector2;



    AddSprite(sprite: Sprite): void;
    GetSprite(index: number): Sprite;
    RemoveSprite(index: number): void;
    SetSprite(index: number, sprite: Sprite): void;


}
    
interface LightsModule {
    enabled: boolean;
    ratio: number;
    useRandomDistribution: boolean;
    light: Light;
    useParticleColor: boolean;
    sizeAffectsRange: boolean;
    alphaAffectsIntensity: boolean;
    range: MinMaxCurve;
    rangeMultiplier: number;
    intensity: MinMaxCurve;
    intensityMultiplier: number;
    maxLights: number;





}
    
interface TrailModule {
    enabled: boolean;
    mode: ParticleSystemTrailMode;
    ratio: number;
    lifetime: MinMaxCurve;
    lifetimeMultiplier: number;
    minVertexDistance: number;
    textureMode: ParticleSystemTrailTextureMode;
    textureScale: Vector2;
    worldSpace: boolean;
    dieWithParticles: boolean;
    sizeAffectsWidth: boolean;
    sizeAffectsLifetime: boolean;
    inheritParticleColor: boolean;
    colorOverLifetime: MinMaxGradient;
    widthOverTrail: MinMaxCurve;
    widthOverTrailMultiplier: number;
    colorOverTrail: MinMaxGradient;
    generateLightingData: boolean;
    ribbonCount: number;
    shadowBias: number;
    splitSubEmitterRibbons: boolean;
    attachRibbonsToTransform: boolean;





}
    
interface CustomDataModule {
    enabled: boolean;



    GetColor(stream: ParticleSystemCustomData): MinMaxGradient;
    GetMode(stream: ParticleSystemCustomData): ParticleSystemCustomDataMode;
    GetVector(stream: ParticleSystemCustomData, component: number): MinMaxCurve;
    GetVectorComponentCount(stream: ParticleSystemCustomData): number;
    SetColor(stream: ParticleSystemCustomData, gradient: MinMaxGradient): void;
    SetMode(stream: ParticleSystemCustomData, mode: ParticleSystemCustomDataMode): void;
    SetVector(stream: ParticleSystemCustomData, component: number, curve: MinMaxCurve): void;
    SetVectorComponentCount(stream: ParticleSystemCustomData, count: number): void;


}
    
interface EmitParams {
    particle: Particle;
    position: Vector3;
    applyShapeToPosition: boolean;
    velocity: Vector3;
    startLifetime: number;
    startSize: number;
    startSize3D: Vector3;
    axisOfRotation: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;
    startColor: Color32;
    randomSeed: number;
    meshIndex: number;



    ResetAngularVelocity(): void;
    ResetAxisOfRotation(): void;
    ResetMeshIndex(): void;
    ResetPosition(): void;
    ResetRandomSeed(): void;
    ResetRotation(): void;
    ResetStartColor(): void;
    ResetStartLifetime(): void;
    ResetStartSize(): void;
    ResetVelocity(): void;


}
    
interface Particle {
    position: Vector3;
    velocity: Vector3;
    readonly animatedVelocity: Vector3;
    readonly totalVelocity: Vector3;
    remainingLifetime: number;
    startLifetime: number;
    startColor: Color32;
    randomSeed: number;
    axisOfRotation: Vector3;
    startSize: number;
    startSize3D: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;



    GetCurrentColor(system: ParticleSystem): Color32;
    GetCurrentSize(system: ParticleSystem): number;
    GetCurrentSize3D(system: ParticleSystem): Vector3;
    GetMeshIndex(system: ParticleSystem): number;
    SetMeshIndex(index: number): void;


}
    
interface PlaybackState {





}
    
interface Trails {
    capacity: number;





}
    
interface ParticleSystemConstructor {


    new(): ParticleSystem;


    ResetPreMappedBufferMemory(): void;
    SetMaximumPreMappedBufferCounts(vertexBuffersCount: number, indexBuffersCount: number): void;

}
declare const ParticleSystem: ParticleSystemConstructor;
    
interface ParticleSystemRenderer extends Renderer {
    alignment: ParticleSystemRenderSpace;
    renderMode: ParticleSystemRenderMode;
    meshDistribution: ParticleSystemMeshDistribution;
    sortMode: ParticleSystemSortMode;
    lengthScale: number;
    velocityScale: number;
    cameraVelocityScale: number;
    normalDirection: number;
    shadowBias: number;
    sortingFudge: number;
    minParticleSize: number;
    maxParticleSize: number;
    pivot: Vector3;
    flip: Vector3;
    maskInteraction: SpriteMaskInteraction;
    trailMaterial: Material;
    enableGPUInstancing: boolean;
    allowRoll: boolean;
    freeformStretching: boolean;
    rotateWithStretchDirection: boolean;
    mesh: Mesh;
    readonly meshCount: number;
    readonly activeVertexStreamsCount: number;
    readonly activeTrailVertexStreamsCount: number;
    readonly supportsMeshInstancing: boolean;



    BakeMesh(mesh: Mesh, options: ParticleSystemBakeMeshOptions): void;
    BakeMesh(mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions): void;
    BakeTexture(verticesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    BakeTexture(verticesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    BakeTexture(verticesTexture: unknown, indicesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    BakeTexture(verticesTexture: unknown, indicesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    BakeTrailsMesh(mesh: Mesh, options: ParticleSystemBakeMeshOptions): void;
    BakeTrailsMesh(mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions): void;
    BakeTrailsTexture(verticesTexture: unknown, indicesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    BakeTrailsTexture(verticesTexture: unknown, indicesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    GetActiveTrailVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    GetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    GetMeshes(meshes: CSArray<Mesh>): number;
    GetMeshWeightings(weightings: CSArray<number>): number;
    SetActiveTrailVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    SetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    SetMeshes(meshes: CSArray<Mesh>, size: number): void;
    SetMeshes(meshes: CSArray<Mesh>): void;
    SetMeshWeightings(weightings: CSArray<number>, size: number): void;
    SetMeshWeightings(weightings: CSArray<number>): void;


}
    
interface ParticleSystemRendererConstructor {


    new(): ParticleSystemRenderer;



}
declare const ParticleSystemRenderer: ParticleSystemRendererConstructor;
    
interface Profiler {





}
    
interface ProfilerCategory {
    readonly Name: string;
    readonly Color: Color32;



    ToString(): string;


}
    
interface ProfilerCategoryConstructor {
    readonly Render: ProfilerCategory;
    readonly Scripts: ProfilerCategory;
    readonly Gui: ProfilerCategory;
    readonly Physics: ProfilerCategory;
    readonly Physics2D: ProfilerCategory;
    readonly Animation: ProfilerCategory;
    readonly Ai: ProfilerCategory;
    readonly Audio: ProfilerCategory;
    readonly Video: ProfilerCategory;
    readonly Particles: ProfilerCategory;
    readonly Lighting: ProfilerCategory;
    readonly Network: ProfilerCategory;
    readonly Loading: ProfilerCategory;
    readonly Vr: ProfilerCategory;
    readonly Input: ProfilerCategory;
    readonly Memory: ProfilerCategory;
    readonly VirtualTexturing: ProfilerCategory;
    readonly FileIO: ProfilerCategory;
    readonly Internal: ProfilerCategory;


    new(categoryName: string): ProfilerCategory;
    new(categoryName: string, color: ProfilerCategoryColor): ProfilerCategory;



}
declare const ProfilerCategory: ProfilerCategoryConstructor;
    
interface ProfilerConstructor {
    readonly supported: boolean;
    logFile: string;
    enableBinaryLog: boolean;
    maxUsedMemory: number;
    enabled: boolean;
    enableAllocationCallstacks: boolean;
    readonly areaCount: number;
    readonly usedHeapSizeLong: number;




    AddFramesFromFile(file: string): void;
    BeginSample(name: string): void;
    BeginSample(name: string, targetObject: Object): void;
    BeginThreadProfiling(threadGroupName: string, threadName: string): void;
    EmitFrameMetaData(id: unknown, tag: number, data: unknown): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData(id: unknown, tag: number, data: unknown): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EndSample(): void;
    EndThreadProfiling(): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllocatedMemoryForGraphicsDriver(): number;
    GetAreaEnabled(area: ProfilerArea): boolean;
    GetCategoriesCount(): number;
    GetMonoHeapSizeLong(): number;
    GetMonoUsedSizeLong(): number;
    GetRuntimeMemorySizeLong(o: Object): number;
    GetTempAllocatorSize(): number;
    GetTotalAllocatedMemoryLong(): number;
    GetTotalFragmentationInfo(stats: CSArray<number>): number;
    GetTotalReservedMemoryLong(): number;
    GetTotalUnusedReservedMemoryLong(): number;
    IsCategoryEnabled(category: ProfilerCategory): boolean;
    SetAreaEnabled(area: ProfilerArea, enabled: boolean): void;
    SetCategoryEnabled(category: ProfilerCategory, enabled: boolean): void;
    SetTempAllocatorRequestedSize(size: number): boolean;

}
declare const Profiler: ProfilerConstructor;
    
interface ICancelHandler extends IEventSystemHandler {



    OnCancel(eventData: BaseEventData): void;


}
    
interface IBeginDragHandler extends IEventSystemHandler {



    OnBeginDrag(eventData: PointerEventData): void;


}
    
interface IDragHandler extends IEventSystemHandler {



    OnDrag(eventData: PointerEventData): void;


}
    
interface IEndDragHandler extends IEventSystemHandler {



    OnEndDrag(eventData: PointerEventData): void;


}
    
interface IScrollHandler extends IEventSystemHandler {



    OnScroll(eventData: PointerEventData): void;


}
    
interface IUpdateSelectedHandler extends IEventSystemHandler {



    OnUpdateSelected(eventData: BaseEventData): void;


}
    
interface TMP_InputField extends Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, IUpdateSelectedHandler, ILayoutElement {
    isAlert: boolean;
    shouldActivateOnSelect: boolean;
    shouldHideMobileInput: boolean;
    shouldHideSoftKeyboard: boolean;
    text: string;
    readonly isFocused: boolean;
    caretBlinkRate: number;
    caretWidth: number;
    textViewport: RectTransform;
    textComponent: TMP_Text;
    placeholder: Graphic;
    verticalScrollbar: Scrollbar;
    scrollSensitivity: number;
    caretColor: Color;
    customCaretColor: boolean;
    selectionColor: Color;
    onValidateInput: OnValidateInput;
    characterLimit: number;
    pointSize: number;
    fontAsset: TMP_FontAsset;
    onFocusSelectAll: boolean;
    resetOnDeActivation: boolean;
    keepTextSelectionVisible: boolean;
    restoreOriginalTextOnEscape: boolean;
    isRichTextEditingAllowed: boolean;
    contentType: ContentType;
    lineType: LineType;
    lineLimit: number;
    inputType: InputType;
    readonly touchScreenKeyboard: TouchScreenKeyboard;
    keyboardType: TouchScreenKeyboardType;
    characterValidation: CharacterValidation;
    inputValidator: TMP_InputValidator;
    readOnly: boolean;
    richText: boolean;
    readonly multiLine: boolean;
    asteriskChar: string;
    readonly wasCanceled: boolean;
    caretPosition: number;
    selectionAnchorPosition: number;
    selectionFocusPosition: number;
    stringPosition: number;
    selectionStringAnchorPosition: number;
    selectionStringFocusPosition: number;
    readonly minWidth: number;
    readonly preferredWidth: number;
    readonly flexibleWidth: number;
    readonly minHeight: number;
    readonly preferredHeight: number;
    readonly flexibleHeight: number;
    readonly layoutPriority: number;

    readonly onEndEdit: MonoSignal<void>;
    readonly onSubmit: MonoSignal<void>;
    readonly onSelect: MonoSignal<void>;
    readonly onDeselect: MonoSignal<void>;
    readonly onTextSelection: MonoSignal<void>;
    readonly onEndTextSelection: MonoSignal<void>;
    readonly onValueChanged: MonoSignal<void>;
    readonly onTouchScreenKeyboardStatusChanged: MonoSignal<void>;


    ActivateInputField(): void;
    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DeactivateInputField(clearSelection: boolean): void;
    ForceLabelUpdate(): void;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    MoveTextEnd(shift: boolean): void;
    MoveTextStart(shift: boolean): void;
    MoveToEndOfLine(shift: boolean, ctrl: boolean): void;
    MoveToStartOfLine(shift: boolean, ctrl: boolean): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnCancel(eventData: BaseEventData): void;
    OnControlClick(): void;
    OnDeselect(eventData: BaseEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    OnUpdateSelected(eventData: BaseEventData): void;
    ProcessEvent(e: Event): void;
    Rebuild(update: CanvasUpdate): void;
    ReleaseSelection(): void;
    SetGlobalFontAsset(fontAsset: TMP_FontAsset): void;
    SetGlobalPointSize(pointSize: number): void;
    SetTextWithoutNotify(input: string): void;


}
    
interface IInitializePotentialDragHandler extends IEventSystemHandler {



    OnInitializePotentialDrag(eventData: PointerEventData): void;


}
    
interface Scrollbar extends Selectable, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    handleRect: RectTransform;
    direction: Direction;
    value: number;
    size: number;
    numberOfSteps: number;

    readonly onValueChanged: MonoSignal<void>;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;


}
    
interface OnValidateInput {



    BeginInvoke(text: string, charIndex: number, addedChar: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): string;
    Invoke(text: string, charIndex: number, addedChar: string): string;


}
    
interface OnValidateInputConstructor {


    new(object: unknown, method: unknown): OnValidateInput;



}
declare const OnValidateInput: OnValidateInputConstructor;
    
interface TMP_InputValidator extends ScriptableObject {



    Validate(text: CSArray<string>, pos: unknown, ch: string): string;


}
    
interface Slider extends Selectable, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    fillRect: RectTransform;
    handleRect: RectTransform;
    direction: Direction;
    minValue: number;
    maxValue: number;
    wholeNumbers: boolean;
    value: number;
    normalizedValue: number;

    readonly onValueChanged: MonoSignal<void>;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;


}
    
interface Dropdown extends Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler {
    template: RectTransform;
    captionText: Text;
    captionImage: Image;
    itemText: Text;
    itemImage: Image;
    options: CSArray<OptionData>;
    alphaFadeSpeed: number;
    value: number;

    readonly onValueChanged: MonoSignal<void>;


    AddOptions(options: CSArray<OptionData>): void;
    AddOptions(options: CSArray<string>): void;
    AddOptions(options: CSArray<Sprite>): void;
    ClearOptions(): void;
    Hide(): void;
    OnCancel(eventData: BaseEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    RefreshShownValue(): void;
    SetValueWithoutNotify(input: number): void;
    Show(): void;


}
    
interface Text extends MaskableGraphic, ILayoutElement {
    readonly cachedTextGenerator: TextGenerator;
    readonly cachedTextGeneratorForLayout: TextGenerator;
    readonly mainTexture: Texture;
    font: Font;
    text: string;
    supportRichText: boolean;
    resizeTextForBestFit: boolean;
    resizeTextMinSize: number;
    resizeTextMaxSize: number;
    alignment: TextAnchor;
    alignByGeometry: boolean;
    fontSize: number;
    horizontalOverflow: HorizontalWrapMode;
    verticalOverflow: VerticalWrapMode;
    lineSpacing: number;
    fontStyle: FontStyle;
    readonly pixelsPerUnit: number;
    readonly minWidth: number;
    readonly preferredWidth: number;
    readonly flexibleWidth: number;
    readonly minHeight: number;
    readonly preferredHeight: number;
    readonly flexibleHeight: number;
    readonly layoutPriority: number;



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    FontTextureChanged(): void;
    GetGenerationSettings(extents: Vector2): TextGenerationSettings;
    OnRebuildRequested(): void;


}
    
interface TextGenerator {
    readonly characterCountVisible: number;
    readonly verts: CSArray<UIVertex>;
    readonly characters: CSArray<UICharInfo>;
    readonly lines: CSArray<UILineInfo>;
    readonly rectExtents: Rect;
    readonly vertexCount: number;
    readonly characterCount: number;
    readonly lineCount: number;
    readonly fontSizeUsedForBestFit: number;



    GetCharacters(characters: CSArray<UICharInfo>): void;
    GetCharactersArray(): CSArray<UICharInfo>;
    GetLines(lines: CSArray<UILineInfo>): void;
    GetLinesArray(): CSArray<UILineInfo>;
    GetPreferredHeight(str: string, settings: TextGenerationSettings): number;
    GetPreferredWidth(str: string, settings: TextGenerationSettings): number;
    GetVertices(vertices: CSArray<UIVertex>): void;
    GetVerticesArray(): CSArray<UIVertex>;
    Invalidate(): void;
    Populate(str: string, settings: TextGenerationSettings): boolean;
    PopulateWithErrors(str: string, settings: TextGenerationSettings, context: GameObject): boolean;


}
    
interface UICharInfo {
    cursorPos: Vector2;
    charWidth: number;





}
    
interface UILineInfo {
    startCharIdx: number;
    height: number;
    topY: number;
    leading: number;





}
    
interface TextGenerationSettings {
    font: Font;
    color: Color;
    fontSize: number;
    lineSpacing: number;
    richText: boolean;
    scaleFactor: number;
    fontStyle: FontStyle;
    textAnchor: TextAnchor;
    alignByGeometry: boolean;
    resizeTextForBestFit: boolean;
    resizeTextMinSize: number;
    resizeTextMaxSize: number;
    updateBounds: boolean;
    verticalOverflow: VerticalWrapMode;
    horizontalOverflow: HorizontalWrapMode;
    generationExtents: Vector2;
    pivot: Vector2;
    generateOutOfBounds: boolean;



    Equals(other: TextGenerationSettings): boolean;


}
    
interface TextGeneratorConstructor {


    new(): TextGenerator;
    new(initialCapacity: number): TextGenerator;



}
declare const TextGenerator: TextGeneratorConstructor;
    
interface TextConstructor {




    GetTextAnchorPivot(anchor: TextAnchor): Vector2;

}
declare const Text: TextConstructor;
    
interface OptionData {
    text: string;
    image: Sprite;





}
    
interface OptionDataConstructor {


    new(): OptionData;
    new(text: string): OptionData;
    new(image: Sprite): OptionData;
    new(text: string, image: Sprite): OptionData;



}
declare const OptionData: OptionDataConstructor;
    
interface TMP_Dropdown extends Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler {
    template: RectTransform;
    captionText: TMP_Text;
    captionImage: Image;
    placeholder: Graphic;
    itemText: TMP_Text;
    itemImage: Image;
    options: CSArray<OptionData>;
    alphaFadeSpeed: number;
    value: number;
    readonly IsExpanded: boolean;
    MultiSelect: boolean;

    readonly onValueChanged: MonoSignal<void>;


    AddOptions(options: CSArray<OptionData>): void;
    AddOptions(options: CSArray<string>): void;
    AddOptions(options: CSArray<Sprite>): void;
    ClearOptions(): void;
    Hide(): void;
    OnCancel(eventData: BaseEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    RefreshShownValue(): void;
    SetValueWithoutNotify(input: number): void;
    Show(): void;


}
    
interface OptionData {
    text: string;
    image: Sprite;
    color: Color;





}
    
interface OptionDataConstructor {


    new(): OptionData;
    new(text: string): OptionData;
    new(image: Sprite): OptionData;
    new(text: string, image: Sprite, color: Color): OptionData;



}
declare const OptionData: OptionDataConstructor;
    
interface CanvasHitDetector extends MonoBehaviour {



    IsPointerOverTarget(target: GameObject): boolean;
    IsPointerOverUI(): boolean;


}
    
interface CanvasHitDetectorConstructor {


    new(): CanvasHitDetector;



}
declare const CanvasHitDetector: CanvasHitDetectorConstructor;
    
interface AudioBehaviour extends Behaviour {





}
    
interface AudioBehaviourConstructor {


    new(): AudioBehaviour;



}
declare const AudioBehaviour: AudioBehaviourConstructor;
    
interface AudioSource extends AudioBehaviour {
    volume: number;
    pitch: number;
    time: number;
    timeSamples: number;
    clip: AudioClip;
    resource: AudioResource;
    outputAudioMixerGroup: AudioMixerGroup;
    gamepadSpeakerOutputType: GamepadSpeakerOutputType;
    readonly isPlaying: boolean;
    readonly isVirtual: boolean;
    loop: boolean;
    ignoreListenerVolume: boolean;
    playOnAwake: boolean;
    ignoreListenerPause: boolean;
    velocityUpdateMode: AudioVelocityUpdateMode;
    panStereo: number;
    spatialBlend: number;
    spatialize: boolean;
    spatializePostEffects: boolean;
    reverbZoneMix: number;
    bypassEffects: boolean;
    bypassListenerEffects: boolean;
    bypassReverbZones: boolean;
    dopplerLevel: number;
    spread: number;
    priority: number;
    mute: boolean;
    minDistance: number;
    maxDistance: number;
    rolloffMode: AudioRolloffMode;



    DisableGamepadOutput(): boolean;
    GetAmbisonicDecoderFloat(index: number, value: unknown): boolean;
    GetCustomCurve(type: AudioSourceCurveType): AnimationCurve;
    GetOutputData(samples: CSArray<number>, channel: number): void;
    GetSpatializerFloat(index: number, value: unknown): boolean;
    GetSpectrumData(samples: CSArray<number>, channel: number, window: FFTWindow): void;
    Pause(): void;
    Play(): void;
    Play(delay: number): void;
    PlayDelayed(delay: number): void;
    PlayOneShot(clip: AudioClip): void;
    PlayOneShot(clip: AudioClip, volumeScale: number): void;
    PlayOnGamepad(slot: number): boolean;
    PlayScheduled(time: number): void;
    SetAmbisonicDecoderFloat(index: number, value: number): boolean;
    SetCustomCurve(type: AudioSourceCurveType, curve: AnimationCurve): void;
    SetGamepadSpeakerMixLevel(slot: number, mixLevel: number): boolean;
    SetGamepadSpeakerMixLevelDefault(slot: number): boolean;
    SetGamepadSpeakerRestrictedAudio(slot: number, restricted: boolean): boolean;
    SetScheduledEndTime(time: number): void;
    SetScheduledStartTime(time: number): void;
    SetSpatializerFloat(index: number, value: number): boolean;
    Stop(): void;
    UnPause(): void;


}
    
interface AudioResource extends Object {





}
    
interface AudioClip extends AudioResource {
    readonly length: number;
    readonly samples: number;
    readonly channels: number;
    readonly frequency: number;
    readonly loadType: AudioClipLoadType;
    readonly preloadAudioData: boolean;
    readonly ambisonic: boolean;
    readonly loadInBackground: boolean;
    readonly loadState: AudioDataLoadState;



    GetData(data: unknown, offsetSamples: number): boolean;
    GetData(data: CSArray<number>, offsetSamples: number): boolean;
    LoadAudioData(): boolean;
    SetData(data: CSArray<number>, offsetSamples: number): boolean;
    SetData(data: unknown, offsetSamples: number): boolean;
    UnloadAudioData(): boolean;


}
    
interface PCMReaderCallback {



    BeginInvoke(data: CSArray<number>, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(data: CSArray<number>): void;


}
    
interface PCMReaderCallbackConstructor {


    new(object: unknown, method: unknown): PCMReaderCallback;



}
declare const PCMReaderCallback: PCMReaderCallbackConstructor;
    
interface PCMSetPositionCallback {



    BeginInvoke(position: number, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(position: number): void;


}
    
interface PCMSetPositionCallbackConstructor {


    new(object: unknown, method: unknown): PCMSetPositionCallback;



}
declare const PCMSetPositionCallback: PCMSetPositionCallbackConstructor;
    
interface AudioClipConstructor {




    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;

}
declare const AudioClip: AudioClipConstructor;
    
interface ISubAssetNotDuplicatable {





}
    
interface AudioMixerGroup extends Object, ISubAssetNotDuplicatable {
    readonly audioMixer: AudioMixer;





}
    
interface AudioMixer extends Object {
    outputAudioMixerGroup: AudioMixerGroup;
    updateMode: AudioMixerUpdateMode;



    ClearFloat(name: string): boolean;
    FindMatchingGroups(subPath: string): CSArray<AudioMixerGroup>;
    FindSnapshot(name: string): AudioMixerSnapshot;
    GetFloat(name: string, value: unknown): boolean;
    SetFloat(name: string, value: number): boolean;
    TransitionToSnapshots(snapshots: CSArray<AudioMixerSnapshot>, weights: CSArray<number>, timeToReach: number): void;


}
    
interface AudioMixerSnapshot extends Object, ISubAssetNotDuplicatable {
    readonly audioMixer: AudioMixer;



    TransitionTo(timeToReach: number): void;


}
    
interface AudioSourceConstructor {


    new(): AudioSource;


    GamepadSpeakerSupportsOutputType(outputType: GamepadSpeakerOutputType): boolean;
    PlayClipAtPoint(clip: AudioClip, position: Vector3): void;
    PlayClipAtPoint(clip: AudioClip, position: Vector3, volume: number): void;

}
declare const AudioSource: AudioSourceConstructor;
    
interface ITween {



    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;


}
    
interface Tween<DriverValueType> extends MonoBehaviour, ITween {



    Await(): void;
    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;
    OnGetFrom(): DriverValueType;
    OnInitialize(): boolean;
    OnUpdate(easedTime: number): void;
    SetDelay(delay: number, goToFirstFrameImmediately: boolean): Tween<DriverValueType>;
    SetEase(ease: EaseType): Tween<DriverValueType>;
    SetEaseBackIn(): Tween<DriverValueType>;
    SetEaseBackInOut(): Tween<DriverValueType>;
    SetEaseBackOut(): Tween<DriverValueType>;
    SetEaseBounceIn(): Tween<DriverValueType>;
    SetEaseBounceInOut(): Tween<DriverValueType>;
    SetEaseBounceOut(): Tween<DriverValueType>;
    SetEaseCircIn(): Tween<DriverValueType>;
    SetEaseCircInOut(): Tween<DriverValueType>;
    SetEaseCircOut(): Tween<DriverValueType>;
    SetEaseCubicIn(): Tween<DriverValueType>;
    SetEaseCubicInOut(): Tween<DriverValueType>;
    SetEaseCubicOut(): Tween<DriverValueType>;
    SetEaseElasticIn(): Tween<DriverValueType>;
    SetEaseElasticInOut(): Tween<DriverValueType>;
    SetEaseElasticOut(): Tween<DriverValueType>;
    SetEaseExpoIn(): Tween<DriverValueType>;
    SetEaseExpoInOut(): Tween<DriverValueType>;
    SetEaseExpoOut(): Tween<DriverValueType>;
    SetEaseLinear(): Tween<DriverValueType>;
    SetEaseQuadIn(): Tween<DriverValueType>;
    SetEaseQuadInOut(): Tween<DriverValueType>;
    SetEaseQuadOut(): Tween<DriverValueType>;
    SetEaseQuartIn(): Tween<DriverValueType>;
    SetEaseQuartInOut(): Tween<DriverValueType>;
    SetEaseQuartOut(): Tween<DriverValueType>;
    SetEaseQuintIn(): Tween<DriverValueType>;
    SetEaseQuintInOut(): Tween<DriverValueType>;
    SetEaseQuintOut(): Tween<DriverValueType>;
    SetEaseSineIn(): Tween<DriverValueType>;
    SetEaseSineInOut(): Tween<DriverValueType>;
    SetEaseSineOut(): Tween<DriverValueType>;
    SetInfinite(): Tween<DriverValueType>;
    SetLoopCount(loopCount: number): Tween<DriverValueType>;
    SetOvershooting(overshooting: number): Tween<DriverValueType>;
    SetPaused(isPaused: boolean): Tween<DriverValueType>;
    SetPingPong(): Tween<DriverValueType>;
    SetRandomTime(): Tween<DriverValueType>;
    SetTime(time: number): Tween<DriverValueType>;
    SetUseUnscaledTime(useUnscaledTime: boolean): Tween<DriverValueType>;
    Yield(): unknown;


}
    
interface Bridge {





}
    
interface IChatroomNetwork {
    readonly OwnID: number;
    readonly PeerIDs: CSArray<number>;

    readonly OnCreatedChatroom: MonoSignal<void>;
    readonly OnChatroomCreationFailed: MonoSignal<unknown>;
    readonly OnClosedChatroom: MonoSignal<void>;
    readonly OnJoinedChatroom: MonoSignal<number>;
    readonly OnChatroomJoinFailed: MonoSignal<unknown>;
    readonly OnLeftChatroom: MonoSignal<void>;
    readonly OnPeerJoinedChatroom: MonoSignal<number, number, AudioSource>;
    readonly OnPeerLeftChatroom: MonoSignal<number>;
    readonly OnAudioReceived: MonoSignal<number, ChatroomAudioSegment>;
    readonly OnAudioBroadcasted: MonoSignal<ChatroomAudioSegment>;


    BroadcastAudioSegment(data: ChatroomAudioSegment): void;
    CloseChatroom(data: unknown): void;
    HostChatroom(data: unknown): void;
    JoinChatroom(data: unknown): void;
    LeaveChatroom(data: unknown): void;


}
    
interface ChatroomAudioSegment {
    segmentIndex: number;
    frequency: number;
    channelCount: number;
    samples: CSArray<number>;





}
    
interface AirshipUniVoiceNetwork extends NetworkBehaviour, IChatroomNetwork {
    agent: ChatroomAgent;
    readonly OwnID: number;
    readonly PeerIDs: CSArray<number>;

    readonly OnCreatedChatroom: MonoSignal<void>;
    readonly OnChatroomCreationFailed: MonoSignal<unknown>;
    readonly OnClosedChatroom: MonoSignal<void>;
    readonly OnJoinedChatroom: MonoSignal<number>;
    readonly OnChatroomJoinFailed: MonoSignal<unknown>;
    readonly OnLeftChatroom: MonoSignal<void>;
    readonly OnPeerJoinedChatroom: MonoSignal<number, number, AudioSource>;
    readonly OnPeerLeftChatroom: MonoSignal<number>;
    readonly OnAudioReceived: MonoSignal<number, ChatroomAudioSegment>;
    readonly OnAudioBroadcasted: MonoSignal<ChatroomAudioSegment>;


    BroadcastAudioSegment(data: ChatroomAudioSegment): void;
    CloseChatroom(data: unknown): void;
    Dispose(): void;
    FromByteArray<T>(data: CSArray<number>): T;
    HostChatroom(data: unknown): void;
    JoinChatroom(data: unknown): void;
    LeaveChatroom(data: unknown): void;
    NetworkServer_OnDisconnected(connection: NetworkConnectionToClient): void;
    OnReadyCommand(conn: NetworkConnectionToClient): void;
    OnStartServer(): void;
    ToByteArray<T>(obj: T): CSArray<number>;
    Weaved(): boolean;


}
    
interface ChatroomAgent {
    PeerOutputs: CSDictionary<number, IAudioOutput>;
    OnModeChanged: unknown;
    PeerSettings: CSDictionary<number, ChatroomPeerSettings>;
    readonly Network: IChatroomNetwork;
    readonly AudioInput: IAudioInput;
    readonly AudioOutputFactory: IAudioOutputFactory;
    readonly CurrentMode: ChatroomAgentMode;
    MuteOthers: boolean;
    MuteSelf: boolean;



    Dispose(): void;


}
    
interface IAudioOutput {
    ID: string;



    Feed(segmentIndex: number, frequency: number, channelCount: number, audioSamples: CSArray<number>): void;
    Feed(segment: ChatroomAudioSegment): void;


}
    
interface ChatroomPeerSettings {
    muteThem: boolean;
    muteSelf: boolean;





}
    
interface ChatroomPeerSettingsConstructor {


    new(): ChatroomPeerSettings;



}
declare const ChatroomPeerSettings: ChatroomPeerSettingsConstructor;
    
interface IAudioInput {
    readonly Frequency: number;
    readonly ChannelCount: number;
    readonly SegmentRate: number;

    readonly OnSegmentReady: MonoSignal<number, CSArray<number>>;




}
    
interface IAudioOutputFactory {



    Create(frequency: number, channelCount: number, samplesLen: number, audioSource: AudioSource): IAudioOutput;


}
    
interface ChatroomAgentConstructor {


    new(chatroomNetwork: IChatroomNetwork, audioInput: IAudioInput, audioOutputFactory: IAudioOutputFactory): ChatroomAgent;



}
declare const ChatroomAgent: ChatroomAgentConstructor;
    
interface AirshipUniVoiceNetworkConstructor {


    new(): AirshipUniVoiceNetwork;



}
declare const AirshipUniVoiceNetwork: AirshipUniVoiceNetworkConstructor;
    
interface BridgeConstructor {




    ClearAllMaterials(ren: Renderer): void;
    ClearMaterial(ren: Renderer, materialI: number): void;
    CopyToClipboard(text: string): void;
    DownloadTexture2DYielding(url: string): Texture2D;
    GetActiveScene(): Scene;
    GetAirshipVoiceChatNetwork(): AirshipUniVoiceNetwork;
    GetAllocatedRam(): number;
    GetAverageFPS(): number;
    GetCurrentFPS(): number;
    GetCurrentMicDeviceIndex(): number;
    GetMicDevices(): CSArray<string>;
    GetMonoRam(): number;
    GetReservedRam(): number;
    GetScene(sceneName: string): Scene;
    GetScenes(): CSArray<Scene>;
    GetVolume(): number;
    HasMicrophonePermission(): boolean;
    IsFullScreen(): boolean;
    IsMicRecording(): boolean;
    LoadGlobalSceneByName(sceneName: string): void;
    LoadScene(sceneName: string, restartLuau: boolean, loadSceneMode: LoadSceneMode): void;
    LoadSceneAsyncFromAssetBundle(sceneName: string, loadSceneMode: LoadSceneMode): void;
    LoadSceneForConnection(conn: NetworkConnection, sceneName: string, makeActiveScene: boolean): void;
    MakeColorArray(size: number): CSArray<Color>;
    MakeDefaultRenderTexture(width: number, height: number): RenderTexture;
    MakeDefaultSprite(texture: Texture2D): Sprite;
    MakeDefaultTexture2D(width: number, height: number): Texture2D;
    MakeFloatArray(size: number): CSArray<number>;
    MakeIntArray(size: number): CSArray<number>;
    MakeMaterialPropertyBlock(): MaterialPropertyBlock;
    MakeMesh(): Mesh;
    MakeSprite(texture2D: Texture2D): Sprite;
    MakeSprite(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite;
    MakeTexture2D(width: number, height: number, format: TextureFormat, mipChain: boolean, linear: boolean): Texture2D;
    MakeVector3Array(size: number): CSArray<Vector3>;
    MoveGameObjectToScene(gameObject: GameObject, scene: Scene): void;
    OpenDevConsole(): void;
    RemoveRichText(input: string): string;
    RequestMicrophonePermissionAsync(): void;
    ScreenPointToLocalPointInRectangle(rectTransform: RectTransform, screenPoint: Vector2): Vector2;
    SetFullScreen(value: boolean): void;
    SetMicDeviceIndex(i: number): void;
    SetParentToSceneRoot(transform: Transform): void;
    SetVolume(volume: number): void;
    StartMicRecording(frequency: number, sampleLength: number): void;
    StopMicRecording(): void;
    UnloadGlobalSceneByName(sceneName: string): void;
    UnloadScene(sceneName: string): void;
    UnloadSceneForConnection(conn: NetworkConnection, sceneName: string): void;
    UpdateLayout(xform: Transform, recursive: boolean): void;

}
declare const Bridge: BridgeConstructor;
    
interface CanvasGroup extends Behaviour, ICanvasRaycastFilter {
    alpha: number;
    interactable: boolean;
    blocksRaycasts: boolean;
    ignoreParentGroups: boolean;



    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;


}
    
interface CanvasGroupConstructor {


    new(): CanvasGroup;



}
declare const CanvasGroup: CanvasGroupConstructor;
    
interface AutoShutdownBridge extends MonoBehaviour {



    SetBundlesLoaded(assetBundlesLoaded: boolean): void;


}
    
interface AutoShutdownBridgeConstructor {


    new(): AutoShutdownBridge;



}
declare const AutoShutdownBridge: AutoShutdownBridgeConstructor;
    
interface ScreenCapture {





}
    
interface ScreenCaptureConstructor {




    CaptureScreenshot(filename: string): void;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string, stereoCaptureMode: StereoScreenCaptureMode): void;
    CaptureScreenshotAsTexture(): Texture2D;
    CaptureScreenshotAsTexture(superSize: number): Texture2D;
    CaptureScreenshotAsTexture(stereoCaptureMode: StereoScreenCaptureMode): Texture2D;
    CaptureScreenshotIntoRenderTexture(renderTexture: RenderTexture): void;

}
declare const ScreenCapture: ScreenCaptureConstructor;
    
interface VoxelBlocks extends MonoBehaviour {
    maxResolution: number;
    atlasSize: number;
    pointFiltering: boolean;
    atlasMaterial: Material;
    atlas: TexturePacker;
    loadedBlocks: CSDictionary<number, BlockDefinition>;
    rootAssetPath: string;
    m_bundlePaths: CSArray<string>;
    blockDefinionLists: CSArray<VoxelBlockDefinionList>;



    AddSolidMaskToVoxelValue(voxelValue: number): number;
    GetBlock(index: number): BlockDefinition;
    GetBlockDefinitionByStringId(blockTypeId: string): BlockDefinition;
    GetBlockDefinitionFromBlockId(index: number): BlockDefinition;
    GetBlockIdFromStringId(stringId: string): number;
    GetStringIdFromBlockId(blockVoxelId: number): string;
    Load(loadTexturesDirectlyFromDisk: boolean): void;
    Reload(useTexturesDirectlyFromDisk: boolean): void;
    SearchForBlockIdByString(stringId: string): number;
    UpdateVoxelBlockId(voxelValue: number, blockId: number): number;


}
    
interface TexturePacker {
    diffuse: RenderTexture;
    normals: RenderTexture;



    Dispose(): void;
    GetUVs(sourceTexture: Texture2D): Rect;
    PackTextures(textures: CSDictionary<number, TextureSet>, desiredPadding: number, width: number, height: number, numMips: number, normalizedSize: number): void;


}
    
interface TextureSet {
    diffuse: Texture2D;
    normals: Texture2D;
    smoothTexture: Texture2D;
    metalTexture: Texture2D;
    emissiveTexture: Texture2D;
    smoothness: number;
    metallic: number;
    normalScale: number;
    emissive: number;
    brightness: number;





}
    
interface TextureSetConstructor {


    new(diffuse: Texture2D, normals: Texture2D, smoothTex: Texture2D, metalTex: Texture2D, emissiveTex: Texture2D, smoothness: number, metallic: number, normalScale: number, emissive: number, brightness: number): TextureSet;



}
declare const TextureSet: TextureSetConstructor;
    
interface TexturePackerConstructor {


    new(): TexturePacker;


    CustomBlit(renderTarget: RenderTexture, sourceTexture: Texture, material: Material, destX: number, destY: number, destWidth: number, destHeight: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number): void;
    DoPadding(target: RenderTexture, source: Texture2D, rect: Rect, pad: number, flipMaterial: Material): void;

}
declare const TexturePacker: TexturePackerConstructor;
    
interface BlockDefinition {
    definition: VoxelBlockDefinition;
    detail: boolean;
    doOcclusion: boolean;
    mesh: LodSet;
    meshTiles: CSArray<LodSet>;
    meshTileProcessingOrder: CSArray<number>;
    meshContexts: CSArray<CSArray<VoxelMeshCopy>>;
    meshContextsRandomTable: CSArray<number>;
    editorTexture: Texture2D;
    topUvs: Rect;
    bottomUvs: Rect;
    sideUvs: Rect;
    materials: CSArray<Material>;
    materialInstanceIds: CSArray<number>;
    meshMaterialInstanceId: number;
    minecraftConversions: CSArray<string>;
    blockId: number;
    blockTypeId: string;
    meshMaterial: Material;



    GetUvsForFace(i: number): Rect;


}
    
interface VoxelBlockDefinition extends ScriptableObject {
    blockName: string;
    description: string;
    contextStyle: ContextStyle;
    meshMaterial: Material;
    topTexture: TextureSet;
    sideTexture: TextureSet;
    bottomTexture: TextureSet;
    quarterBlockMeshes: CSArray<VoxelQuarterBlockMeshDefinition>;
    prefab: GameObject;
    staticMeshLOD0: GameObject;
    staticMeshLOD1: GameObject;
    staticMeshLOD2: GameObject;
    meshTile1x1x1: MeshSet;
    meshTile2x2x2: MeshSet;
    meshTile3x3x3: MeshSet;
    meshTile4x4x4: MeshSet;
    rotatedPlacement: boolean;
    metallic: number;
    smoothness: number;
    normalScale: number;
    emissive: number;
    brightness: number;
    solid: boolean;
    collisionType: CollisionType;
    randomRotation: boolean;
    minecraftIds: string;





}
    
interface TextureSet {
    material: Material;
    diffuse: Texture2D;
    normal: Texture2D;
    smooth: Texture2D;
    metallic: Texture2D;
    emissive: Texture2D;





}
    
interface TextureSetConstructor {


    new(): TextureSet;



}
declare const TextureSet: TextureSetConstructor;
    
interface VoxelQuarterBlockMeshDefinition extends ScriptableObject {
    UA: GameObject;
    UB: GameObject;
    UC: GameObject;
    UD: GameObject;
    UE: GameObject;
    UF: GameObject;
    UG: GameObject;
    UH: GameObject;
    UI: GameObject;
    UJ: GameObject;
    UK: GameObject;
    UL: GameObject;
    UM: GameObject;
    UN: GameObject;
    DA: GameObject;
    DB: GameObject;
    DC: GameObject;
    DD: GameObject;
    DE: GameObject;
    DF: GameObject;
    DG: GameObject;
    DH: GameObject;
    DI: GameObject;
    DJ: GameObject;
    DK: GameObject;
    DL: GameObject;
    DM: GameObject;
    DN: GameObject;
    probablity: number;



    GetQuarterBlockMesh(blockName: string): GameObject;


}
    
interface VoxelQuarterBlockMeshDefinitionConstructor {


    new(): VoxelQuarterBlockMeshDefinition;



}
declare const VoxelQuarterBlockMeshDefinition: VoxelQuarterBlockMeshDefinitionConstructor;
    
interface MeshSet {
    mesh_LOD0: GameObject;
    mesh_LOD1: GameObject;
    mesh_LOD2: GameObject;





}
    
interface MeshSetConstructor {


    new(): MeshSet;



}
declare const MeshSet: MeshSetConstructor;
    
interface VoxelBlockDefinitionConstructor {


    new(): VoxelBlockDefinition;



}
declare const VoxelBlockDefinition: VoxelBlockDefinitionConstructor;
    
interface LodSet {
    lod0: VoxelMeshCopy;
    lod1: VoxelMeshCopy;
    lod2: VoxelMeshCopy;





}
    
interface VoxelMeshCopy {
    quaternions: CSArray<unknown>;
    flip: CSArray<PrecalculatedFlip>;
    rotation: CSArray<PrecalculatedRotation>;
    srcUvs: CSArray<Vector2>;
    srcColors: CSArray<Color32>;
    srcVertices: CSArray<Vector3>;
    srcNormals: CSArray<Vector3>;
    surfaces: CSArray<Surface>;



    AdjustUVs(uvs: Rect): void;
    ApplyMaterial(meshMaterial: Material): void;


}
    
interface PrecalculatedFlip {
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    surfaces: CSArray<Surface>;





}
    
interface Surface {
    triangles: CSArray<number>;
    meshMaterial: Material;
    meshMaterialName: string;
    meshMaterialId: number;



    Clone(): Surface;
    Invert(): void;


}
    
interface SurfaceConstructor {


    new(triangles: CSArray<number>, material: Material, materialName: string, materialId: number): Surface;
    new(): Surface;



}
declare const Surface: SurfaceConstructor;
    
interface PrecalculatedFlipConstructor {


    new(srcVertices: CSArray<Vector3>, srcNormals: CSArray<Vector3>, srcSurfaces: CSArray<Surface>, flip: Flips): PrecalculatedFlip;



}
declare const PrecalculatedFlip: PrecalculatedFlipConstructor;
    
interface PrecalculatedRotation {
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;





}
    
interface PrecalculatedRotationConstructor {


    new(srcVertices: CSArray<Vector3>, srcNormals: CSArray<Vector3>, rot: Rotations, quat: Quaternion): PrecalculatedRotation;



}
declare const PrecalculatedRotation: PrecalculatedRotationConstructor;
    
interface VoxelMeshCopyConstructor {


    new(obj: GameObject): VoxelMeshCopy;
    new(src: VoxelMeshCopy): VoxelMeshCopy;
    new(assetPath: string, showError: boolean): VoxelMeshCopy;



}
declare const VoxelMeshCopy: VoxelMeshCopyConstructor;
    
interface LodSetConstructor {


    new(): LodSet;



}
declare const LodSet: LodSetConstructor;
    
interface BlockDefinitionConstructor {


    new(): BlockDefinition;



}
declare const BlockDefinition: BlockDefinitionConstructor;
    
interface VoxelBlockDefinionList extends ScriptableObject {
    scope: string;
    blockDefinitions: CSArray<VoxelBlockDefinition>;





}
    
interface VoxelBlockDefinionListConstructor {


    new(): VoxelBlockDefinionList;



}
declare const VoxelBlockDefinionList: VoxelBlockDefinionListConstructor;
    
    
    
interface VoxelBlocksConstructor {
    allTileSizes: CSArray<number>;
    meshTileOffsets: CSDictionary<number, Vector3>;
    meshTileSizes: CSDictionary<number, Vector3>;
    TileSizeNames: CSArray<string>;
    ContextBlockNames: CSArray<string>;
    QuarterBlockNames: CSArray<string>;
    QuarterBlockSubstitutions: CSArray<number>;


    new(): VoxelBlocks;


    GetRandomMeshContext(block: BlockDefinition): CSArray<VoxelMeshCopy>;
    GetRandomMeshContext(block: BlockDefinition, origin: Vector3, offset: number): CSArray<VoxelMeshCopy>;

}
declare const VoxelBlocks: VoxelBlocksConstructor;
    
interface CharacterController extends Collider {
    readonly velocity: Vector3;
    readonly isGrounded: boolean;
    readonly collisionFlags: CollisionFlags;
    radius: number;
    height: number;
    center: Vector3;
    slopeLimit: number;
    stepOffset: number;
    skinWidth: number;
    minMoveDistance: number;
    detectCollisions: boolean;
    enableOverlapRecovery: boolean;



    Move(motion: Vector3): CollisionFlags;
    SimpleMove(speed: Vector3): boolean;


}
    
interface CharacterControllerConstructor {


    new(): CharacterController;



}
declare const CharacterController: CharacterControllerConstructor;
    
interface TrailRenderer extends Renderer {
    time: number;
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    autodestruct: boolean;
    emitting: boolean;
    numCornerVertices: number;
    numCapVertices: number;
    minVertexDistance: number;
    startColor: Color;
    endColor: Color;
    readonly positionCount: number;
    textureScale: Vector2;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    maskInteraction: SpriteMaskInteraction;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;



    AddPosition(position: Vector3): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    Clear(): void;
    GetPosition(index: number): Vector3;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    SetPosition(index: number, position: Vector3): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;


}
    
interface TrailRendererConstructor {


    new(): TrailRenderer;



}
declare const TrailRenderer: TrailRendererConstructor;
    
interface WindowCore {





}
    
interface WindowProxy extends MonoBehaviour {

    readonly windowFocus: MonoSignal<void>;


    HasFocus(): boolean;


}
    
interface WindowProxyConstructor {


    new(): WindowProxy;



}
declare const WindowProxy: WindowProxyConstructor;
    
interface WindowCoreConstructor {
    Window: WindowProxy;




    SetWindowProxy(window: WindowProxy): void;

}
declare const WindowCore: WindowCoreConstructor;
    
interface CharacterMoveModifier {
    speedMultiplier: number;
    jumpMultiplier: number;
    blockSprint: boolean;
    blockJump: boolean;





}
    
interface CharacterMoveModifierConstructor {


    new(): CharacterMoveModifier;



}
declare const CharacterMoveModifier: CharacterMoveModifierConstructor;
    
interface MaterialColorURP extends MonoBehaviour {
    colorSettings: CSArray<ColorSetting>;
    addedByEditorScript: boolean;



    Clear(): void;
    DoUpdate(): void;
    EditorFirstTimeSetup(): void;
    GetColorSettingByMaterial(mat: Material): ColorSetting;
    InitializeColorsFromCurrentMaterials(): void;
    SetColor(indx: number, newColor: Color): void;
    SetColorOnAll(newColor: Color): void;


}
    
interface ColorSetting {
    baseColor: Color;
    reference: string;



    CopyFrom(otherSettings: ColorSetting): void;


}
    
interface ColorSettingConstructor {


    new(baseColor: Color): ColorSetting;



}
declare const ColorSetting: ColorSettingConstructor;
    
interface MaterialColorURPConstructor {


    new(): MaterialColorURP;



}
declare const MaterialColorURP: MaterialColorURPConstructor;
    
interface MainMenuLoadingScreen extends BundleLoadingScreen {
    canvas: Canvas;
    progressText: TMP_Text;
    continueButton: Button;
    spinner: GameObject;
    errorWrapper: GameObject;
    logo: RectTransform;
    errorText: TMP_Text;
    sceneManager: MainMenuSceneManager;
    mainContent: RectTransform;
    mainContentCanvasGroup: CanvasGroup;



    ClickContinueButton(): void;
    Close(): void;
    Retry(): void;
    SetError(msg: string): void;
    SetProgress(text: string, percent: number): void;
    SetTotalDownloadSize(sizeBytes: number): void;
    Show(): void;


}
    
interface MainMenuSceneManager extends MonoBehaviour {
    loadingScreen: MainMenuLoadingScreen;



    CheckForFailedStartup(): unknown;
    CompletedTSLoad(): void;
    Retry(): void;


}
    
interface PackageVersionResponse {
    package: Package;





}
    
interface Package {
    assetVersionNumber: number;
    codeVersionNumber: number;
<<<<<<< HEAD
    publishVersionNumber: number;
||||||| e514c4dd7
=======
    publishNumber: number;
>>>>>>> 2de4af93bc0b321ad68833f192effe6f9c5e2949





}
    
interface PackageConstructor {


    new(): Package;



}
declare const Package: PackageConstructor;
    
interface PackageVersionResponseConstructor {


    new(): PackageVersionResponse;



}
declare const PackageVersionResponse: PackageVersionResponseConstructor;
    
interface IPromise<PromisedT> {
    readonly Id: number;



    Catch(onRejected: unknown): IPromise;
    Catch(onRejected: unknown): IPromise<PromisedT>;
    ContinueWith(onResolved: unknown): IPromise;
    ContinueWith<ConvertedT>(onComplete: unknown): IPromise<ConvertedT>;
    Done(onResolved: unknown, onRejected: unknown): void;
    Done(onResolved: unknown): void;
    Done(): void;
    Finally(onComplete: unknown): IPromise<PromisedT>;
    Progress(onProgress: unknown): IPromise<PromisedT>;
    Then<ConvertedT>(onResolved: unknown): IPromise<ConvertedT>;
    Then(onResolved: unknown): IPromise;
    Then(onResolved: unknown): IPromise;
    Then<ConvertedT>(onResolved: unknown, onRejected: unknown): IPromise<ConvertedT>;
    Then(onResolved: unknown, onRejected: unknown): IPromise;
    Then(onResolved: unknown, onRejected: unknown): IPromise;
    Then<ConvertedT>(onResolved: unknown, onRejected: unknown, onProgress: unknown): IPromise<ConvertedT>;
    Then(onResolved: unknown, onRejected: unknown, onProgress: unknown): IPromise;
    Then(onResolved: unknown, onRejected: unknown, onProgress: unknown): IPromise;
    Then<ConvertedT>(transform: unknown): IPromise<ConvertedT>;
    ThenAll<ConvertedT>(chain: unknown): IPromise<CSArray<ConvertedT>>;
    ThenAll(chain: unknown): IPromise;
    ThenRace<ConvertedT>(chain: unknown): IPromise<ConvertedT>;
    ThenRace(chain: unknown): IPromise;
    WithName(name: string): IPromise<PromisedT>;


}
    
interface IPromise {
    readonly Id: number;



    Catch(onRejected: unknown): IPromise;
    ContinueWith(onResolved: unknown): IPromise;
    ContinueWith<ConvertedT>(onComplete: unknown): IPromise<ConvertedT>;
    Done(onResolved: unknown, onRejected: unknown): void;
    Done(onResolved: unknown): void;
    Done(): void;
    Finally(onComplete: unknown): IPromise;
    Progress(onProgress: unknown): IPromise;
    Then<ConvertedT>(onResolved: unknown): IPromise<ConvertedT>;
    Then(onResolved: unknown): IPromise;
    Then(onResolved: unknown): IPromise;
    Then<ConvertedT>(onResolved: unknown, onRejected: unknown): IPromise<ConvertedT>;
    Then(onResolved: unknown, onRejected: unknown): IPromise;
    Then(onResolved: unknown, onRejected: unknown): IPromise;
    Then<ConvertedT>(onResolved: unknown, onRejected: unknown, onProgress: unknown): IPromise<ConvertedT>;
    Then(onResolved: unknown, onRejected: unknown, onProgress: unknown): IPromise;
    Then(onResolved: unknown, onRejected: unknown, onProgress: unknown): IPromise;
    ThenAll(chain: unknown): IPromise;
    ThenAll<ConvertedT>(chain: unknown): IPromise<CSArray<ConvertedT>>;
    ThenRace(chain: unknown): IPromise;
    ThenRace<ConvertedT>(chain: unknown): IPromise<ConvertedT>;
    ThenSequence(chain: unknown): IPromise;
    WithName(name: string): IPromise;


}
    
interface MainMenuSceneManagerConstructor {


    new(): MainMenuSceneManager;


    GetLatestPackageVersion(packageId: string): IPromise<PackageVersionResponse>;

}
declare const MainMenuSceneManager: MainMenuSceneManagerConstructor;
    
interface MainMenuLoadingScreenConstructor {


    new(): MainMenuLoadingScreen;



}
declare const MainMenuLoadingScreen: MainMenuLoadingScreenConstructor;
    
interface HttpManager {





}
    
interface HttpResponse {
    success: boolean;
    data: string;
    error: string;
    statusCode: number;
    headers: CSDictionary<string, string>;



    GetHeader(headerName: string): string;


}
    
interface RequestHelper {
    Uri: string;
    Method: string;
    Body: unknown;
    BodyString: string;
    BodyRaw: CSArray<number>;
    Timeout?: number;
    ContentType: string;
    Retries: number;
    RetrySecondsDelay: number;
    RetryCallbackOnlyOnNetworkErrors: boolean;
    RetryCallback: unknown;
    ProgressCallback: unknown;
    EnableDebug: boolean;
    UseHttpContinue?: boolean;
    RedirectLimit?: number;
    IgnoreHttpException: boolean;
    FormData: WWWForm;
    SimpleForm: CSDictionary<string, string>;
    FormSections: CSArray<IMultipartFormSection>;
    CertificateHandler: CertificateHandler;
    UploadHandler: UploadHandler;
    DownloadHandler: DownloadHandler;
    Headers: CSDictionary<string, string>;
    Params: CSDictionary<string, string>;
    ParseResponseBody: boolean;
    Request: UnityWebRequest;
    readonly UploadProgress: number;
    readonly UploadedBytes: number;
    readonly DownloadProgress: number;
    readonly DownloadedBytes: number;
    IsAborted: boolean;
    DefaultContentType: boolean;



    Abort(): void;
    GetHeader(name: string): string;


}
    
interface WWWForm {
    readonly headers: CSDictionary<string, string>;
    readonly data: CSArray<number>;



    AddBinaryData(fieldName: string, contents: CSArray<number>): void;
    AddBinaryData(fieldName: string, contents: CSArray<number>, fileName: string): void;
    AddBinaryData(fieldName: string, contents: CSArray<number>, fileName: string, mimeType: string): void;
    AddField(fieldName: string, value: string): void;
    AddField(fieldName: string, value: string, e: unknown): void;
    AddField(fieldName: string, i: number): void;


}
    
interface WWWFormConstructor {


    new(): WWWForm;



}
declare const WWWForm: WWWFormConstructor;
    
interface IMultipartFormSection {
    readonly sectionName: string;
    readonly sectionData: CSArray<number>;
    readonly fileName: string;
    readonly contentType: string;





}
    
interface CertificateHandler {



    Dispose(): void;


}
    
interface UploadHandler {
    readonly data: CSArray<number>;
    contentType: string;
    readonly progress: number;



    Dispose(): void;


}
    
interface DownloadHandler {
    readonly isDone: boolean;
    readonly error: string;
    readonly nativeData: CSArray<number>;
    readonly data: CSArray<number>;
    readonly text: string;



    Dispose(): void;


}
    
interface UnityWebRequest {
    disposeCertificateHandlerOnDispose: boolean;
    disposeDownloadHandlerOnDispose: boolean;
    disposeUploadHandlerOnDispose: boolean;
    method: string;
    readonly error: string;
    useHttpContinue: boolean;
    url: string;
    uri: unknown;
    readonly responseCode: number;
    readonly uploadProgress: number;
    readonly isModifiable: boolean;
    readonly isDone: boolean;
    readonly result: Result;
    readonly downloadProgress: number;
    readonly uploadedBytes: number;
    readonly downloadedBytes: number;
    redirectLimit: number;
    uploadHandler: UploadHandler;
    downloadHandler: DownloadHandler;
    certificateHandler: CertificateHandler;
    timeout: number;



    Abort(): void;
    Dispose(): void;
    GetRequestHeader(name: string): string;
    GetResponseHeader(name: string): string;
    GetResponseHeaders(): CSDictionary<string, string>;
    SendWebRequest(): UnityWebRequestAsyncOperation;
    SetRequestHeader(name: string, value: string): void;


}
    
interface UnityWebRequestAsyncOperation extends AsyncOperation {
    readonly webRequest: UnityWebRequest;





}
    
interface UnityWebRequestAsyncOperationConstructor {


    new(): UnityWebRequestAsyncOperation;



}
declare const UnityWebRequestAsyncOperation: UnityWebRequestAsyncOperationConstructor;
    
interface UnityWebRequestConstructor {
    kHttpVerbGET: string;
    kHttpVerbHEAD: string;
    kHttpVerbPOST: string;
    kHttpVerbPUT: string;
    kHttpVerbCREATE: string;
    kHttpVerbDELETE: string;


    new(): UnityWebRequest;
    new(url: string): UnityWebRequest;
    new(uri: unknown): UnityWebRequest;
    new(url: string, method: string): UnityWebRequest;
    new(uri: unknown, method: string): UnityWebRequest;
    new(url: string, method: string, downloadHandler: DownloadHandler, uploadHandler: UploadHandler): UnityWebRequest;
    new(uri: unknown, method: string, downloadHandler: DownloadHandler, uploadHandler: UploadHandler): UnityWebRequest;


    ClearCookieCache(): void;
    ClearCookieCache(uri: unknown): void;
    Delete(uri: string): UnityWebRequest;
    Delete(uri: unknown): UnityWebRequest;
    EscapeURL(s: string): string;
    EscapeURL(s: string, e: unknown): string;
    GenerateBoundary(): CSArray<number>;
    Get(uri: string): UnityWebRequest;
    Get(uri: unknown): UnityWebRequest;
    Head(uri: string): UnityWebRequest;
    Head(uri: unknown): UnityWebRequest;
    Post(uri: string, postData: string, contentType: string): UnityWebRequest;
    Post(uri: unknown, postData: string, contentType: string): UnityWebRequest;
    Post(uri: string, formData: WWWForm): UnityWebRequest;
    Post(uri: unknown, formData: WWWForm): UnityWebRequest;
    Post(uri: string, multipartFormSections: CSArray<IMultipartFormSection>): UnityWebRequest;
    Post(uri: unknown, multipartFormSections: CSArray<IMultipartFormSection>): UnityWebRequest;
    Post(uri: string, multipartFormSections: CSArray<IMultipartFormSection>, boundary: CSArray<number>): UnityWebRequest;
    Post(uri: unknown, multipartFormSections: CSArray<IMultipartFormSection>, boundary: CSArray<number>): UnityWebRequest;
    Post(uri: string, formFields: CSDictionary<string, string>): UnityWebRequest;
    Post(uri: unknown, formFields: CSDictionary<string, string>): UnityWebRequest;
    PostWwwForm(uri: string, form: string): UnityWebRequest;
    PostWwwForm(uri: unknown, form: string): UnityWebRequest;
    Put(uri: string, bodyData: CSArray<number>): UnityWebRequest;
    Put(uri: unknown, bodyData: CSArray<number>): UnityWebRequest;
    Put(uri: string, bodyData: string): UnityWebRequest;
    Put(uri: unknown, bodyData: string): UnityWebRequest;
    SerializeFormSections(multipartFormSections: CSArray<IMultipartFormSection>, boundary: CSArray<number>): CSArray<number>;
    SerializeSimpleForm(formFields: CSDictionary<string, string>): CSArray<number>;
    UnEscapeURL(s: string): string;
    UnEscapeURL(s: string, e: unknown): string;

}
declare const UnityWebRequest: UnityWebRequestConstructor;
    
interface RequestHelperConstructor {


    new(): RequestHelper;



}
declare const RequestHelper: RequestHelperConstructor;
    
interface HttpManagerConstructor {
    loggingEnabled: boolean;


    new(): HttpManager;


    DeleteAsync(url: string): HttpResponse;
    DeleteAsync(url: string, headers: string): HttpResponse;
    GetAsync(url: string, headers: string): HttpResponse;
    GetAsync(url: string): HttpResponse;
    PatchAsync(url: string, data: string): HttpResponse;
    PatchAsync(url: string, data: string, headers: string): HttpResponse;
    PostAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string, data: string, headers: string): HttpResponse;
    PutAsync(url: string, data: string): HttpResponse;
    PutAsync(url: string, data: string, headers: string): HttpResponse;
    PutAsync(options: RequestHelper, headers: string): HttpResponse;
    SetLoggingEnabled(val: boolean): void;

}
declare const HttpManager: HttpManagerConstructor;
    
interface InternalHttpManager {





}

interface InternalHttpManagerConstructor {
    editorUserId: string;
    editorAuthToken: string;
    authToken: string;




    DeleteAsync(url: string): HttpResponse;
    GetAsync(url: string): HttpResponse;
    GetAsyncWithHeaders(url: string, headers: string): HttpResponse;
    PatchAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string): HttpResponse;
    PutAsync(url: string, data: string): HttpResponse;
    PutImageAsync(url: string, filePath: string): HttpResponse;
    SetAuthToken(authToken: string): void;
    SetEditorAuthToken(authToken: string): void;

}
declare const InternalHttpManager: InternalHttpManagerConstructor;
    
interface CrossSceneState {





}
    
interface ServerTransferData {
    address: string;
    port: number;
    gameId: string;
    loadingImageUrl: string;





}
    
interface ServerTransferDataConstructor {


    new(): ServerTransferData;



}
declare const ServerTransferData: ServerTransferDataConstructor;
    
interface CrossSceneStateConstructor {
    ServerTransferData: ServerTransferData;
    UseLocalBundles: boolean;
    kickMessage: string;
    disconnectKicked: boolean;




    IsLocalServer(): boolean;

}
declare const CrossSceneState: CrossSceneStateConstructor;
    
interface Toggle extends Selectable, ISubmitHandler, IPointerClickHandler, ICanvasElement {
    toggleTransition: ToggleTransition;
    graphic: Graphic;
    group: ToggleGroup;
    isOn: boolean;



    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetIsOnWithoutNotify(value: boolean): void;


}
    
interface ToggleGroup extends UIBehaviour {
    allowSwitchOff: boolean;



    ActiveToggles(): CSArray<Toggle>;
    AnyTogglesOn(): boolean;
    EnsureValidState(): void;
    GetFirstActiveToggle(): Toggle;
    NotifyToggleOn(toggle: Toggle, sendCallback: boolean): void;
    RegisterToggle(toggle: Toggle): void;
    SetAllTogglesOff(sendCallback: boolean): void;
    UnregisterToggle(toggle: Toggle): void;


}
    
interface ILayoutController {



    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface ILayoutGroup extends ILayoutController {





}
    
interface LayoutGroup extends UIBehaviour, ILayoutGroup, ILayoutElement {
    padding: RectOffset;
    childAlignment: TextAnchor;
    readonly minWidth: number;
    readonly preferredWidth: number;
    readonly flexibleWidth: number;
    readonly minHeight: number;
    readonly preferredHeight: number;
    readonly flexibleHeight: number;
    readonly layoutPriority: number;



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface RectOffset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    readonly horizontal: number;
    readonly vertical: number;



    Add(rect: Rect): Rect;
    Remove(rect: Rect): Rect;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;


}
    
interface RectOffsetConstructor {


    new(): RectOffset;
    new(left: number, right: number, top: number, bottom: number): RectOffset;



}
declare const RectOffset: RectOffsetConstructor;
    
interface HorizontalOrVerticalLayoutGroup extends LayoutGroup {
    spacing: number;
    childForceExpandWidth: boolean;
    childForceExpandHeight: boolean;
    childControlWidth: boolean;
    childControlHeight: boolean;
    childScaleWidth: boolean;
    childScaleHeight: boolean;
    reverseArrangement: boolean;





}
    
interface HorizontalLayoutGroup extends HorizontalOrVerticalLayoutGroup {



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface VerticalLayoutGroup extends HorizontalOrVerticalLayoutGroup {



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface ILayoutSelfController extends ILayoutController {





}
    
interface ContentSizeFitter extends UIBehaviour, ILayoutSelfController {
    horizontalFit: FitMode;
    verticalFit: FitMode;



    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface AspectRatioFitter extends UIBehaviour, ILayoutSelfController {
    aspectMode: AspectMode;
    aspectRatio: number;



    IsAspectModeValid(): boolean;
    IsComponentValidOnObject(): boolean;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface LayoutRebuilder extends ICanvasElement {
    readonly transform: Transform;



    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;
    ToString(): string;


}
    
interface LayoutRebuilderConstructor {


    new(): LayoutRebuilder;


    ForceRebuildLayoutImmediate(layoutRoot: RectTransform): void;
    MarkLayoutForRebuild(rect: RectTransform): void;

}
declare const LayoutRebuilder: LayoutRebuilderConstructor;
    
interface RectTransformUtility {





}
    
interface RectTransformUtilityConstructor {




    CalculateRelativeRectTransformBounds(root: Transform, child: Transform): Bounds;
    CalculateRelativeRectTransformBounds(trans: Transform): Bounds;
    FlipLayoutAxes(rect: RectTransform, keepPositioning: boolean, recursive: boolean): void;
    FlipLayoutOnAxis(rect: RectTransform, axis: number, keepPositioning: boolean, recursive: boolean): void;
    PixelAdjustPoint(point: Vector2, elementTransform: Transform, canvas: Canvas): Vector2;
    PixelAdjustRect(rectTransform: RectTransform, canvas: Canvas): Rect;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2): boolean;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2, cam: Camera): boolean;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2, cam: Camera, offset: Vector4): boolean;
    ScreenPointToLocalPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, localPoint: unknown): boolean;
    ScreenPointToRay(cam: Camera, screenPos: Vector2): Ray;
    ScreenPointToWorldPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, worldPoint: unknown): boolean;
    WorldToScreenPoint(cam: Camera, worldPoint: Vector3): Vector2;

}
declare const RectTransformUtility: RectTransformUtilityConstructor;
    
interface ScrollRect extends UIBehaviour, ILayoutGroup, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, ILayoutElement {
    content: RectTransform;
    horizontal: boolean;
    vertical: boolean;
    movementType: MovementType;
    elasticity: number;
    inertia: boolean;
    decelerationRate: number;
    scrollSensitivity: number;
    viewport: RectTransform;
    horizontalScrollbar: Scrollbar;
    verticalScrollbar: Scrollbar;
    horizontalScrollbarVisibility: ScrollbarVisibility;
    verticalScrollbarVisibility: ScrollbarVisibility;
    horizontalScrollbarSpacing: number;
    verticalScrollbarSpacing: number;
    velocity: Vector2;
    normalizedPosition: Vector2;
    horizontalNormalizedPosition: number;
    verticalNormalizedPosition: number;
    readonly minWidth: number;
    readonly preferredWidth: number;
    readonly flexibleWidth: number;
    readonly minHeight: number;
    readonly preferredHeight: number;
    readonly flexibleHeight: number;
    readonly layoutPriority: number;

    readonly onValueChanged: MonoSignal<void>;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    GraphicUpdateComplete(): void;
    IsActive(): boolean;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnScroll(data: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
    StopMovement(): void;


}
    
interface CameraScreenshotRecorder extends MonoBehaviour {
    saveFolder: SaveFolder;
    shouldSaveCaptures: boolean;
    resWidth: number;
    resHeight: number;
    readonly FolderName: string;



    SaveRenderTexture(rt: RenderTexture, fileName: string, png: boolean): CameraScreenshotResponse;
    SaveTexture(texture: Texture2D, fileName: string, png: boolean): CameraScreenshotResponse;
    ScreenShotName(width: number, height: number, png: boolean): string;
    ScreenShotName(filename: string, png: boolean): string;
    TakeCameraScreenshot(camera: Camera, fileName: string, superSampleSize: number): void;
    TakeCameraScreenshotCo(camera: Camera, fileName: string, superSampleSize: number): unknown;
    TakeScreenshot(fileName: string, superSampleSize: number, png: boolean): void;


}
    
interface CameraScreenshotResponse {
    path: string;
    filesize: number;
    extension: string;





}
    
interface CameraScreenshotResponseConstructor {


    new(): CameraScreenshotResponse;



}
declare const CameraScreenshotResponse: CameraScreenshotResponseConstructor;
    
interface OnPictureTaken {



    BeginInvoke(screenshot: Texture2D, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(screenshot: Texture2D): void;


}
    
interface OnPictureTakenConstructor {


    new(object: unknown, method: unknown): OnPictureTaken;



}
declare const OnPictureTaken: OnPictureTakenConstructor;
    
interface CameraScreenshotRecorderConstructor {
    onPictureTaken: OnPictureTaken;
    readonly GetScreenshotTexture: Texture2D;


    new(): CameraScreenshotRecorder;



}
declare const CameraScreenshotRecorder: CameraScreenshotRecorderConstructor;
    
interface DevConsole {





}
    
interface DevConsoleMono extends MonoBehaviour {
    bottom: GameObject;
    activeContext: LogContext;



    ClearActiveConsoleContext(): void;
    CloseConsole(): void;
    OnClientTabClick(): void;
    OnLogMessageCallback(logString: string, stackTrace: string, type: LogType): void;
    OnLogMessageReceived(logString: string, stackTrace: string, type: LogType, context: LogContext, time: string, prepend: boolean): void;
    OnRepositionButtonPointerDown(eventData: BaseEventData): void;
    OnRepositionButtonPointerUp(_: BaseEventData): void;
    OnServerTabClick(): void;
    OpenLogsFolder(): void;
    SetActiveContext(context: LogContext): void;


}
    
interface DevConsoleMonoConstructor {


    new(): DevConsoleMono;



}
declare const DevConsoleMono: DevConsoleMonoConstructor;
    
interface Command {
    readonly Name: string;
    readonly HelpText: string;
    readonly IsCustomCommand: boolean;



    GetAliases(): CSArray<string>;
    GetFormattedName(): string;
    GetFormattedParameter(parameterIndex: number): string;
    GetParameters(): CSArray<Parameter>;
    ToFormattedString(): string;
    ToString(): string;


}
    
interface Parameter {
    readonly Type: unknown;
    readonly FriendlyTypeName: string;
    readonly Name: string;
    readonly HelpText: string;



    ToFormattedString(): string;
    ToString(): string;


}
    
interface ParameterConstructor {




    Create(name: string, helpText: string): Parameter;

}
declare const Parameter: ParameterConstructor;
    
interface CommandConstructor {




    Create(name: string, aliases: string, helpText: string, callback: unknown): Command;
    Create<T1>(name: string, aliases: string, helpText: string, p1: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3, T4>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, p4: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3, T4, T5>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, p4: Parameter, p5: Parameter, callback: unknown, defaultCallback: unknown): Command;

}
declare const Command: CommandConstructor;
    
interface DevConsoleConstructor {
    console: DevConsoleMono;
    clearConsoleOnServerConnect: boolean;
    IsEnabled: boolean;
    IsOpen: boolean;
    readonly IsOpenAndFocused: boolean;
    IsKeyBindingsEnabled: boolean;
    ToggleKey?: Key;
    readonly AverageFps: number;
    readonly AverageMs: number;




    AddCommand(command: Command, onlyInDevBuild: boolean): boolean;
    AddParameterType<T>(parseFunc: unknown): boolean;
    ClearActiveConsoleContext(): void;
    ClearConsole(): void;
    CloseConsole(): void;
    DisableConsole(): void;
    DisableToggleKey(): void;
    EnableConsole(): void;
    GetCommand(name: string): Command;
    GetCommand(name: string, command: unknown): boolean;
    InvokeCoroutine(enumerator: unknown): Coroutine;
    InvokeDelayed(action: unknown, delay: number): Coroutine;
    Log(message: unknown, context: LogContext, prepend: boolean): void;
    Log(message: unknown, colour: Color, context: LogContext, prepend: boolean): void;
    LogCollection<T>(collection: CSArray<T>, toString: unknown, prefix: string, suffix: string): void;
    LogCommand(): void;
    LogCommand(name: string): void;
    LogError(message: unknown, context: LogContext, prepend: boolean): void;
    LogException(exception: unknown, context: LogContext, prepend: boolean): void;
    LogSeperator(message: unknown): void;
    LogSuccess(message: unknown, context: LogContext): void;
    LogVariable(variableName: string, value: unknown, suffix: string): void;
    LogWarning(message: unknown, context: LogContext, prepend: boolean): void;
    OpenConsole(): void;
    RemoveCommand(name: string): boolean;
    RemoveTrackedStat(name: string): boolean;
    RunCommand(input: string): boolean;
    SetToggleKey(toggleKey: unknown): void;
    SetTrackedStat(name: string, func: unknown, startEnabled: boolean): void;

    readonly OnConsoleEnabled: MonoSignal<void>;
    readonly OnConsoleDisabled: MonoSignal<void>;
    readonly OnConsoleOpened: MonoSignal<boolean>;
    readonly OnConsoleClosed: MonoSignal<boolean>;
    readonly OnConsoleFocused: MonoSignal<void>;
    readonly OnConsoleFocusLost: MonoSignal<void>;
}
declare const DevConsole: DevConsoleConstructor;
    
interface EasyShake extends MonoBehaviour {
    shakeDuration: number;
    shakeOnEnable: boolean;
    destroyComponentOnEnd: boolean;
    movementLerpMod: number;
    movementsPerSecond: number;
    minimizeShakeOverTime: boolean;
    maxPositionOffset: Vector3;
    maxRotationOffsetAngles: Vector3;



    GetRandomVector3(maxRange: Vector3): Vector3;
    SetStartingPosRot(localPosition: Vector3, localRotation: Quaternion): void;
    Shake(duration: number): void;
    ShakeForever(): void;
    StopShake(): void;


}
    
interface EasyShakeConstructor {


    new(): EasyShake;



}
declare const EasyShake: EasyShakeConstructor;
    
interface EasyMotion extends MonoBehaviour {
    refreshMode: EngineRunMode;
    transformSpace: Space;
    translate: boolean;
    translationSpeed: Vector3;
    rotate: boolean;
    angularRotationSpeed: Vector3;
    scale: boolean;
    scaleSpeed: Vector3;
    sineMotion: boolean;
    sineMod: number;
    sineOffset: number;
    randomizeOffset: boolean;





}
    
interface EasyMotionConstructor {


    new(): EasyMotion;



}
declare const EasyMotion: EasyMotionConstructor;
    
interface CloudImage extends MonoBehaviour {
    url: string;
    image: Image;
    downloadOnStart: boolean;
    releaseImageOnDisable: boolean;
    hideErrors: boolean;
    readonly loadedUrl: string;

    readonly OnFinishedLoading: MonoSignal<unknown>;


    ReleaseImage(notifyCache: boolean): void;
    StartDownload(): void;


}
    
interface CloudImageConstructor {


    new(): CloudImage;


    CleanseCache(): void;
    ClearCache(): void;
    PrintCache(): void;

}
declare const CloudImage: CloudImageConstructor;
    
interface AccessoryOutfit extends ScriptableObject {
    accessories: CSArray<AccessoryComponent>;
    faceDecal: AccessoryFace;
    forceSkinColor: boolean;
    skinColor: Color;





}
    
interface AccessoryComponent extends MonoBehaviour {
    serverClassId: string;
    serverClassIdStaging: string;
    accessorySlot: AccessorySlot;
    visibilityMode: VisibilityMode;
    skinnedToCharacter: boolean;
    canMeshCombine: boolean;
    bodyMask: number;
    localPosition: Vector3;
    localRotation: Quaternion;
    localScale: Vector3;



    Copy(other: AccessoryComponent): void;
    GetServerClassId(): string;
    GetServerInstanceId(): string;
    GetSlotNumber(): number;
    HasFlag(flag: BodyMask): boolean;
    SetInstanceId(id: string): void;


}
    
interface BodyMaskInspectorData {
    name: string;
    bodyMask: BodyMask;





}
    
interface BodyMaskInspectorDataConstructor {


    new(mask: BodyMask, name: string): BodyMaskInspectorData;



}
declare const BodyMaskInspectorData: BodyMaskInspectorDataConstructor;
    
interface AccessoryComponentConstructor {
    BodyMaskInspectorDatas: CSArray<BodyMaskInspectorData>;


    new(): AccessoryComponent;


    GetBodyMaskName(bit: number): string;

}
declare const AccessoryComponent: AccessoryComponentConstructor;
    
interface AccessoryFace extends ScriptableObject {
    serverClassId: string;
    serverClassIdStaging: string;
    serverInstanceId: string;
    decalTexture: Texture2D;



    GetServerClassId(): string;


}
    
interface AccessoryFaceConstructor {


    new(): AccessoryFace;



}
declare const AccessoryFace: AccessoryFaceConstructor;
    
interface AccessoryOutfitConstructor {


    new(): AccessoryOutfit;



}
declare const AccessoryOutfit: AccessoryOutfitConstructor;
    
interface LineRenderer extends Renderer {
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    numCornerVertices: number;
    numCapVertices: number;
    useWorldSpace: boolean;
    loop: boolean;
    startColor: Color;
    endColor: Color;
    positionCount: number;
    textureScale: Vector2;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    maskInteraction: SpriteMaskInteraction;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;



    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    GetPosition(index: number): Vector3;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    SetPosition(index: number, position: Vector3): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    Simplify(tolerance: number): void;


}
    
interface LineRendererConstructor {


    new(): LineRenderer;



}
declare const LineRenderer: LineRendererConstructor;
    
interface AirshipRedirectScroll extends MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerEnterHandler, IPointerExitHandler {
    isDragging: boolean;
    redirectTarget: ScrollRect;
    ignoreDrag: boolean;



    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;


}
    
interface AirshipRedirectScrollConstructor {


    new(): AirshipRedirectScroll;



}
declare const AirshipRedirectScroll: AirshipRedirectScrollConstructor;
    
interface IMeshModifier {



    ModifyMesh(verts: VertexHelper): void;


}
    
interface VertexHelper {
    readonly currentVertCount: number;
    readonly currentIndexCount: number;



    AddTriangle(idx0: number, idx1: number, idx2: number): void;
    AddUIVertexQuad(verts: CSArray<UIVertex>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, indices: CSArray<number>): void;
    AddUIVertexTriangleStream(verts: CSArray<UIVertex>): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, uv2: Vector4, uv3: Vector4, normal: Vector3, tangent: Vector4): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, normal: Vector3, tangent: Vector4): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4): void;
    AddVert(v: UIVertex): void;
    Clear(): void;
    Dispose(): void;
    FillMesh(mesh: Mesh): void;
    GetUIVertexStream(stream: CSArray<UIVertex>): void;
    PopulateUIVertex(vertex: unknown, i: number): void;
    SetUIVertex(vertex: UIVertex, i: number): void;


}
    
interface VertexHelperConstructor {


    new(): VertexHelper;
    new(m: Mesh): VertexHelper;



}
declare const VertexHelper: VertexHelperConstructor;
    
interface TrueShadow extends UIBehaviour, IMeshModifier, ICanvasElement {
    readonly UsingRendererMaterialProvider: boolean;
    Size: number;
    Spread: number;
    UseGlobalAngle: boolean;
    OffsetAngle: number;
    OffsetDistance: number;
    Color: Color;
    UseCasterAlpha: boolean;
    IgnoreCasterColor: boolean;
    Inset: boolean;
    BlendMode: BlendMode;
    ColorBleedMode: ColorBleedMode;
    DisableFitCompensation: boolean;
    readonly ClearColor: Color;
    ShadowAsSibling: boolean;
    CustomHash: number;
    readonly Offset: Vector2;
    Cutout: boolean;



    ApplySerializedData(): void;
    CopyTo(other: TrueShadow): void;
    CopyTo(other: GameObject): void;
    CopyToTMPSubMeshes(): void;
    GetShadowCastingMaterial(): Material;
    GetShadowRenderingMaterial(): Material;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    ModifyMesh(mesh: Mesh): void;
    ModifyMesh(verts: VertexHelper): void;
    ModifyShadowCastingMaterialProperties(propertyBlock: MaterialPropertyBlock): void;
    ModifyShadowCastingMesh(mesh: Mesh): void;
    ModifyShadowRendererMaterial(baseMaterial: Material): void;
    ModifyShadowRendererMesh(vertexHelper: VertexHelper): void;
    Rebuild(executing: CanvasUpdate): void;
    RefreshPlugins(): void;
    SetHierachyDirty(): void;
    SetLayoutDirty(): void;
    SetTextureDirty(): void;


}
    
interface TrueShadowConstructor {


    new(): TrueShadow;



}
declare const TrueShadow: TrueShadowConstructor;
    
interface ScalableBufferManager {





}
    
interface ScalableBufferManagerConstructor {
    readonly widthScaleFactor: number;
    readonly heightScaleFactor: number;




    ResizeBuffers(widthScale: number, heightScale: number): void;

}
declare const ScalableBufferManager: ScalableBufferManagerConstructor;
    
interface AirshipPlatformUtil {





}
    
interface AirshipPlatformUtilConstructor {
    livePlatforms: CSArray<number>;


    new(): AirshipPlatformUtil;


    FromBuildTarget(buildTarget: BuildTarget): AirshipPlatform;
    FromRuntimePlatform(runtimePlatform: RuntimePlatform): AirshipPlatform;
    GetLocalPlatform(): AirshipPlatform;
    IsDeviceSimulator(): boolean;
    ToBuildTarget(platform: AirshipPlatform): BuildTarget;

}
declare const AirshipPlatformUtil: AirshipPlatformUtilConstructor;
    
interface CharacterRig extends MonoBehaviour {
    bodyMesh: SkinnedMeshRenderer;
    armsMesh: SkinnedMeshRenderer;
    headMesh: Renderer;
    faceMesh: Renderer;
    rigHolder: Transform;
    rootMotion: Transform;
    master: Transform;
    hips: Transform;
    spine: Transform;
    head: Transform;
    upperArmL: Transform;
    forearmL: Transform;
    handL: Transform;
    fingersL: Transform;
    thumbL: Transform;
    upperArmR: Transform;
    forearmR: Transform;
    handR: Transform;
    fingersR: Transform;
    thumbR: Transform;
    thighL: Transform;
    shinL: Transform;
    footL: Transform;
    thighR: Transform;
    shinR: Transform;
    footR: Transform;
    headTop: Transform;
    neck: Transform;
    spineChest: Transform;
    heldItemL: Transform;
    heldItemR: Transform;
    baseMeshes: CSArray<Renderer>;



    GetSlotTransform(slot: AccessorySlot): Transform;


}
    
interface CharacterRigConstructor {


    new(): CharacterRig;



}
declare const CharacterRig: CharacterRigConstructor;
    
interface AvatarAccessoryCollection extends ScriptableObject {
    accessories: CSArray<AccessoryComponent>;
    faces: CSArray<AccessoryFace>;
    skinColors: CSArray<Color>;





}
    
interface AvatarAccessoryCollectionConstructor {


    new(): AvatarAccessoryCollection;



}
declare const AvatarAccessoryCollection: AvatarAccessoryCollectionConstructor;
    
interface SystemInfo {





}
    
interface SystemInfoConstructor {
    unsupportedIdentifier: string;
    readonly batteryLevel: number;
    readonly batteryStatus: BatteryStatus;
    readonly operatingSystem: string;
    readonly operatingSystemFamily: OperatingSystemFamily;
    readonly processorType: string;
    readonly processorFrequency: number;
    readonly processorCount: number;
    readonly systemMemorySize: number;
    readonly deviceUniqueIdentifier: string;
    readonly deviceName: string;
    readonly deviceModel: string;
    readonly supportsAccelerometer: boolean;
    readonly supportsGyroscope: boolean;
    readonly supportsLocationService: boolean;
    readonly supportsVibration: boolean;
    readonly supportsAudio: boolean;
    readonly deviceType: DeviceType;
    readonly graphicsMemorySize: number;
    readonly graphicsDeviceName: string;
    readonly graphicsDeviceVendor: string;
    readonly graphicsDeviceID: number;
    readonly graphicsDeviceVendorID: number;
    readonly graphicsDeviceType: GraphicsDeviceType;
    readonly graphicsUVStartsAtTop: boolean;
    readonly graphicsDeviceVersion: string;
    readonly graphicsShaderLevel: number;
    readonly graphicsMultiThreaded: boolean;
    readonly renderingThreadingMode: RenderingThreadingMode;
    readonly foveatedRenderingCaps: FoveatedRenderingCaps;
    readonly hasHiddenSurfaceRemovalOnGPU: boolean;
    readonly hasDynamicUniformArrayIndexingInFragmentShaders: boolean;
    readonly supportsShadows: boolean;
    readonly supportsRawShadowDepthSampling: boolean;
    readonly supportsMotionVectors: boolean;
    readonly supports3DTextures: boolean;
    readonly supportsCompressed3DTextures: boolean;
    readonly supports2DArrayTextures: boolean;
    readonly supports3DRenderTextures: boolean;
    readonly supportsCubemapArrayTextures: boolean;
    readonly supportsAnisotropicFilter: boolean;
    readonly copyTextureSupport: CopyTextureSupport;
    readonly supportsComputeShaders: boolean;
    readonly supportsGeometryShaders: boolean;
    readonly supportsTessellationShaders: boolean;
    readonly supportsRenderTargetArrayIndexFromVertexShader: boolean;
    readonly supportsInstancing: boolean;
    readonly supportsHardwareQuadTopology: boolean;
    readonly supports32bitsIndexBuffer: boolean;
    readonly supportsSparseTextures: boolean;
    readonly supportedRenderTargetCount: number;
    readonly supportsSeparatedRenderTargetsBlend: boolean;
    readonly supportedRandomWriteTargetCount: number;
    readonly supportsMultisampledTextures: number;
    readonly supportsMultisampled2DArrayTextures: boolean;
    readonly supportsMultisampleAutoResolve: boolean;
    readonly supportsTextureWrapMirrorOnce: number;
    readonly usesReversedZBuffer: boolean;
    readonly npotSupport: NPOTSupport;
    readonly maxTextureSize: number;
    readonly maxTexture3DSize: number;
    readonly maxTextureArraySlices: number;
    readonly maxCubemapSize: number;
    readonly maxAnisotropyLevel: number;
    readonly maxComputeBufferInputsVertex: number;
    readonly maxComputeBufferInputsFragment: number;
    readonly maxComputeBufferInputsGeometry: number;
    readonly maxComputeBufferInputsDomain: number;
    readonly maxComputeBufferInputsHull: number;
    readonly maxComputeBufferInputsCompute: number;
    readonly maxComputeWorkGroupSize: number;
    readonly maxComputeWorkGroupSizeX: number;
    readonly maxComputeWorkGroupSizeY: number;
    readonly maxComputeWorkGroupSizeZ: number;
    readonly computeSubGroupSize: number;
    readonly supportsAsyncCompute: boolean;
    readonly supportsGpuRecorder: boolean;
    readonly supportsGraphicsFence: boolean;
    readonly supportsAsyncGPUReadback: boolean;
    readonly supportsRayTracingShaders: boolean;
    readonly supportsRayTracing: boolean;
    readonly supportsInlineRayTracing: boolean;
    readonly supportsSetConstantBuffer: boolean;
    readonly constantBufferOffsetAlignment: number;
    readonly maxConstantBufferSize: number;
    readonly maxGraphicsBufferSize: number;
    readonly hasMipMaxLevel: boolean;
    readonly supportsMipStreaming: boolean;
    readonly usesLoadStoreActions: boolean;
    readonly hdrDisplaySupportFlags: HDRDisplaySupportFlags;
    readonly supportsConservativeRaster: boolean;
    readonly supportsMultiview: boolean;
    readonly supportsStoreAndResolveAction: boolean;
    readonly supportsMultisampleResolveDepth: boolean;
    readonly supportsMultisampleResolveStencil: boolean;
    readonly supportsIndirectArgumentsBuffer: boolean;


    new(): SystemInfo;


    GetCompatibleFormat(format: GraphicsFormat, usage: GraphicsFormatUsage): GraphicsFormat;
    GetGraphicsFormat(format: DefaultFormat): GraphicsFormat;
    GetRenderTextureSupportedMSAASampleCount(desc: RenderTextureDescriptor): number;
    IsFormatSupported(format: GraphicsFormat, usage: GraphicsFormatUsage): boolean;
    SupportsBlendingOnRenderTextureFormat(format: RenderTextureFormat): boolean;
    SupportsRandomWriteOnRenderTextureFormat(format: RenderTextureFormat): boolean;
    SupportsRenderTextureFormat(format: RenderTextureFormat): boolean;
    SupportsTextureFormat(format: TextureFormat): boolean;
    SupportsVertexAttributeFormat(format: VertexAttributeFormat, dimension: number): boolean;

}
declare const SystemInfo: SystemInfoConstructor;
    
interface CanvasScaler extends UIBehaviour {
    uiScaleMode: ScaleMode;
    referencePixelsPerUnit: number;
    scaleFactor: number;
    referenceResolution: Vector2;
    screenMatchMode: ScreenMatchMode;
    matchWidthOrHeight: number;
    physicalUnit: Unit;
    fallbackScreenDPI: number;
    defaultSpriteDPI: number;
    dynamicPixelsPerUnit: number;





}
    
interface GridLayoutGroup extends LayoutGroup {
    startCorner: Corner;
    startAxis: Axis;
    cellSize: Vector2;
    spacing: Vector2;
    constraint: Constraint;
    constraintCount: number;



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;


}
    
interface ILayoutIgnorer {
    readonly ignoreLayout: boolean;





}
    
interface LayoutElement extends UIBehaviour, ILayoutIgnorer, ILayoutElement {
    ignoreLayout: boolean;
    minWidth: number;
    minHeight: number;
    preferredWidth: number;
    preferredHeight: number;
    flexibleWidth: number;
    flexibleHeight: number;
    layoutPriority: number;



    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;


}
    
interface Screen {





}
    
interface Resolution {
    width: number;
    height: number;
    refreshRateRatio: RefreshRate;



    ToString(): string;


}
    
interface RefreshRate {
    numerator: number;
    denominator: number;
    readonly value: number;



    CompareTo(other: RefreshRate): number;
    Equals(other: RefreshRate): boolean;
    ToString(): string;


}
    
interface DisplayInfo {
    width: number;
    height: number;
    refreshRate: RefreshRate;
    workArea: RectInt;
    name: string;



    Equals(other: DisplayInfo): boolean;


}
    
interface ScreenConstructor {
    readonly width: number;
    readonly height: number;
    readonly dpi: number;
    readonly currentResolution: Resolution;
    readonly resolutions: CSArray<Resolution>;
    readonly msaaSamples: number;
    fullScreen: boolean;
    fullScreenMode: FullScreenMode;
    readonly safeArea: Rect;
    readonly cutouts: CSArray<Rect>;
    autorotateToPortrait: boolean;
    autorotateToPortraitUpsideDown: boolean;
    autorotateToLandscapeLeft: boolean;
    autorotateToLandscapeRight: boolean;
    orientation: ScreenOrientation;
    sleepTimeout: number;
    brightness: number;
    readonly mainWindowPosition: Vector2Int;
    readonly mainWindowDisplayInfo: DisplayInfo;


    new(): Screen;


    GetDisplayLayout(displayLayout: CSArray<DisplayInfo>): void;
    MoveMainWindowTo(display: unknown, position: Vector2Int): AsyncOperation;
    SetMSAASamples(numSamples: number): void;
    SetResolution(width: number, height: number, fullscreenMode: FullScreenMode, preferredRefreshRate: RefreshRate): void;
    SetResolution(width: number, height: number, fullscreenMode: FullScreenMode): void;
    SetResolution(width: number, height: number, fullscreen: boolean): void;

}
declare const Screen: ScreenConstructor;
    
interface Gizmos {





}
    
interface GizmosConstructor {
    color: Color;
    matrix: Matrix4x4;
    exposure: Texture;
    readonly probeSize: number;


    new(): Gizmos;


    CalculateLOD(position: Vector3, radius: number): number;
    DrawCube(center: Vector3, size: Vector3): void;
    DrawFrustum(center: Vector3, fov: number, maxRange: number, minRange: number, aspect: number): void;
    DrawGUITexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material): void;
    DrawGUITexture(screenRect: Rect, texture: Texture): void;
    DrawGUITexture(screenRect: Rect, texture: Texture, mat: Material): void;
    DrawGUITexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number): void;
    DrawIcon(center: Vector3, name: string, allowScaling: boolean): void;
    DrawIcon(center: Vector3, name: string, allowScaling: boolean, tint: Color): void;
    DrawIcon(center: Vector3, name: string): void;
    DrawLine(from: Vector3, to: Vector3): void;
    DrawLineList(points: unknown): void;
    DrawLineStrip(points: unknown, looped: boolean): void;
    DrawMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawMesh(mesh: Mesh, position: Vector3): void;
    DrawMesh(mesh: Mesh): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion): void;
    DrawMesh(mesh: Mesh, submeshIndex: number, position: Vector3): void;
    DrawMesh(mesh: Mesh, submeshIndex: number): void;
    DrawRay(r: Ray): void;
    DrawRay(from: Vector3, direction: Vector3): void;
    DrawSphere(center: Vector3, radius: number): void;
    DrawWireCube(center: Vector3, size: Vector3): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawWireMesh(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawWireMesh(mesh: Mesh, position: Vector3): void;
    DrawWireMesh(mesh: Mesh): void;
    DrawWireMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number, position: Vector3): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number): void;
    DrawWireSphere(center: Vector3, radius: number): void;

}
declare const Gizmos: GizmosConstructor;
    
interface DeviceBridge {





}
    
interface DeviceBridgeConstructor {
    isTablet: boolean;


    new(): DeviceBridge;


    GetDeviceType(): AirshipDeviceType;
    OnLoad(): void;

}
declare const DeviceBridge: DeviceBridgeConstructor;
    
interface Mask extends UIBehaviour, IMaterialModifier, ICanvasRaycastFilter {
    readonly rectTransform: RectTransform;
    showMaskGraphic: boolean;
    readonly graphic: Graphic;



    GetModifiedMaterial(baseMaterial: Material): Material;
    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;
    MaskEnabled(): boolean;


}
    
interface ImageWithRoundedCorners extends MonoBehaviour {
    radius: number;



    Refresh(): void;
    Validate(): void;


}
    
interface ImageWithRoundedCornersConstructor {


    new(): ImageWithRoundedCorners;



}
declare const ImageWithRoundedCorners: ImageWithRoundedCornersConstructor;
    
interface ImageWithIndependentRoundedCorners extends MonoBehaviour {
    r: Vector4;



    Refresh(): void;
    Validate(): void;


}
    
interface ImageWithIndependentRoundedCornersConstructor {


    new(): ImageWithIndependentRoundedCorners;



}
declare const ImageWithIndependentRoundedCorners: ImageWithIndependentRoundedCornersConstructor;
    
interface NavMeshAgent extends Behaviour {
    destination: Vector3;
    stoppingDistance: number;
    velocity: Vector3;
    nextPosition: Vector3;
    readonly steeringTarget: Vector3;
    readonly desiredVelocity: Vector3;
    readonly remainingDistance: number;
    baseOffset: number;
    readonly isOnOffMeshLink: boolean;
    readonly currentOffMeshLinkData: OffMeshLinkData;
    readonly nextOffMeshLinkData: OffMeshLinkData;
    autoTraverseOffMeshLink: boolean;
    autoBraking: boolean;
    autoRepath: boolean;
    readonly hasPath: boolean;
    readonly pathPending: boolean;
    readonly isPathStale: boolean;
    readonly pathStatus: NavMeshPathStatus;
    readonly pathEndPosition: Vector3;
    isStopped: boolean;
    path: NavMeshPath;
    readonly navMeshOwner: Object;
    agentTypeID: number;
    areaMask: number;
    speed: number;
    angularSpeed: number;
    acceleration: number;
    updatePosition: boolean;
    updateRotation: boolean;
    updateUpAxis: boolean;
    radius: number;
    height: number;
    obstacleAvoidanceType: ObstacleAvoidanceType;
    avoidancePriority: number;
    readonly isOnNavMesh: boolean;



    ActivateCurrentOffMeshLink(activated: boolean): void;
    CalculatePath(targetPosition: Vector3, path: NavMeshPath): boolean;
    CompleteOffMeshLink(): void;
    FindClosestEdge(hit: unknown): boolean;
    GetAreaCost(areaIndex: number): number;
    Move(offset: Vector3): void;
    Raycast(targetPosition: Vector3, hit: unknown): boolean;
    ResetPath(): void;
    SamplePathPosition(areaMask: number, maxDistance: number, hit: unknown): boolean;
    SetAreaCost(areaIndex: number, areaCost: number): void;
    SetDestination(target: Vector3): boolean;
    SetPath(path: NavMeshPath): boolean;
    Warp(newPosition: Vector3): boolean;


}
    
interface OffMeshLinkData {
    readonly valid: boolean;
    readonly activated: boolean;
    readonly linkType: OffMeshLinkType;
    readonly startPos: Vector3;
    readonly endPos: Vector3;
    readonly owner: Object;





}
    
interface NavMeshPath {
    readonly corners: CSArray<Vector3>;
    readonly status: NavMeshPathStatus;



    ClearCorners(): void;
    GetCornersNonAlloc(results: CSArray<Vector3>): number;


}
    
interface NavMeshPathConstructor {


    new(): NavMeshPath;



}
declare const NavMeshPath: NavMeshPathConstructor;
    
interface NavMeshAgentConstructor {


    new(): NavMeshAgent;



}
declare const NavMeshAgent: NavMeshAgentConstructor;
    
    
interface OnNavMeshPreUpdate {



    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;


}
    
interface OnNavMeshPreUpdateConstructor {


    new(object: unknown, method: unknown): OnNavMeshPreUpdate;



}
declare const OnNavMeshPreUpdate: OnNavMeshPreUpdateConstructor;
    
interface NavMeshLinkInstance {





}
    
interface NavMeshLinkData {
    startPosition: Vector3;
    endPosition: Vector3;
    costModifier: number;
    bidirectional: boolean;
    width: number;
    area: number;
    agentTypeID: number;





}
    
interface NavMeshDataInstance {
    readonly valid: boolean;
    owner: Object;



    Remove(): void;


}
    
interface NavMeshData extends Object {
    readonly sourceBounds: Bounds;
    position: Vector3;
    rotation: Quaternion;





}
    
interface NavMeshDataConstructor {


    new(): NavMeshData;
    new(agentTypeID: number): NavMeshData;



}
declare const NavMeshData: NavMeshDataConstructor;
    
interface NavMeshQueryFilter {
    areaMask: number;
    agentTypeID: number;



    GetAreaCost(areaIndex: number): number;
    SetAreaCost(areaIndex: number, cost: number): void;


}
    
interface NavMeshTriangulation {
    vertices: CSArray<Vector3>;
    indices: CSArray<number>;
    areas: CSArray<number>;





}
    
interface NavMeshBuildSettings {
    agentTypeID: number;
    agentRadius: number;
    agentHeight: number;
    agentSlope: number;
    agentClimb: number;
    ledgeDropHeight: number;
    maxJumpAcrossDistance: number;
    minRegionArea: number;
    overrideVoxelSize: boolean;
    voxelSize: number;
    overrideTileSize: boolean;
    tileSize: number;
    maxJobWorkers: number;
    preserveTilesOutsideBounds: boolean;
    buildHeightMesh: boolean;
    debug: NavMeshBuildDebugSettings;



    ValidationReport(buildBounds: Bounds): CSArray<string>;


}
    
interface NavMeshBuildDebugSettings {
    flags: NavMeshBuildDebugFlags;





}
    
    
interface NavMeshObstacle extends Behaviour {
    height: number;
    radius: number;
    velocity: Vector3;
    carving: boolean;
    carveOnlyStationary: boolean;
    carvingMoveThreshold: number;
    carvingTimeToStationary: number;
    shape: NavMeshObstacleShape;
    center: Vector3;
    size: Vector3;





}
    
interface NavMeshObstacleConstructor {


    new(): NavMeshObstacle;



}
declare const NavMeshObstacle: NavMeshObstacleConstructor;
    
interface ScrollView extends VisualElement {
    horizontalScrollerVisibility: ScrollerVisibility;
    verticalScrollerVisibility: ScrollerVisibility;
    elasticAnimationIntervalMs: number;
    scrollOffset: Vector2;
    horizontalPageSize: number;
    verticalPageSize: number;
    mouseWheelScrollSize: number;
    scrollDecelerationRate: number;
    elasticity: number;
    touchScrollBehavior: TouchScrollBehavior;
    nestedInteractionKind: NestedInteractionKind;
    readonly contentViewport: VisualElement;
    readonly horizontalScroller: Scroller;
    readonly verticalScroller: Scroller;
    readonly contentContainer: VisualElement;
    mode: ScrollViewMode;



    ScrollTo(child: VisualElement): void;


}
    
interface Scroller extends VisualElement {
    readonly slider: Slider;
    readonly lowButton: RepeatButton;
    readonly highButton: RepeatButton;
    value: number;
    lowValue: number;
    highValue: number;
    direction: SliderDirection;

    readonly valueChanged: MonoSignal<number>;


    Adjust(factor: number): void;
    ScrollPageDown(): void;
    ScrollPageDown(factor: number): void;
    ScrollPageUp(): void;
    ScrollPageUp(factor: number): void;


}
    
interface IValueField<T> {
    value: T;



    ApplyInputDeviceDelta(delta: Vector3, speed: DeltaSpeed, startValue: T): void;
    StartDragging(): void;
    StopDragging(): void;


}
    
interface BaseSlider<TValueType> extends BaseField<TValueType>, IValueField<TValueType> {
    lowValue: TValueType;
    highValue: TValueType;
    readonly range: TValueType;
    pageSize: number;
    showInputField: boolean;
    value: TValueType;
    direction: SliderDirection;
    inverted: boolean;



    AdjustDragElement(factor: number): void;
    ApplyInputDeviceDelta(delta: Vector3, speed: DeltaSpeed, startValue: TValueType): void;
    SetValueWithoutNotify(newValue: TValueType): void;


}
    
interface BaseSliderConstructor {
    readonly ussClassName: string;
    readonly labelUssClassName: string;
    readonly inputUssClassName: string;
    readonly horizontalVariantUssClassName: string;
    readonly verticalVariantUssClassName: string;
    readonly dragContainerUssClassName: string;
    readonly trackerUssClassName: string;
    readonly draggerUssClassName: string;
    readonly draggerBorderUssClassName: string;
    readonly textFieldClassName: string;





}
declare const BaseSlider: BaseSliderConstructor;
    
interface Slider extends BaseSlider<number> {



    ApplyInputDeviceDelta(delta: Vector3, speed: DeltaSpeed, startValue: number): void;


}
    
interface SliderConstructor {
    readonly ussClassName: string;
    readonly labelUssClassName: string;
    readonly inputUssClassName: string;


    new(): Slider;
    new(start: number, end: number, direction: SliderDirection, pageSize: number): Slider;
    new(label: string, start: number, end: number, direction: SliderDirection, pageSize: number): Slider;



}
declare const Slider: SliderConstructor;
    
interface RepeatButton extends TextElement {



    SetAction(clickEvent: unknown, delay: number, interval: number): void;


}
    
interface RepeatButtonConstructor {
    readonly ussClassName: string;


    new(): RepeatButton;
    new(clickEvent: unknown, delay: number, interval: number): RepeatButton;



}
declare const RepeatButton: RepeatButtonConstructor;
    
interface ScrollerConstructor {
    readonly ussClassName: string;
    readonly horizontalVariantUssClassName: string;
    readonly verticalVariantUssClassName: string;
    readonly sliderUssClassName: string;
    readonly lowButtonUssClassName: string;
    readonly highButtonUssClassName: string;


    new(): Scroller;
    new(lowValue: number, highValue: number, valueChanged: unknown, direction: SliderDirection): Scroller;



}
declare const Scroller: ScrollerConstructor;
    
interface ScrollViewConstructor {
    readonly ussClassName: string;
    readonly viewportUssClassName: string;
    readonly horizontalVariantViewportUssClassName: string;
    readonly verticalVariantViewportUssClassName: string;
    readonly verticalHorizontalVariantViewportUssClassName: string;
    readonly contentAndVerticalScrollUssClassName: string;
    readonly contentUssClassName: string;
    readonly horizontalVariantContentUssClassName: string;
    readonly verticalVariantContentUssClassName: string;
    readonly verticalHorizontalVariantContentUssClassName: string;
    readonly hScrollerUssClassName: string;
    readonly vScrollerUssClassName: string;
    readonly horizontalVariantUssClassName: string;
    readonly verticalVariantUssClassName: string;
    readonly verticalHorizontalVariantUssClassName: string;
    readonly scrollVariantUssClassName: string;


    new(): ScrollView;
    new(scrollViewMode: ScrollViewMode): ScrollView;



}
declare const ScrollView: ScrollViewConstructor;
    
interface AirshipLongPress extends MonoBehaviour, IBeginDragHandler, IDragHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler {
    holdTime: number;

    readonly OnClick: MonoSignal<void>;
    readonly OnLongPress: MonoSignal<unknown>;


    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    Update(): void;


}
    
interface AirshipLongPressConstructor {


    new(): AirshipLongPress;



}
declare const AirshipLongPress: AirshipLongPressConstructor;
    
interface BoxCollider2D extends Collider2D {
    size: Vector2;
    edgeRadius: number;
    autoTiling: boolean;





}
    
interface BoxCollider2DConstructor {


    new(): BoxCollider2D;



}
declare const BoxCollider2D: BoxCollider2DConstructor;
    
interface CircleCollider2D extends Collider2D {
    radius: number;





}
    
interface CircleCollider2DConstructor {


    new(): CircleCollider2D;



}
declare const CircleCollider2D: CircleCollider2DConstructor;
    
interface CapsuleCollider2D extends Collider2D {
    size: Vector2;
    direction: CapsuleDirection2D;





}
    
interface CapsuleCollider2DConstructor {


    new(): CapsuleCollider2D;



}
declare const CapsuleCollider2D: CapsuleCollider2DConstructor;
    
interface PolygonCollider2D extends Collider2D {
    useDelaunayMesh: boolean;
    autoTiling: boolean;
    points: CSArray<Vector2>;
    pathCount: number;



    CreatePrimitive(sides: number): void;
    CreatePrimitive(sides: number, scale: Vector2): void;
    CreatePrimitive(sides: number, scale: Vector2, offset: Vector2): void;
    GetPath(index: number): CSArray<Vector2>;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetTotalPointCount(): number;
    SetPath(index: number, points: CSArray<Vector2>): void;
    SetPath(index: number, points: CSArray<Vector2>): void;


}
    
interface PolygonCollider2DConstructor {


    new(): PolygonCollider2D;



}
declare const PolygonCollider2D: PolygonCollider2DConstructor;
    
interface CustomCollider2D extends Collider2D {
    readonly customShapeCount: number;
    readonly customVertexCount: number;



    ClearCustomShapes(shapeIndex: number, shapeCount: number): void;
    ClearCustomShapes(): void;
    GetCustomShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetCustomShapes(physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: number, shapeCount: number): number;
    GetCustomShapes(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): number;
    SetCustomShape(physicsShapeGroup: PhysicsShapeGroup2D, srcShapeIndex: number, dstShapeIndex: number): void;
    SetCustomShape(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>, srcShapeIndex: number, dstShapeIndex: number): void;
    SetCustomShapes(physicsShapeGroup: PhysicsShapeGroup2D): void;
    SetCustomShapes(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;


}
    
interface CustomCollider2DConstructor {


    new(): CustomCollider2D;



}
declare const CustomCollider2D: CustomCollider2DConstructor;
    
interface EdgeCollider2D extends Collider2D {
    edgeRadius: number;
    readonly edgeCount: number;
    readonly pointCount: number;
    points: CSArray<Vector2>;
    useAdjacentStartPoint: boolean;
    useAdjacentEndPoint: boolean;
    adjacentStartPoint: Vector2;
    adjacentEndPoint: Vector2;



    GetPoints(points: CSArray<Vector2>): number;
    Reset(): void;
    SetPoints(points: CSArray<Vector2>): boolean;


}
    
interface EdgeCollider2DConstructor {


    new(): EdgeCollider2D;



}
declare const EdgeCollider2D: EdgeCollider2DConstructor;
    
interface TilemapCollider2D extends Collider2D {
    useDelaunayMesh: boolean;
    maximumTileChangeCount: number;
    extrusionFactor: number;
    readonly hasTilemapChanges: boolean;



    ProcessTilemapChanges(): void;


}
    
interface TilemapCollider2DConstructor {


    new(): TilemapCollider2D;



}
declare const TilemapCollider2D: TilemapCollider2DConstructor;
    
interface SphereCollider extends Collider {
    center: Vector3;
    radius: number;





}
    
interface SphereColliderConstructor {


    new(): SphereCollider;



}
declare const SphereCollider: SphereColliderConstructor;
    
interface BoxCollider extends Collider {
    center: Vector3;
    size: Vector3;





}
    
interface BoxColliderConstructor {


    new(): BoxCollider;



}
declare const BoxCollider: BoxColliderConstructor;
    
interface CapsuleCollider extends Collider {
    center: Vector3;
    radius: number;
    height: number;
    direction: number;





}
    
interface CapsuleColliderConstructor {


    new(): CapsuleCollider;



}
declare const CapsuleCollider: CapsuleColliderConstructor;
    
interface MeshCollider extends Collider {
    sharedMesh: Mesh;
    convex: boolean;
    cookingOptions: MeshColliderCookingOptions;





}
    
interface MeshColliderConstructor {


    new(): MeshCollider;



}
declare const MeshCollider: MeshColliderConstructor;
    
interface WheelCollider extends Collider {
    center: Vector3;
    radius: number;
    suspensionDistance: number;
    suspensionSpring: JointSpring;
    suspensionExpansionLimited: boolean;
    forceAppPointDistance: number;
    mass: number;
    wheelDampingRate: number;
    forwardFriction: WheelFrictionCurve;
    sidewaysFriction: WheelFrictionCurve;
    motorTorque: number;
    brakeTorque: number;
    steerAngle: number;
    readonly isGrounded: boolean;
    readonly rpm: number;
    sprungMass: number;
    rotationSpeed: number;



    ConfigureVehicleSubsteps(speedThreshold: number, stepsBelowThreshold: number, stepsAboveThreshold: number): void;
    GetGroundHit(hit: unknown): boolean;
    GetWorldPose(pos: unknown, quat: unknown): void;
    ResetSprungMasses(): void;


}
    
interface JointSpring {
    spring: number;
    damper: number;
    targetPosition: number;





}
    
interface WheelFrictionCurve {
    extremumSlip: number;
    extremumValue: number;
    asymptoteSlip: number;
    asymptoteValue: number;
    stiffness: number;





}
    
interface WheelColliderConstructor {


    new(): WheelCollider;



}
declare const WheelCollider: WheelColliderConstructor;
    
interface TerrainCollider extends Collider {
    terrainData: TerrainData;





}
    
interface TerrainData extends Object {
    readonly heightmapTexture: RenderTexture;
    heightmapResolution: number;
    readonly heightmapScale: Vector3;
    readonly holesTexture: Texture;
    enableHolesTextureCompression: boolean;
    readonly holesResolution: number;
    size: Vector3;
    readonly bounds: Bounds;
    wavingGrassStrength: number;
    wavingGrassAmount: number;
    wavingGrassSpeed: number;
    wavingGrassTint: Color;
    readonly detailWidth: number;
    readonly detailHeight: number;
    readonly maxDetailScatterPerRes: number;
    readonly detailPatchCount: number;
    readonly detailResolution: number;
    readonly detailResolutionPerPatch: number;
    readonly detailScatterMode: DetailScatterMode;
    detailPrototypes: CSArray<DetailPrototype>;
    treeInstances: CSArray<TreeInstance>;
    readonly treeInstanceCount: number;
    treePrototypes: CSArray<TreePrototype>;
    readonly alphamapLayers: number;
    alphamapResolution: number;
    readonly alphamapWidth: number;
    readonly alphamapHeight: number;
    baseMapResolution: number;
    readonly alphamapTextureCount: number;
    readonly alphamapTextures: CSArray<Texture2D>;
    terrainLayers: CSArray<TerrainLayer>;



    ComputeDetailCoverage(detailPrototypeIndex: number): number;
    ComputeDetailInstanceTransforms(patchX: number, patchY: number, layer: number, density: number, bounds: unknown): CSArray<DetailInstanceTransform>;
    CopyActiveRenderTextureToHeightmap(sourceRect: RectInt, dest: Vector2Int, syncControl: TerrainHeightmapSyncControl): void;
    CopyActiveRenderTextureToTexture(textureName: string, textureIndex: number, sourceRect: RectInt, dest: Vector2Int, allowDelayedCPUSync: boolean): void;
    DirtyHeightmapRegion(region: RectInt, syncControl: TerrainHeightmapSyncControl): void;
    DirtyTextureRegion(textureName: string, region: RectInt, allowDelayedCPUSync: boolean): void;
    GetAlphamaps(x: number, y: number, width: number, height: number): unknown;
    GetAlphamapTexture(index: number): Texture2D;
    GetClampedDetailPatches(density: number): CSArray<Vector2Int>;
    GetDetailLayer(xBase: number, yBase: number, width: number, height: number, layer: number): unknown;
    GetDetailLayer(positionBase: Vector2Int, size: Vector2Int, layer: number): unknown;
    GetHeight(x: number, y: number): number;
    GetHeights(xBase: number, yBase: number, width: number, height: number): unknown;
    GetHoles(xBase: number, yBase: number, width: number, height: number): unknown;
    GetInterpolatedHeight(x: number, y: number): number;
    GetInterpolatedHeights(xBase: number, yBase: number, xCount: number, yCount: number, xInterval: number, yInterval: number): unknown;
    GetInterpolatedHeights(results: unknown, resultXOffset: number, resultYOffset: number, xBase: number, yBase: number, xCount: number, yCount: number, xInterval: number, yInterval: number): void;
    GetInterpolatedNormal(x: number, y: number): Vector3;
    GetMaximumHeightError(): CSArray<number>;
    GetPatchMinMaxHeights(): CSArray<PatchExtents>;
    GetSteepness(x: number, y: number): number;
    GetSupportedLayers(xBase: number, yBase: number, totalWidth: number, totalHeight: number): CSArray<number>;
    GetSupportedLayers(positionBase: Vector2Int, size: Vector2Int): CSArray<number>;
    GetTreeInstance(index: number): TreeInstance;
    IsHole(x: number, y: number): boolean;
    OverrideMaximumHeightError(maxError: CSArray<number>): void;
    OverrideMinMaxPatchHeights(minMaxHeights: CSArray<PatchExtents>): void;
    RefreshPrototypes(): void;
    RemoveDetailPrototype(index: number): void;
    SetAlphamaps(x: number, y: number, map: unknown): void;
    SetBaseMapDirty(): void;
    SetDetailLayer(xBase: number, yBase: number, layer: number, details: unknown): void;
    SetDetailLayer(basePosition: Vector2Int, layer: number, details: unknown): void;
    SetDetailResolution(detailResolution: number, resolutionPerPatch: number): void;
    SetDetailScatterMode(scatterMode: DetailScatterMode): void;
    SetHeights(xBase: number, yBase: number, heights: unknown): void;
    SetHeightsDelayLOD(xBase: number, yBase: number, heights: unknown): void;
    SetHoles(xBase: number, yBase: number, holes: unknown): void;
    SetHolesDelayLOD(xBase: number, yBase: number, holes: unknown): void;
    SetTerrainLayersRegisterUndo(terrainLayers: CSArray<TerrainLayer>, undoName: string): void;
    SetTreeInstance(index: number, instance: TreeInstance): void;
    SetTreeInstances(instances: CSArray<TreeInstance>, snapToHeightmap: boolean): void;
    SyncHeightmap(): void;
    SyncTexture(textureName: string): void;


}
    
interface DetailPrototype {
    prototype: GameObject;
    prototypeTexture: Texture2D;
    minWidth: number;
    maxWidth: number;
    minHeight: number;
    maxHeight: number;
    noiseSeed: number;
    noiseSpread: number;
    density: number;
    holeEdgePadding: number;
    healthyColor: Color;
    dryColor: Color;
    renderMode: DetailRenderMode;
    usePrototypeMesh: boolean;
    useInstancing: boolean;
    targetCoverage: number;
    useDensityScaling: boolean;
    alignToGround: number;
    positionJitter: number;



    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    Validate(): boolean;
    Validate(errorMessage: CSArray<string>): boolean;


}
    
interface DetailPrototypeConstructor {


    new(): DetailPrototype;
    new(other: DetailPrototype): DetailPrototype;



}
declare const DetailPrototype: DetailPrototypeConstructor;
    
interface TreeInstance {
    position: Vector3;
    widthScale: number;
    heightScale: number;
    rotation: number;
    color: Color32;
    lightmapColor: Color32;
    prototypeIndex: number;





}
    
interface TreePrototype {
    prefab: GameObject;
    bendFactor: number;
    navMeshLod: number;



    Equals(obj: unknown): boolean;
    GetHashCode(): number;


}
    
interface TreePrototypeConstructor {


    new(): TreePrototype;
    new(other: TreePrototype): TreePrototype;



}
declare const TreePrototype: TreePrototypeConstructor;
    
interface TerrainLayer extends Object {
    diffuseTexture: Texture2D;
    normalMapTexture: Texture2D;
    maskMapTexture: Texture2D;
    tileSize: Vector2;
    tileOffset: Vector2;
    specular: Color;
    metallic: number;
    smoothness: number;
    normalScale: number;
    diffuseRemapMin: Vector4;
    diffuseRemapMax: Vector4;
    maskMapRemapMin: Vector4;
    maskMapRemapMax: Vector4;
    smoothnessSource: TerrainLayerSmoothnessSource;





}
    
interface TerrainLayerConstructor {


    new(): TerrainLayer;



}
declare const TerrainLayer: TerrainLayerConstructor;
    
interface DetailInstanceTransform {
    posX: number;
    posY: number;
    posZ: number;
    scaleXZ: number;
    scaleY: number;
    rotationY: number;





}
    
interface PatchExtents {
    min: number;
    max: number;





}
    
interface TerrainDataConstructor {
    readonly AlphamapTextureName: string;
    readonly HolesTextureName: string;


    new(): TerrainData;



}
declare const TerrainData: TerrainDataConstructor;
    
interface TerrainColliderConstructor {


    new(): TerrainCollider;



}
declare const TerrainCollider: TerrainColliderConstructor;
    
interface NavMeshHit {
    position: Vector3;
    normal: Vector3;
    distance: number;
    mask: number;
    hit: boolean;





}
    
interface Graphics {





}
    
interface LightProbeProxyVolume extends Behaviour {
    readonly boundsGlobal: Bounds;
    sizeCustom: Vector3;
    originCustom: Vector3;
    probeDensity: number;
    gridResolutionX: number;
    gridResolutionY: number;
    gridResolutionZ: number;
    boundingBoxMode: BoundingBoxMode;
    resolutionMode: ResolutionMode;
    probePositionMode: ProbePositionMode;
    refreshMode: RefreshMode;
    qualityMode: QualityMode;
    dataFormat: DataFormat;



    Update(): void;


}
    
interface LightProbeProxyVolumeConstructor {
    readonly isFeatureSupported: boolean;


    new(): LightProbeProxyVolume;



}
declare const LightProbeProxyVolume: LightProbeProxyVolumeConstructor;
    
interface RenderParams {
    layer: number;
    renderingLayerMask: number;
    rendererPriority: number;
    instanceID: number;
    worldBounds: Bounds;
    camera: Camera;
    motionVectorMode: MotionVectorGenerationMode;
    reflectionProbeUsage: ReflectionProbeUsage;
    material: Material;
    matProps: MaterialPropertyBlock;
    shadowCastingMode: ShadowCastingMode;
    receiveShadows: boolean;
    lightProbeUsage: LightProbeUsage;
    lightProbeProxyVolume: LightProbeProxyVolume;
    overrideSceneCullingMask: boolean;
    sceneCullingMask: number;





}
    
interface RenderParamsConstructor {


    new(mat: Material): RenderParams;



}
declare const RenderParams: RenderParamsConstructor;
    
interface RenderTargetSetup {
    color: CSArray<RenderBuffer>;
    depth: RenderBuffer;
    mipLevel: number;
    cubemapFace: CubemapFace;
    depthSlice: number;
    colorLoad: CSArray<number>;
    colorStore: CSArray<number>;
    depthLoad: RenderBufferLoadAction;
    depthStore: RenderBufferStoreAction;





}
    
interface RenderTargetSetupConstructor {


    new(color: CSArray<RenderBuffer>, depth: RenderBuffer, mip: number, face: CubemapFace, colorLoad: CSArray<number>, colorStore: CSArray<number>, depthLoad: RenderBufferLoadAction, depthStore: RenderBufferStoreAction): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer, mipLevel: number): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer, mipLevel: number, face: CubemapFace): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer, mipLevel: number, face: CubemapFace, depthSlice: number): RenderTargetSetup;
    new(color: CSArray<RenderBuffer>, depth: RenderBuffer): RenderTargetSetup;
    new(color: CSArray<RenderBuffer>, depth: RenderBuffer, mipLevel: number): RenderTargetSetup;
    new(color: CSArray<RenderBuffer>, depth: RenderBuffer, mip: number, face: CubemapFace): RenderTargetSetup;



}
declare const RenderTargetSetup: RenderTargetSetupConstructor;
    
interface GraphicsConstructor {
    readonly activeColorGamut: ColorGamut;
    activeTier: GraphicsTier;
    readonly preserveFramebufferAlpha: boolean;
    readonly minOpenGLESVersion: OpenGLESVersion;
    readonly activeColorBuffer: RenderBuffer;
    readonly activeDepthBuffer: RenderBuffer;


    new(): Graphics;


    Blit(source: Texture, dest: RenderTexture): void;
    Blit(source: Texture, dest: RenderTexture, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: RenderTexture, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: RenderTexture, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: RenderTexture, mat: Material, pass: number): void;
    Blit(source: Texture, dest: RenderTexture, mat: Material, pass: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: RenderTexture, mat: Material): void;
    Blit(source: Texture, mat: Material, pass: number): void;
    Blit(source: Texture, mat: Material, pass: number, destDepthSlice: number): void;
    Blit(source: Texture, mat: Material): void;
    Blit(source: Texture, dest: GraphicsTexture): void;
    Blit(source: Texture, dest: GraphicsTexture, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: GraphicsTexture, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: GraphicsTexture, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: GraphicsTexture, mat: Material, pass: number): void;
    Blit(source: Texture, dest: GraphicsTexture, mat: Material, pass: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: GraphicsTexture, mat: Material): void;
    BlitMultiTap(source: Texture, dest: RenderTexture, mat: Material, offsets: CSArray<Vector2>): void;
    BlitMultiTap(source: Texture, dest: RenderTexture, mat: Material, destDepthSlice: number, offsets: CSArray<Vector2>): void;
    BlitMultiTap(source: Texture, dest: GraphicsTexture, mat: Material, offsets: CSArray<Vector2>): void;
    BlitMultiTap(source: Texture, dest: GraphicsTexture, mat: Material, destDepthSlice: number, offsets: CSArray<Vector2>): void;
    ClearRandomWriteTargets(): void;
    ConvertTexture(src: Texture, dst: Texture): boolean;
    ConvertTexture(src: Texture, srcElement: number, dst: Texture, dstElement: number): boolean;
    CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer): void;
    CopyTexture(src: Texture, dst: Texture): void;
    CopyTexture(src: Texture, srcElement: number, dst: Texture, dstElement: number): void;
    CopyTexture(src: Texture, srcElement: number, srcMip: number, dst: Texture, dstElement: number, dstMip: number): void;
    CopyTexture(src: Texture, srcElement: number, srcMip: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number, dst: Texture, dstElement: number, dstMip: number, dstX: number, dstY: number): void;
    CreateAsyncGraphicsFence(stage: SynchronisationStage): GraphicsFence;
    CreateAsyncGraphicsFence(): GraphicsFence;
    CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags): GraphicsFence;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshNow(mesh: Mesh, position: Vector3, rotation: Quaternion, materialIndex: number): void;
    DrawMeshNow(mesh: Mesh, matrix: Matrix4x4, materialIndex: number): void;
    DrawMeshNow(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawMeshNow(mesh: Mesh, matrix: Matrix4x4): void;
    DrawProcedural(material: Material, bounds: Bounds, topology: MeshTopology, vertexCount: number, instanceCount: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProcedural(material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: number, instanceCount: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: ComputeBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: GraphicsBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralNow(topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    DrawProceduralNow(topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: number, instanceCount: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, color: Color, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, color: Color, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, color: Color): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture): void;
    ExecuteCommandBuffer(buffer: CommandBuffer): void;
    ExecuteCommandBufferAsync(buffer: CommandBuffer, queueType: ComputeQueueType): void;
    RenderMesh(rparams: unknown, mesh: Mesh, submeshIndex: number, objectToWorld: Matrix4x4, prevObjectToWorld: unknown): void;
    RenderMeshIndirect(rparams: unknown, mesh: Mesh, commandBuffer: GraphicsBuffer, commandCount: number, startCommand: number): void;
    RenderMeshInstanced<T>(rparams: unknown, mesh: Mesh, submeshIndex: number, instanceData: CSArray<T>, instanceCount: number, startInstance: number): void;
    RenderMeshInstanced<T>(rparams: unknown, mesh: Mesh, submeshIndex: number, instanceData: CSArray<T>, instanceCount: number, startInstance: number): void;
    RenderMeshInstanced<T>(rparams: RenderParams, mesh: Mesh, submeshIndex: number, instanceData: CSArray<T>, instanceCount: number, startInstance: number): void;
    RenderMeshPrimitives(rparams: unknown, mesh: Mesh, submeshIndex: number, instanceCount: number): void;
    RenderPrimitives(rparams: unknown, topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    RenderPrimitivesIndexed(rparams: unknown, topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: number, startIndex: number, instanceCount: number): void;
    RenderPrimitivesIndexedIndirect(rparams: unknown, topology: MeshTopology, indexBuffer: GraphicsBuffer, commandBuffer: GraphicsBuffer, commandCount: number, startCommand: number): void;
    RenderPrimitivesIndirect(rparams: unknown, topology: MeshTopology, commandBuffer: GraphicsBuffer, commandCount: number, startCommand: number): void;
    SetRandomWriteTarget(index: number, uav: RenderTexture): void;
    SetRandomWriteTarget(index: number, uav: ComputeBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, uav: GraphicsBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, uav: ComputeBuffer): void;
    SetRandomWriteTarget(index: number, uav: GraphicsBuffer): void;
    SetRenderTarget(rt: RenderTexture, mipLevel: number, face: CubemapFace, depthSlice: number): void;
    SetRenderTarget(rt: GraphicsTexture, mipLevel: number, face: CubemapFace, depthSlice: number): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: number, face: CubemapFace, depthSlice: number): void;
    SetRenderTarget(colorBuffers: CSArray<RenderBuffer>, depthBuffer: RenderBuffer): void;
    SetRenderTarget(setup: RenderTargetSetup): void;
    SetRenderTarget(rt: RenderTexture): void;
    SetRenderTarget(rt: RenderTexture, mipLevel: number): void;
    SetRenderTarget(rt: RenderTexture, mipLevel: number, face: CubemapFace): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: number): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: number, face: CubemapFace): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStage): void;

}
declare const Graphics: GraphicsConstructor;
    
interface StandaloneFileBrowser {





}
    
interface ExtensionFilter {
    Name: string;
    Extensions: CSArray<string>;





}
    
interface ExtensionFilterConstructor {


    new(filterName: string, filterExtensions: CSArray<string>): ExtensionFilter;



}
declare const ExtensionFilter: ExtensionFilterConstructor;
    
interface StandaloneFileBrowserConstructor {


    new(): StandaloneFileBrowser;


    OpenFilePanel(title: string, directory: string, extension: string, multiselect: boolean): CSArray<string>;
    OpenFilePanel(title: string, directory: string, extensions: CSArray<ExtensionFilter>, multiselect: boolean): CSArray<string>;
    OpenFilePanelAsync(title: string, directory: string, extension: string, multiselect: boolean, cb: unknown): void;
    OpenFilePanelAsync(title: string, directory: string, extensions: CSArray<ExtensionFilter>, multiselect: boolean, cb: unknown): void;
    OpenFolderPanel(title: string, directory: string, multiselect: boolean): CSArray<string>;
    OpenFolderPanelAsync(title: string, directory: string, multiselect: boolean, cb: unknown): void;
    SaveFilePanel(title: string, directory: string, defaultName: string, extension: string): string;
    SaveFilePanel(title: string, directory: string, defaultName: string, extensions: CSArray<ExtensionFilter>): string;
    SaveFilePanelAsync(title: string, directory: string, defaultName: string, extension: string, cb: unknown): void;
    SaveFilePanelAsync(title: string, directory: string, defaultName: string, extensions: CSArray<ExtensionFilter>, cb: unknown): void;

}
declare const StandaloneFileBrowser: StandaloneFileBrowserConstructor;
    
interface UnityWebRequestTexture {





}
    
interface UnityWebRequestTextureConstructor {




    GetTexture(uri: string): UnityWebRequest;
    GetTexture(uri: unknown): UnityWebRequest;
    GetTexture(uri: string, nonReadable: boolean): UnityWebRequest;
    GetTexture(uri: unknown, nonReadable: boolean): UnityWebRequest;

}
declare const UnityWebRequestTexture: UnityWebRequestTextureConstructor;
    
interface DownloadHandlerTexture extends DownloadHandler {
    readonly texture: Texture2D;



    Dispose(): void;


}
    
interface DownloadHandlerTextureConstructor {


    new(): DownloadHandlerTexture;
    new(readable: boolean): DownloadHandlerTexture;


    GetContent(www: UnityWebRequest): Texture2D;

}
declare const DownloadHandlerTexture: DownloadHandlerTextureConstructor;
    
interface UIOutline extends Graphic {
    readonly mainTexture: Texture;





}
    
interface UIOutlineConstructor {


    new(): UIOutline;



}
declare const UIOutline: UIOutlineConstructor;
    
interface IDropHandler extends IEventSystemHandler {



    OnDrop(eventData: PointerEventData): void;


}
    
interface EventTrigger extends MonoBehaviour, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler {
    triggers: CSArray<Entry>;



    OnBeginDrag(eventData: PointerEventData): void;
    OnCancel(eventData: BaseEventData): void;
    OnDeselect(eventData: BaseEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnDrop(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    OnUpdateSelected(eventData: BaseEventData): void;


}
    
interface Entry {
    eventID: EventTriggerType;





}
    
interface EntryConstructor {


    new(): Entry;



}
declare const Entry: EntryConstructor;
    
interface CharacterMovementData extends MonoBehaviour {
    characterHeight: number;
    characterRadius: number;
    colliderGroundOffset: number;
    onlySprintForward: boolean;
    useAccelerationMovement: boolean;
    speed: number;
    sprintSpeed: number;
    accelerationForce: number;
    sprintAccelerationForce: number;
    minAccelerationDelta: number;
    inAirDirectionalControl: number;
    accelerationTurnFriction: number;
    autoCrouch: boolean;
    preventFallingWhileCrouching: boolean;
    preventStepUpWhileCrouching: boolean;
    crouchSpeedMultiplier: number;
    crouchHeightMultiplier: number;
    numberOfJumps: number;
    jumpSpeed: number;
    jumpCoyoteTime: number;
    allowDebugFlying: boolean;
    flySpeedMultiplier: number;
    verticalFlySpeed: number;
    jumpUpBlockCooldown: number;
    useGravity: boolean;
    useGravityWhileGrounded: boolean;
    alwaysSnapToGround: boolean;
    gravityMultiplier: number;
    upwardsGravityMultiplier: number;
    groundCollisionLayerMask: LayerMask;
    terminalVelocity: number;
    minimumVelocity: number;
    useMinimumVelocityInAir: boolean;
    preventWallClipping: boolean;
    drag: number;
    airDragMultiplier: number;
    airSpeedMultiplier: number;
    detectStepUps: boolean;
    alwaysStepUp: boolean;
    assistedLedgeJump: boolean;
    maxStepUpHeight: number;
    stepUpRampDistance: number;
    detectSlopes: boolean;
    slopeForce: number;
    minSlopeDelta: number;
    maxSlopeDelta: number;





}
    
interface CharacterMovementDataConstructor {


    new(): CharacterMovementData;



}
declare const CharacterMovementData: CharacterMovementDataConstructor;
    
interface Terrain extends Behaviour {
    terrainData: TerrainData;
    treeDistance: number;
    treeBillboardDistance: number;
    treeCrossFadeLength: number;
    treeMaximumFullLODCount: number;
    detailObjectDistance: number;
    detailObjectDensity: number;
    heightmapPixelError: number;
    heightmapMaximumLOD: number;
    heightmapMinimumLODSimplification: number;
    basemapDistance: number;
    lightmapIndex: number;
    realtimeLightmapIndex: number;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;
    keepUnusedRenderingResources: boolean;
    shadowCastingMode: ShadowCastingMode;
    reflectionProbeUsage: ReflectionProbeUsage;
    materialTemplate: Material;
    drawHeightmap: boolean;
    allowAutoConnect: boolean;
    groupingID: number;
    drawInstanced: boolean;
    enableHeightmapRayTracing: boolean;
    readonly normalmapTexture: RenderTexture;
    drawTreesAndFoliage: boolean;
    patchBoundsMultiplier: Vector3;
    treeLODBiasMultiplier: number;
    collectDetailPatches: boolean;
    ignoreQualitySettings: boolean;
    editorRenderFlags: TerrainRenderFlags;
    bakeLightProbesForTrees: boolean;
    deringLightProbesForTrees: boolean;
    treeMotionVectorModeOverride: TreeMotionVectorModeOverride;
    preserveTreePrototypeLayers: boolean;
    readonly leftNeighbor: Terrain;
    readonly rightNeighbor: Terrain;
    readonly topNeighbor: Terrain;
    readonly bottomNeighbor: Terrain;
    renderingLayerMask: number;



    AddTreeInstance(instance: TreeInstance): void;
    Flush(): void;
    GetClosestReflectionProbes(result: CSArray<ReflectionProbeBlendInfo>): void;
    GetKeepUnusedCameraRenderingResources(cameraInstanceID: number): boolean;
    GetPosition(): Vector3;
    GetSplatMaterialPropertyBlock(dest: MaterialPropertyBlock): void;
    SampleHeight(worldPosition: Vector3): number;
    SetKeepUnusedCameraRenderingResources(cameraInstanceID: number, keepUnused: boolean): void;
    SetNeighbors(left: Terrain, top: Terrain, right: Terrain, bottom: Terrain): void;
    SetSplatMaterialPropertyBlock(properties: MaterialPropertyBlock): void;


}
    
interface TerrainConstructor {
    readonly heightmapFormat: GraphicsFormat;
    readonly heightmapTextureFormat: TextureFormat;
    readonly heightmapRenderTextureFormat: RenderTextureFormat;
    readonly normalmapFormat: GraphicsFormat;
    readonly normalmapTextureFormat: TextureFormat;
    readonly normalmapRenderTextureFormat: RenderTextureFormat;
    readonly holesFormat: GraphicsFormat;
    readonly holesRenderTextureFormat: RenderTextureFormat;
    readonly compressedHolesFormat: GraphicsFormat;
    readonly compressedHolesTextureFormat: TextureFormat;
    readonly activeTerrain: Terrain;
    readonly activeTerrains: CSArray<Terrain>;


    new(): Terrain;


    CreateTerrainGameObject(assignTerrain: TerrainData): GameObject;
    GetActiveTerrains(terrainList: CSArray<Terrain>): void;
    SetConnectivityDirty(): void;

}
declare const Terrain: TerrainConstructor;
    
interface GraphicRaycaster extends BaseRaycaster {
    readonly sortOrderPriority: number;
    readonly renderOrderPriority: number;
    ignoreReversedGraphics: boolean;
    blockingObjects: BlockingObjects;
    blockingMask: LayerMask;
    readonly eventCamera: Camera;



    Raycast(eventData: PointerEventData, resultAppendList: CSArray<RaycastResult>): void;


}
    
interface IPostProcessComponent {



    IsActive(): boolean;


}
    
interface IApplyRevertPropertyContextMenuItemProvider {



    GetSourceName(comp: Component): string;
    GetSourceTerm(): string;
    TryGetApplyMethodForFieldName(property: SerializedProperty, applyMethod: unknown): boolean;
    TryGetRevertMethodForFieldName(property: SerializedProperty, revertMethod: unknown): boolean;


}
    
interface SerializedProperty {
    readonly serializedObject: SerializedObject;
    exposedReferenceValue: Object;
    boxedValue: unknown;
    readonly hasMultipleDifferentValues: boolean;
    readonly displayName: string;
    readonly name: string;
    readonly type: string;
    readonly arrayElementType: string;
    readonly tooltip: string;
    readonly depth: number;
    readonly propertyPath: string;
    readonly editable: boolean;
    readonly isAnimated: boolean;
    isExpanded: boolean;
    readonly hasChildren: boolean;
    readonly hasVisibleChildren: boolean;
    readonly isInstantiatedPrefab: boolean;
    prefabOverride: boolean;
    readonly isDefaultOverride: boolean;
    readonly propertyType: SerializedPropertyType;
    readonly numericType: SerializedPropertyNumericType;
    intValue: number;
    longValue: number;
    ulongValue: number;
    uintValue: number;
    boolValue: boolean;
    floatValue: number;
    doubleValue: number;
    stringValue: string;
    colorValue: Color;
    animationCurveValue: AnimationCurve;
    gradientValue: Gradient;
    objectReferenceValue: Object;
    managedReferenceValue: unknown;
    managedReferenceId: number;
    readonly managedReferenceFullTypename: string;
    readonly managedReferenceFieldTypename: string;
    objectReferenceInstanceIDValue: number;
    enumValueIndex: number;
    enumValueFlag: number;
    readonly enumNames: CSArray<string>;
    readonly enumDisplayNames: CSArray<string>;
    vector2Value: Vector2;
    vector3Value: Vector3;
    vector4Value: Vector4;
    vector2IntValue: Vector2Int;
    vector3IntValue: Vector3;
    quaternionValue: Quaternion;
    rectValue: Rect;
    rectIntValue: RectInt;
    boundsValue: Bounds;
    boundsIntValue: BoundsInt;
    hash128Value: Hash128;
    readonly isArray: boolean;
    arraySize: number;
    readonly minArraySize: number;
    readonly isFixedBuffer: boolean;
    readonly fixedBufferSize: number;
    readonly contentHash: number;



    ClearArray(): void;
    Copy(): SerializedProperty;
    CountInProperty(): number;
    CountRemaining(): number;
    DeleteArrayElementAtIndex(index: number): void;
    DeleteCommand(): boolean;
    Dispose(): void;
    DuplicateCommand(): boolean;
    FindPropertyRelative(relativePropertyPath: string): SerializedProperty;
    GetArrayElementAtIndex(index: number): SerializedProperty;
    GetEndProperty(): SerializedProperty;
    GetEndProperty(includeInvisible: boolean): SerializedProperty;
    GetEnumerator(): unknown;
    GetFixedBufferElementAtIndex(index: number): SerializedProperty;
    InsertArrayElementAtIndex(index: number): void;
    MoveArrayElement(srcIndex: number, dstIndex: number): boolean;
    Next(enterChildren: boolean): boolean;
    NextVisible(enterChildren: boolean): boolean;
    Reset(): void;


}
    
interface SerializedObject {
    readonly targetObject: Object;
    readonly targetObjects: CSArray<Object>;
    readonly context: Object;
    readonly hasModifiedProperties: boolean;
    readonly isEditingMultipleObjects: boolean;
    maxArraySizeForMultiEditing: number;
    forceChildVisibility: boolean;



    ApplyModifiedProperties(): boolean;
    ApplyModifiedPropertiesWithoutUndo(): boolean;
    CopyFromSerializedProperty(prop: SerializedProperty): void;
    CopyFromSerializedPropertyIfDifferent(prop: SerializedProperty): boolean;
    Dispose(): void;
    FindProperty(propertyPath: string): SerializedProperty;
    GetIterator(): SerializedProperty;
    SetIsDifferentCacheDirty(): void;
    Update(): void;
    UpdateIfRequiredOrScript(): boolean;


}
    
interface SerializedObjectConstructor {


    new(obj: Object): SerializedObject;
    new(obj: Object, context: Object): SerializedObject;
    new(objs: CSArray<Object>): SerializedObject;
    new(objs: CSArray<Object>, context: Object): SerializedObject;



}
declare const SerializedObject: SerializedObjectConstructor;
    
interface BoundsInt {
    x: number;
    y: number;
    z: number;
    readonly center: Vector3;
    min: Vector3;
    max: Vector3;
    xMin: number;
    yMin: number;
    zMin: number;
    xMax: number;
    yMax: number;
    zMax: number;
    position: Vector3;
    size: Vector3;
    readonly allPositionsWithin: PositionEnumerator;



    ClampToBounds(bounds: BoundsInt): void;
    Contains(position: Vector3): boolean;
    Equals(other: unknown): boolean;
    Equals(other: BoundsInt): boolean;
    GetHashCode(): number;
    SetMinMax(minPosition: Vector3, maxPosition: Vector3): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;


}
    
interface PositionEnumerator {
    readonly Current: Vector3;



    GetEnumerator(): PositionEnumerator;
    MoveNext(): boolean;
    Reset(): void;


}
    
interface PositionEnumeratorConstructor {


    new(min: Vector3, max: Vector3): PositionEnumerator;



}
declare const PositionEnumerator: PositionEnumeratorConstructor;
    
interface BoundsIntConstructor {


    new(xMin: number, yMin: number, zMin: number, sizeX: number, sizeY: number, sizeZ: number): BoundsInt;
    new(position: Vector3, size: Vector3): BoundsInt;



}
declare const BoundsInt: BoundsIntConstructor;
    
interface SerializedPropertyConstructor {




    DataEquals(x: SerializedProperty, y: SerializedProperty): boolean;
    EqualContents(x: SerializedProperty, y: SerializedProperty): boolean;

}
declare const SerializedProperty: SerializedPropertyConstructor;
    
interface VolumeComponent extends ScriptableObject, IApplyRevertPropertyContextMenuItemProvider {
    active: boolean;
    readonly displayName: string;
    readonly parameters: CSArray<VolumeParameter>;



    AnyPropertiesIsOverridden(): boolean;
    GetHashCode(): number;
    GetSourceName(comp: Component): string;
    GetSourceTerm(): string;
    Override(state: VolumeComponent, interpFactor: number): void;
    Release(): void;
    SetAllOverridesTo(state: boolean): void;
    TryGetApplyMethodForFieldName(property: SerializedProperty, applyMethod: unknown): boolean;
    TryGetRevertMethodForFieldName(property: SerializedProperty, revertMethod: unknown): boolean;


}
    
interface VolumeParameter {
    overrideState: boolean;



    Clone(): unknown;
    GetValue<T>(): T;
    Release(): void;
    SetValue(parameter: VolumeParameter): void;


}
    
interface VolumeParameterConstructor {
    k_DebuggerDisplay: string;




    IsObjectParameter(type: unknown): boolean;

}
declare const VolumeParameter: VolumeParameterConstructor;
    
interface VolumeComponentConstructor {


    new(): VolumeComponent;



}
declare const VolumeComponent: VolumeComponentConstructor;
    
interface DepthOfField extends VolumeComponent, IPostProcessComponent {
    mode: DepthOfFieldModeParameter;
    gaussianStart: MinFloatParameter;
    gaussianEnd: MinFloatParameter;
    gaussianMaxRadius: ClampedFloatParameter;
    highQualitySampling: BoolParameter;
    focusDistance: MinFloatParameter;
    aperture: ClampedFloatParameter;
    focalLength: ClampedFloatParameter;
    bladeCount: ClampedIntParameter;
    bladeCurvature: ClampedFloatParameter;
    bladeRotation: ClampedFloatParameter;



    IsActive(): boolean;


}
    
interface VolumeParameter<T> extends VolumeParameter {
    value: T;



    Clone(): unknown;
    Equals(other: VolumeParameter<T>): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    Interp(from: T, to: T, t: number): void;
    Override(x: T): void;
    SetValue(parameter: VolumeParameter): void;
    ToString(): string;


}
    
interface VolumeParameterConstructor {


    new(): VolumeParameter<T>;



}
declare const VolumeParameter: VolumeParameterConstructor;
    
interface DepthOfFieldModeParameter extends VolumeParameter<DepthOfFieldMode> {





}
    
interface DepthOfFieldModeParameterConstructor {


    new(value: DepthOfFieldMode, overrideState: boolean): DepthOfFieldModeParameter;



}
declare const DepthOfFieldModeParameter: DepthOfFieldModeParameterConstructor;
    
interface FloatParameter extends VolumeParameter<number> {



    Interp(from: number, to: number, t: number): void;


}
    
interface FloatParameterConstructor {


    new(value: number, overrideState: boolean): FloatParameter;



}
declare const FloatParameter: FloatParameterConstructor;
    
interface MinFloatParameter extends FloatParameter {
    min: number;
    value: number;





}
    
interface MinFloatParameterConstructor {


    new(value: number, min: number, overrideState: boolean): MinFloatParameter;



}
declare const MinFloatParameter: MinFloatParameterConstructor;
    
interface ClampedFloatParameter extends FloatParameter {
    min: number;
    max: number;
    value: number;





}
    
interface ClampedFloatParameterConstructor {


    new(value: number, min: number, max: number, overrideState: boolean): ClampedFloatParameter;



}
declare const ClampedFloatParameter: ClampedFloatParameterConstructor;
    
interface BoolParameter extends VolumeParameter<boolean> {
    displayType: DisplayType;





}
    
interface BoolParameterConstructor {


    new(value: boolean, overrideState: boolean): BoolParameter;
    new(value: boolean, displayType: DisplayType, overrideState: boolean): BoolParameter;



}
declare const BoolParameter: BoolParameterConstructor;
    
interface IntParameter extends VolumeParameter<number> {



    Interp(from: number, to: number, t: number): void;


}
    
interface IntParameterConstructor {


    new(value: number, overrideState: boolean): IntParameter;



}
declare const IntParameter: IntParameterConstructor;
    
interface ClampedIntParameter extends IntParameter {
    min: number;
    max: number;
    value: number;





}
    
interface ClampedIntParameterConstructor {


    new(value: number, min: number, max: number, overrideState: boolean): ClampedIntParameter;



}
declare const ClampedIntParameter: ClampedIntParameterConstructor;
    
interface DepthOfFieldConstructor {


    new(): DepthOfField;



}
declare const DepthOfField: DepthOfFieldConstructor;
    
interface IVolume {
    isGlobal: boolean;
    readonly colliders: CSArray<Collider>;





}
    
interface Volume extends MonoBehaviour, IVolume {
    priority: number;
    blendDistance: number;
    weight: number;
    sharedProfile: VolumeProfile;
    isGlobal: boolean;
    profile: VolumeProfile;
    readonly colliders: CSArray<Collider>;



    HasInstantiatedProfile(): boolean;


}
    
    
    
interface VolumeConstructor {


    new(): Volume;



}
declare const Volume: VolumeConstructor;
    
interface LensDistortion extends VolumeComponent, IPostProcessComponent {
    intensity: ClampedFloatParameter;
    xMultiplier: ClampedFloatParameter;
    yMultiplier: ClampedFloatParameter;
    center: Vector2Parameter;
    scale: ClampedFloatParameter;



    IsActive(): boolean;


}
    
interface Vector2Parameter extends VolumeParameter<Vector2> {



    Interp(from: Vector2, to: Vector2, t: number): void;


}
    
interface Vector2ParameterConstructor {


    new(value: Vector2, overrideState: boolean): Vector2Parameter;



}
declare const Vector2Parameter: Vector2ParameterConstructor;
    
interface LensDistortionConstructor {


    new(): LensDistortion;



}
declare const LensDistortion: LensDistortionConstructor;
    
interface Vignette extends VolumeComponent, IPostProcessComponent {
    color: ColorParameter;
    center: Vector2Parameter;
    intensity: ClampedFloatParameter;
    smoothness: ClampedFloatParameter;
    rounded: BoolParameter;



    IsActive(): boolean;


}
    
interface ColorParameter extends VolumeParameter<Color> {
    hdr: boolean;
    showAlpha: boolean;
    showEyeDropper: boolean;



    Interp(from: Color, to: Color, t: number): void;


}
    
interface ColorParameterConstructor {


    new(value: Color, overrideState: boolean): ColorParameter;
    new(value: Color, hdr: boolean, showAlpha: boolean, showEyeDropper: boolean, overrideState: boolean): ColorParameter;



}
declare const ColorParameter: ColorParameterConstructor;
    
interface VignetteConstructor {


    new(): Vignette;



}
declare const Vignette: VignetteConstructor;
    
interface NetworkServer {





}
    
interface InterestManagementBase extends MonoBehaviour {



    OnCheckObserver(identity: NetworkIdentity, newObserver: NetworkConnectionToClient): boolean;
    OnDestroyed(identity: NetworkIdentity): void;
    OnSpawned(identity: NetworkIdentity): void;
    Rebuild(identity: NetworkIdentity, initialize: boolean): void;
    ResetState(): void;
    SetHostVisibility(identity: NetworkIdentity, visible: boolean): void;


}
    
interface TimeSample {
    average: number;



    Begin(): void;
    End(): void;


}
    
interface TimeSampleConstructor {


    new(n: number): TimeSample;



}
declare const TimeSample: TimeSampleConstructor;
    
interface LocalConnectionToClient extends NetworkConnectionToClient {



    Disconnect(): void;


}
    
interface LocalConnectionToClientConstructor {


    new(): LocalConnectionToClient;



}
declare const LocalConnectionToClient: LocalConnectionToClientConstructor;
    
interface NetworkServerConstructor {
    maxConnections: number;
    tickRate: number;
    connections: CSDictionary<number, NetworkConnectionToClient>;
    readonly spawned: CSDictionary<number, NetworkIdentity>;
    dontListen: boolean;
    isLoadingScene: boolean;
    aoi: InterestManagementBase;
    exceptionsDisconnect: boolean;
    disconnectInactiveConnections: boolean;
    disconnectInactiveTimeout: number;
    OnConnectedEvent: unknown;
    OnDisconnectedEvent: unknown;
    OnErrorEvent: unknown;
    OnTransportExceptionEvent: unknown;
    actualTickRate: number;
    earlyUpdateDuration: TimeSample;
    lateUpdateDuration: TimeSample;
    fullUpdateDuration: TimeSample;
    readonly tickInterval: number;
    readonly sendRate: number;
    readonly sendInterval: number;
    readonly localConnection: LocalConnectionToClient;
    readonly active: boolean;
    readonly activeHost: boolean;




    AddConnection(conn: NetworkConnectionToClient): boolean;
    AddPlayerForConnection(conn: NetworkConnectionToClient, player: GameObject, assetId: number): boolean;
    AddPlayerForConnection(conn: NetworkConnectionToClient, player: GameObject): boolean;
    ClearHandlers(): void;
    Destroy(obj: GameObject): void;
    DestroyPlayerForConnection(conn: NetworkConnectionToClient): void;
    DisconnectAll(): void;
    HasExternalConnections(): boolean;
    Listen(maxConns: number): void;
    RebuildObservers(identity: NetworkIdentity, initialize: boolean): void;
    RegisterHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    RegisterHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    RemoveConnection(connectionId: number): boolean;
    RemovePlayerForConnection(conn: NetworkConnectionToClient, removeOptions: RemovePlayerOptions): void;
    ReplaceHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    ReplaceHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    ReplaceHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    ReplacePlayerForConnection(conn: NetworkConnectionToClient, player: GameObject, keepAuthority: boolean): boolean;
    ReplacePlayerForConnection(conn: NetworkConnectionToClient, player: GameObject, assetId: number, keepAuthority: boolean): boolean;
    SendToAll<T>(message: T, channelId: number, sendToReadyOnly: boolean): void;
    SendToReady<T>(message: T, channelId: number): void;
    SendToReadyObservers<T>(identity: NetworkIdentity, message: T, includeOwner: boolean, channelId: number): void;
    SendToReadyObservers<T>(identity: NetworkIdentity, message: T, channelId: number): void;
    SetAllClientsNotReady(): void;
    SetClientNotReady(conn: NetworkConnectionToClient): void;
    SetClientReady(conn: NetworkConnectionToClient): void;
    Shutdown(): void;
    Spawn(obj: GameObject, ownerPlayer: GameObject): void;
    Spawn(obj: GameObject): void;
    Spawn(obj: GameObject, ownerConnection: NetworkConnection): void;
    Spawn(obj: GameObject, assetId: number, ownerConnection: NetworkConnection): void;
    SpawnObjects(): boolean;
    UnregisterHandler<T>(): void;
    UnSpawn(obj: GameObject): void;

}
declare const NetworkServer: NetworkServerConstructor;
    
interface NetworkClient {





}
    
interface SnapshotInterpolationSettings {
    bufferTimeMultiplier: number;
    bufferLimit: number;
    catchupNegativeThreshold: number;
    catchupPositiveThreshold: number;
    catchupSpeed: number;
    slowdownSpeed: number;
    driftEmaDuration: number;
    dynamicAdjustment: boolean;
    dynamicAdjustmentTolerance: number;
    deliveryTimeEmaDuration: number;





}
    
interface SnapshotInterpolationSettingsConstructor {


    new(): SnapshotInterpolationSettings;



}
declare const SnapshotInterpolationSettings: SnapshotInterpolationSettingsConstructor;
    
interface SpawnDelegate {



    BeginInvoke(position: Vector3, assetId: number, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): GameObject;
    Invoke(position: Vector3, assetId: number): GameObject;


}
    
interface SpawnDelegateConstructor {


    new(object: unknown, method: unknown): SpawnDelegate;



}
declare const SpawnDelegate: SpawnDelegateConstructor;
    
interface UnSpawnDelegate {



    BeginInvoke(spawned: GameObject, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(spawned: GameObject): void;


}
    
interface UnSpawnDelegateConstructor {


    new(object: unknown, method: unknown): UnSpawnDelegate;



}
declare const UnSpawnDelegate: UnSpawnDelegateConstructor;
    
interface SpawnHandlerDelegate {



    BeginInvoke(msg: SpawnMessage, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): GameObject;
    Invoke(msg: SpawnMessage): GameObject;


}
    
interface NetworkMessage {





}
    
interface SpawnMessage extends NetworkMessage {
    netId: number;
    isLocalPlayer: boolean;
    isOwner: boolean;
    sceneId: number;
    assetId: number;
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    payload: CSArray<number>;





}
    
interface SpawnHandlerDelegateConstructor {


    new(object: unknown, method: unknown): SpawnHandlerDelegate;



}
declare const SpawnHandlerDelegate: SpawnHandlerDelegateConstructor;
    
interface NetworkClientConstructor {
    exceptionsDisconnect: boolean;
    readonly spawned: CSDictionary<number, NetworkIdentity>;
    ready: boolean;
    OnConnectedEvent: unknown;
    OnDisconnectedEvent: unknown;
    OnErrorEvent: unknown;
    OnTransportExceptionEvent: unknown;
    readonly prefabs: CSDictionary<number, GameObject>;
    aoi: InterestManagementBase;
    isLoadingScene: boolean;
    connectionQuality: ConnectionQuality;
    lastConnectionQuality: ConnectionQuality;
    connectionQualityMethod: ConnectionQualityMethod;
    connectionQualityInterval: number;
    snapshotSettings: SnapshotInterpolationSettings;
    bufferTimeMultiplier: number;
    snapshots: CSDictionary<number, TimeSnapshot>;
    dynamicAdjustment: boolean;
    dynamicAdjustmentTolerance: number;
    deliveryTimeEmaDuration: number;
    readonly sendRate: number;
    readonly sendInterval: number;
    readonly connection: NetworkConnection;
    readonly localPlayer: NetworkIdentity;
    readonly active: boolean;
    readonly activeHost: boolean;
    readonly isConnecting: boolean;
    readonly isConnected: boolean;
    readonly initialBufferTime: number;
    readonly bufferTime: number;




    AddPlayer(): boolean;
    ClearSpawners(): void;
    Connect(address: string): void;
    Connect(uri: unknown): void;
    ConnectHost(): void;
    DestroyAllClientObjects(): void;
    Disconnect(): void;
    GetPrefab(assetId: number, prefab: unknown): boolean;
    OnGUI(): void;
    OnTimeSnapshot(snap: TimeSnapshot): void;
    PrepareToSpawnSceneObjects(): void;
    Ready(): boolean;
    RegisterHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    RegisterHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    RegisterPrefab(prefab: GameObject, newAssetId: number): void;
    RegisterPrefab(prefab: GameObject): void;
    RegisterPrefab(prefab: GameObject, newAssetId: number, spawnHandler: SpawnDelegate, unspawnHandler: UnSpawnDelegate): void;
    RegisterPrefab(prefab: GameObject, spawnHandler: SpawnDelegate, unspawnHandler: UnSpawnDelegate): void;
    RegisterPrefab(prefab: GameObject, newAssetId: number, spawnHandler: SpawnHandlerDelegate, unspawnHandler: UnSpawnDelegate): void;
    RegisterPrefab(prefab: GameObject, spawnHandler: SpawnHandlerDelegate, unspawnHandler: UnSpawnDelegate): void;
    RegisterSpawnHandler(assetId: number, spawnHandler: SpawnDelegate, unspawnHandler: UnSpawnDelegate): void;
    RegisterSpawnHandler(assetId: number, spawnHandler: SpawnHandlerDelegate, unspawnHandler: UnSpawnDelegate): void;
    ReplaceHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    ReplaceHandler<T>(handler: unknown, requireAuthentication: boolean): void;
    Send<T>(message: T, channelId: number): void;
    Shutdown(): void;
    UnregisterHandler<T>(): boolean;
    UnregisterPrefab(prefab: GameObject): void;
    UnregisterSpawnHandler(assetId: number): void;

    readonly onConnectionQualityChanged: MonoSignal<ConnectionQuality, ConnectionQuality>;
}
declare const NetworkClient: NetworkClientConstructor;
    
interface NetworkTransformBase extends NetworkBehaviour {
    target: Transform;
    readonly clientSnapshots: CSDictionary<number, TransformSnapshot>;
    readonly serverSnapshots: CSDictionary<number, TransformSnapshot>;
    syncPosition: boolean;
    syncRotation: boolean;
    syncScale: boolean;
    onlySyncOnChange: boolean;
    compressRotation: boolean;
    interpolatePosition: boolean;
    interpolateRotation: boolean;
    interpolateScale: boolean;
    coordinateSpace: CoordinateSpace;
    sendIntervalMultiplier: number;
    timelineOffset: boolean;
    showGizmos: boolean;
    showOverlay: boolean;
    overlayColor: Color;



    CmdTeleport(destination: Vector3): void;
    CmdTeleport(destination: Vector3, rotation: Quaternion): void;
    Reset(): void;
    ResetState(): void;
    RpcTeleport(destination: Vector3): void;
    RpcTeleport(destination: Vector3, rotation: Quaternion): void;
    Weaved(): boolean;


}
    
interface TransformSnapshot extends Snapshot {
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    remoteTime: number;
    localTime: number;



    ToString(): string;


}
    
interface TransformSnapshotConstructor {


    new(remoteTime: number, localTime: number, position: Vector3, rotation: Quaternion, scale: Vector3): TransformSnapshot;


    Interpolate(from: TransformSnapshot, to: TransformSnapshot, t: number): TransformSnapshot;

}
declare const TransformSnapshot: TransformSnapshotConstructor;
    
interface NetworkTransformUnreliable extends NetworkTransformBase {
    bufferResetMultiplier: number;
    positionSensitivity: number;
    rotationSensitivity: number;
    scaleSensitivity: number;



    OnDeserialize(reader: NetworkReader, initialState: boolean): void;
    OnSerialize(writer: NetworkWriter, initialState: boolean): void;
    Weaved(): boolean;


}
    
interface NetworkTransformUnreliableConstructor {


    new(): NetworkTransformUnreliable;



}
declare const NetworkTransformUnreliable: NetworkTransformUnreliableConstructor;
    
    
    
interface NetworkTransformReliable extends NetworkTransformBase {
    onlySyncOnChangeCorrectionMultiplier: number;
    rotationSensitivity: number;
    positionPrecision: number;
    scalePrecision: number;



    OnDeserialize(reader: NetworkReader, initialState: boolean): void;
    OnSerialize(writer: NetworkWriter, initialState: boolean): void;
    ResetState(): void;
    Weaved(): boolean;


}
    
interface NetworkTransformReliableConstructor {


    new(): NetworkTransformReliable;



}
declare const NetworkTransformReliable: NetworkTransformReliableConstructor;
    
interface NetworkAnimator extends NetworkBehaviour {
    clientAuthority: boolean;
    animator: Animator;
    _Mirror_SyncVarHookDelegate_animatorSpeed: unknown;
    NetworkanimatorSpeed: number;



    DeserializeSyncVars(reader: NetworkReader, initialState: boolean): void;
    OnDeserialize(reader: NetworkReader, initialState: boolean): void;
    OnSerialize(writer: NetworkWriter, initialState: boolean): void;
    Reset(): void;
    ResetTrigger(triggerName: string): void;
    ResetTrigger(hash: number): void;
    SerializeSyncVars(writer: NetworkWriter, forceAll: boolean): void;
    SetTrigger(triggerName: string): void;
    SetTrigger(hash: number): void;
    Weaved(): boolean;


}
    
interface NetworkAnimatorConstructor {


    new(): NetworkAnimator;



}
declare const NetworkAnimator: NetworkAnimatorConstructor;
    
interface NetworkConnectionToServer extends NetworkConnection {



    Disconnect(): void;


}
    
interface NetworkConnectionToServerConstructor {


    new(): NetworkConnectionToServer;



}
declare const NetworkConnectionToServer: NetworkConnectionToServerConstructor;
    
    
    
interface PredictedRigidbody extends NetworkBehaviour {
    predictedRigidbody: Rigidbody;
    mode: PredictionMode;
    motionSmoothingVelocityThreshold: number;
    motionSmoothingAngularVelocityThreshold: number;
    motionSmoothingTimeTolerance: number;
    stateHistoryLimit: number;
    recordInterval: number;
    onlyRecordChanges: boolean;
    compareLastFirst: boolean;
    positionCorrectionThreshold: number;
    rotationCorrectionThreshold: number;
    oneFrameAhead: boolean;
    snapThreshold: number;
    showGhost: boolean;
    ghostVelocityThreshold: number;
    localGhostMaterial: Material;
    remoteGhostMaterial: Material;
    checkGhostsEveryNthFrame: number;
    positionInterpolationSpeed: number;
    rotationInterpolationSpeed: number;
    teleportDistanceMultiplier: number;
    reduceSendsWhileIdle: boolean;



    OnDeserialize(reader: NetworkReader, initialState: boolean): void;
    OnSerialize(writer: NetworkWriter, initialState: boolean): void;
    OnStopClient(): void;
    Weaved(): boolean;


}
    
interface PredictedRigidbodyConstructor {


    new(): PredictedRigidbody;


    IsPredicted(rb: Rigidbody, predictedRigidbody: unknown): boolean;
    IsPredicted(co: Collider, predictedRigidbody: unknown): boolean;

}
declare const PredictedRigidbody: PredictedRigidbodyConstructor;
    
interface PredictedState {
    readonly timestamp: number;
    position: Vector3;
    positionDelta: Vector3;
    rotation: Quaternion;
    rotationDelta: Quaternion;
    velocity: Vector3;
    velocityDelta: Vector3;
    angularVelocity: Vector3;
    angularVelocityDelta: Vector3;





}
    
interface NativeTween {





}
    
interface NativeTweenConstructor {




    AnchoredPosition(self: Component, to: Vector2, duration: number): Tween<Vector2>;
    AnchoredPosition(self: GameObject, to: Vector2, duration: number): Tween<Vector2>;
    AnchoredPositionX(self: Component, to: number, duration: number): Tween<number>;
    AnchoredPositionX(self: GameObject, to: number, duration: number): Tween<number>;
    AnchoredPositionY(self: Component, to: number, duration: number): Tween<number>;
    AnchoredPositionY(self: GameObject, to: number, duration: number): Tween<number>;
    AnchorMax(self: Component, to: Vector2, duration: number): Tween<Vector2>;
    AnchorMax(self: GameObject, to: Vector2, duration: number): Tween<Vector2>;
    AnchorMin(self: Component, to: Vector2, duration: number): Tween<Vector2>;
    AnchorMin(self: GameObject, to: Vector2, duration: number): Tween<Vector2>;
    AudioSourcePitch(self: Component, to: number, duration: number): Tween<number>;
    AudioSourcePitch(self: GameObject, to: number, duration: number): Tween<number>;
    AudioSourcePriority(self: Component, to: number, duration: number): Tween<number>;
    AudioSourcePriority(self: GameObject, to: number, duration: number): Tween<number>;
    AudioSourceReverbZoneMix(self: Component, to: number, duration: number): Tween<number>;
    AudioSourceReverbZoneMix(self: GameObject, to: number, duration: number): Tween<number>;
    AudioSourceSpatialBlend(self: Component, to: number, duration: number): Tween<number>;
    AudioSourceSpatialBlend(self: GameObject, to: number, duration: number): Tween<number>;
    AudioSourceStereoPan(self: Component, to: number, duration: number): Tween<number>;
    AudioSourceStereoPan(self: GameObject, to: number, duration: number): Tween<number>;
    AudioSourceVolume(self: Component, to: number, duration: number): Tween<number>;
    AudioSourceVolume(self: GameObject, to: number, duration: number): Tween<number>;
    CameraFieldOfView(self: Component, to: number, duration: number): Tween<number>;
    CameraFieldOfView(self: GameObject, to: number, duration: number): Tween<number>;
    CameraOrthographicSize(self: Component, to: number, duration: number): Tween<number>;
    CameraOrthographicSize(self: GameObject, to: number, duration: number): Tween<number>;
    CancelAll(self: Component, includeChildren: boolean, includeInactive: boolean): void;
    CancelAll(self: GameObject, includeChildren: boolean, includeInactive: boolean): void;
    CanvasGroupAlpha(self: Component, to: number, duration: number): Tween<number>;
    CanvasGroupAlpha(self: GameObject, to: number, duration: number): Tween<number>;
    GraphicAlpha(self: Component, to: number, duration: number): Tween<number>;
    GraphicAlpha(self: GameObject, to: number, duration: number): Tween<number>;
    GraphicColor(self: Component, to: Color, duration: number): Tween<Color>;
    GraphicColor(self: GameObject, to: Color, duration: number): Tween<Color>;
    ImageFillAmount(self: Component, to: number, duration: number): Tween<number>;
    ImageFillAmount(self: GameObject, to: number, duration: number): Tween<number>;
    LightColor(self: Component, to: Color, duration: number): Tween<Color>;
    LightColor(self: GameObject, to: Color, duration: number): Tween<Color>;
    LightIntensity(self: Component, to: number, duration: number): Tween<number>;
    LightIntensity(self: GameObject, to: number, duration: number): Tween<number>;
    LightRange(self: Component, to: number, duration: number): Tween<number>;
    LightRange(self: GameObject, to: number, duration: number): Tween<number>;
    LightSpotAngle(self: Component, to: number, duration: number): Tween<number>;
    LightSpotAngle(self: GameObject, to: number, duration: number): Tween<number>;
    LocalPosition(self: Component, to: Vector3, duration: number): Tween<Vector3>;
    LocalPosition(self: GameObject, to: Vector3, duration: number): Tween<Vector3>;
    LocalPositionX(self: Component, to: number, duration: number): Tween<number>;
    LocalPositionX(self: GameObject, to: number, duration: number): Tween<number>;
    LocalPositionY(self: Component, to: number, duration: number): Tween<number>;
    LocalPositionY(self: GameObject, to: number, duration: number): Tween<number>;
    LocalPositionZ(self: Component, to: number, duration: number): Tween<number>;
    LocalPositionZ(self: GameObject, to: number, duration: number): Tween<number>;
    LocalRotation(self: Component, to: Vector3, duration: number): Tween<Vector3>;
    LocalRotation(self: GameObject, to: Vector3, duration: number): Tween<Vector3>;
    LocalRotationX(self: Component, to: number, duration: number): Tween<number>;
    LocalRotationX(self: GameObject, to: number, duration: number): Tween<number>;
    LocalRotationY(self: Component, to: number, duration: number): Tween<number>;
    LocalRotationY(self: GameObject, to: number, duration: number): Tween<number>;
    LocalScale(self: Component, to: Vector3, duration: number): Tween<Vector3>;
    LocalScale(self: GameObject, to: Vector3, duration: number): Tween<Vector3>;
    LocalScaleX(self: Component, to: number, duration: number): Tween<number>;
    LocalScaleX(self: GameObject, to: number, duration: number): Tween<number>;
    LocalScaleY(self: Component, to: number, duration: number): Tween<number>;
    LocalScaleY(self: GameObject, to: number, duration: number): Tween<number>;
    LocalScaleZ(self: Component, to: number, duration: number): Tween<number>;
    LocalScaleZ(self: GameObject, to: number, duration: number): Tween<number>;
    MaterialAlpha(self: Component, to: number, duration: number): Tween<number>;
    MaterialAlpha(self: GameObject, to: number, duration: number): Tween<number>;
    MaterialColor(self: Component, to: Color, duration: number): Tween<Color>;
    MaterialColor(self: GameObject, to: Color, duration: number): Tween<Color>;
    MaterialsColorProperty(self: Component, propertyName: string, from: Color, to: Color, duration: number): Tween<number>;
    MaterialsFloatProperty(self: Component, propertyName: string, from: number, to: number, duration: number): Tween<number>;
    OffsetMax(self: Component, to: Vector2, duration: number): Tween<Vector2>;
    OffsetMax(self: GameObject, to: Vector2, duration: number): Tween<Vector2>;
    OffsetMin(self: Component, to: Vector2, duration: number): Tween<Vector2>;
    OffsetMin(self: GameObject, to: Vector2, duration: number): Tween<Vector2>;
    Position(self: Component, to: Vector3, duration: number): Tween<Vector3>;
    Position(self: GameObject, to: Vector3, duration: number): Tween<Vector3>;
    PositionX(self: Component, to: number, duration: number): Tween<number>;
    PositionX(self: GameObject, to: number, duration: number): Tween<number>;
    PositionY(self: Component, to: number, duration: number): Tween<number>;
    PositionY(self: GameObject, to: number, duration: number): Tween<number>;
    PositionZ(self: Component, to: number, duration: number): Tween<number>;
    PositionZ(self: GameObject, to: number, duration: number): Tween<number>;
    RendererColor(self: Component, from: Color, to: Color, duration: number): Tween<Color>;
    RendererColor(self: GameObject, from: Color, to: Color, duration: number): Tween<Color>;
    Rotation(self: Component, to: Vector3, duration: number): Tween<Vector3>;
    Rotation(self: GameObject, to: Vector3, duration: number): Tween<Vector3>;
    RotationX(self: Component, to: number, duration: number): Tween<number>;
    RotationX(self: GameObject, to: number, duration: number): Tween<number>;
    RotationY(self: Component, to: number, duration: number): Tween<number>;
    RotationY(self: GameObject, to: number, duration: number): Tween<number>;
    RotationZ(self: Component, to: number, duration: number): Tween<number>;
    RotationZ(self: GameObject, to: number, duration: number): Tween<number>;
    SizeDelta(self: Component, to: Vector2, duration: number): Tween<Vector2>;
    SizeDelta(self: GameObject, to: Vector2, duration: number): Tween<Vector2>;
    SpriteRendererAlpha(self: Component, to: number, duration: number): Tween<number>;
    SpriteRendererAlpha(self: GameObject, to: number, duration: number): Tween<number>;
    SpriteRendererColor(self: Component, to: Color, duration: number): Tween<Color>;
    SpriteRendererColor(self: GameObject, to: Color, duration: number): Tween<Color>;
    TextMeshAlpha(self: Component, to: number, duration: number): Tween<number>;
    TextMeshAlpha(self: GameObject, to: number, duration: number): Tween<number>;
    TextMeshColor(self: Component, to: Color, duration: number): Tween<Color>;
    TextMeshColor(self: GameObject, to: Color, duration: number): Tween<Color>;
    TextMeshProAlpha(self: Component, to: number, duration: number): Tween<number>;
    TextMeshProAlpha(self: GameObject, to: number, duration: number): Tween<number>;
    TextMeshProColor(self: Component, to: Color, duration: number): Tween<Color>;
    TextMeshProColor(self: GameObject, to: Color, duration: number): Tween<Color>;
    TweenLocalRotationZ(self: Component, to: number, duration: number): Tween<number>;
    TweenLocalRotationZ(self: GameObject, to: number, duration: number): Tween<number>;
    ValueColor(self: Component, to: Color, duration: number, onUpdate: unknown): Tween<Color>;
    ValueColor(self: GameObject, to: Color, duration: number, onUpdate: unknown): Tween<Color>;
    ValueFloat(self: Component, to: number, duration: number, onUpdate: unknown): Tween<number>;
    ValueFloat(self: GameObject, to: number, duration: number, onUpdate: unknown): Tween<number>;
    ValueVector2(self: Component, to: Vector2, duration: number, onUpdate: unknown): Tween<Vector2>;
    ValueVector2(self: GameObject, to: Vector2, duration: number, onUpdate: unknown): Tween<Vector2>;
    ValueVector3(self: Component, to: Vector3, duration: number, onUpdate: unknown): Tween<Vector3>;
    ValueVector3(self: GameObject, to: Vector3, duration: number, onUpdate: unknown): Tween<Vector3>;
    VolumeWeight(self: Component, to: number, duration: number): Tween<number>;
    VolumeWeight(self: GameObject, to: number, duration: number): Tween<number>;

}
declare const NativeTween: NativeTweenConstructor;
    
interface TweenComponent<DriverValueType, ComponentType extends Component> extends Tween<DriverValueType> {



    OnInitialize(): boolean;


}
    
interface ConstantForce extends Behaviour {
    force: Vector3;
    relativeForce: Vector3;
    torque: Vector3;
    relativeTorque: Vector3;





}
    
interface ConstantForceConstructor {


    new(): ConstantForce;



}
declare const ConstantForce: ConstantForceConstructor;
    
interface PhysicsUpdateBehaviour2D extends Behaviour {





}
    
interface PhysicsUpdateBehaviour2DConstructor {


    new(): PhysicsUpdateBehaviour2D;



}
declare const PhysicsUpdateBehaviour2D: PhysicsUpdateBehaviour2DConstructor;
    
interface ConstantForce2D extends PhysicsUpdateBehaviour2D {
    force: Vector2;
    relativeForce: Vector2;
    torque: number;





}
    
interface ConstantForce2DConstructor {


    new(): ConstantForce2D;



}
declare const ConstantForce2D: ConstantForce2DConstructor;
    
interface FixedJoint extends Joint {





}
    
interface FixedJointConstructor {


    new(): FixedJoint;



}
declare const FixedJoint: FixedJointConstructor;
    
interface MoveInputData {
    moveDir: Vector3;
    jump: boolean;
    crouch: boolean;
    sprint: boolean;
    lookVector: Vector3;
    customData: BinaryBlob;



    Dispose(): void;
    GetTick(): number;
    SetTick(value: number): void;


}
    
interface MoveInputDataConstructor {


    new(moveDir: Vector3, jump: boolean, crouch: boolean, sprint: boolean, lookVector: Vector3, customData: BinaryBlob): MoveInputData;


    CompareBinaryBlobs(a: BinaryBlob, b: BinaryBlob): boolean;

}
declare const MoveInputData: MoveInputDataConstructor;
    
interface GridLayout extends Behaviour {
    readonly cellSize: Vector3;
    readonly cellGap: Vector3;
    readonly cellLayout: CellLayout;
    readonly cellSwizzle: CellSwizzle;



    CellToLocal(cellPosition: Vector3): Vector3;
    CellToLocalInterpolated(cellPosition: Vector3): Vector3;
    CellToWorld(cellPosition: Vector3): Vector3;
    GetBoundsLocal(cellPosition: Vector3): Bounds;
    GetBoundsLocal(origin: Vector3, size: Vector3): Bounds;
    GetLayoutCellCenter(): Vector3;
    LocalToCell(localPosition: Vector3): Vector3;
    LocalToCellInterpolated(localPosition: Vector3): Vector3;
    LocalToWorld(localPosition: Vector3): Vector3;
    WorldToCell(worldPosition: Vector3): Vector3;
    WorldToLocal(worldPosition: Vector3): Vector3;


}
    
interface GridLayoutConstructor {


    new(): GridLayout;



}
declare const GridLayout: GridLayoutConstructor;
    
interface Grid extends GridLayout {
    cellSize: Vector3;
    cellGap: Vector3;
    cellLayout: CellLayout;
    cellSwizzle: CellSwizzle;



    GetCellCenterLocal(position: Vector3): Vector3;
    GetCellCenterWorld(position: Vector3): Vector3;


}
    
interface GridConstructor {


    new(): Grid;


    InverseSwizzle(swizzle: CellSwizzle, position: Vector3): Vector3;
    Swizzle(swizzle: CellSwizzle, position: Vector3): Vector3;

}
declare const Grid: GridConstructor;
    
interface UIScrollRectEventBubbler extends MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IScrollHandler {
    Bubble: boolean;
    DisableEventTriggerWhileDragging: boolean;
    DisableDragEvents: boolean;
    readonly EventTrigger: EventTrigger;



    OnBeginDrag(eventData: PointerEventData): void;
    OnDisable(): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;


}
    
interface UIScrollRectEventBubblerConstructor {


    new(): UIScrollRectEventBubbler;



}
declare const UIScrollRectEventBubbler: UIScrollRectEventBubblerConstructor;
    
interface VisualEffect extends Behaviour {
    outputEventReceived: unknown;
    pause: boolean;
    playRate: number;
    startSeed: number;
    resetSeedOnPlay: boolean;
    initialEventID: number;
    initialEventName: string;
    readonly culled: boolean;
    visualEffectAsset: VisualEffectAsset;
    readonly aliveParticleCount: number;



    AdvanceOneFrame(): void;
    CreateVFXEventAttribute(): VFXEventAttribute;
    GetAnimationCurve(nameID: number): AnimationCurve;
    GetAnimationCurve(name: string): AnimationCurve;
    GetBool(nameID: number): boolean;
    GetBool(name: string): boolean;
    GetFloat(nameID: number): number;
    GetFloat(name: string): number;
    GetGradient(nameID: number): Gradient;
    GetGradient(name: string): Gradient;
    GetInt(nameID: number): number;
    GetInt(name: string): number;
    GetMatrix4x4(nameID: number): Matrix4x4;
    GetMatrix4x4(name: string): Matrix4x4;
    GetMesh(nameID: number): Mesh;
    GetMesh(name: string): Mesh;
    GetOutputEventNames(names: CSArray<string>): void;
    GetParticleSystemInfo(nameID: number): VFXParticleSystemInfo;
    GetParticleSystemInfo(name: string): VFXParticleSystemInfo;
    GetParticleSystemNames(names: CSArray<string>): void;
    GetSkinnedMeshRenderer(nameID: number): SkinnedMeshRenderer;
    GetSkinnedMeshRenderer(name: string): SkinnedMeshRenderer;
    GetSpawnSystemInfo(nameID: number, spawnState: VFXSpawnerState): void;
    GetSpawnSystemInfo(nameID: number): VFXSpawnerState;
    GetSpawnSystemInfo(name: string): VFXSpawnerState;
    GetSpawnSystemNames(names: CSArray<string>): void;
    GetSystemNames(names: CSArray<string>): void;
    GetTexture(nameID: number): Texture;
    GetTexture(name: string): Texture;
    GetTextureDimension(nameID: number): TextureDimension;
    GetTextureDimension(name: string): TextureDimension;
    GetUInt(nameID: number): number;
    GetUInt(name: string): number;
    GetVector2(nameID: number): Vector2;
    GetVector2(name: string): Vector2;
    GetVector3(nameID: number): Vector3;
    GetVector3(name: string): Vector3;
    GetVector4(nameID: number): Vector4;
    GetVector4(name: string): Vector4;
    HasAnimationCurve(nameID: number): boolean;
    HasAnimationCurve(name: string): boolean;
    HasAnySystemAwake(): boolean;
    HasBool(nameID: number): boolean;
    HasBool(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasGradient(nameID: number): boolean;
    HasGradient(name: string): boolean;
    HasGraphicsBuffer(nameID: number): boolean;
    HasGraphicsBuffer(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasMatrix4x4(nameID: number): boolean;
    HasMatrix4x4(name: string): boolean;
    HasMesh(nameID: number): boolean;
    HasMesh(name: string): boolean;
    HasSkinnedMeshRenderer(nameID: number): boolean;
    HasSkinnedMeshRenderer(name: string): boolean;
    HasSystem(nameID: number): boolean;
    HasSystem(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasTexture(name: string): boolean;
    HasUInt(nameID: number): boolean;
    HasUInt(name: string): boolean;
    HasVector2(nameID: number): boolean;
    HasVector2(name: string): boolean;
    HasVector3(nameID: number): boolean;
    HasVector3(name: string): boolean;
    HasVector4(nameID: number): boolean;
    HasVector4(name: string): boolean;
    Play(eventAttribute: VFXEventAttribute): void;
    Play(): void;
    Reinit(): void;
    ResetOverride(nameID: number): void;
    ResetOverride(name: string): void;
    SendEvent(eventNameID: number, eventAttribute: VFXEventAttribute): void;
    SendEvent(eventName: string, eventAttribute: VFXEventAttribute): void;
    SendEvent(eventNameID: number): void;
    SendEvent(eventName: string): void;
    SetAnimationCurve(nameID: number, c: AnimationCurve): void;
    SetAnimationCurve(name: string, c: AnimationCurve): void;
    SetBool(nameID: number, b: boolean): void;
    SetBool(name: string, b: boolean): void;
    SetFloat(nameID: number, f: number): void;
    SetFloat(name: string, f: number): void;
    SetGradient(nameID: number, g: Gradient): void;
    SetGradient(name: string, g: Gradient): void;
    SetGraphicsBuffer(nameID: number, g: GraphicsBuffer): void;
    SetGraphicsBuffer(name: string, g: GraphicsBuffer): void;
    SetInt(nameID: number, i: number): void;
    SetInt(name: string, i: number): void;
    SetMatrix4x4(nameID: number, v: Matrix4x4): void;
    SetMatrix4x4(name: string, v: Matrix4x4): void;
    SetMesh(nameID: number, m: Mesh): void;
    SetMesh(name: string, m: Mesh): void;
    SetSkinnedMeshRenderer(nameID: number, m: SkinnedMeshRenderer): void;
    SetSkinnedMeshRenderer(name: string, m: SkinnedMeshRenderer): void;
    SetTexture(nameID: number, t: Texture): void;
    SetTexture(name: string, t: Texture): void;
    SetUInt(nameID: number, i: number): void;
    SetUInt(name: string, i: number): void;
    SetVector2(nameID: number, v: Vector2): void;
    SetVector2(name: string, v: Vector2): void;
    SetVector3(nameID: number, v: Vector3): void;
    SetVector3(name: string, v: Vector3): void;
    SetVector4(nameID: number, v: Vector4): void;
    SetVector4(name: string, v: Vector4): void;
    Simulate(stepDeltaTime: number, stepCount: number): void;
    Stop(eventAttribute: VFXEventAttribute): void;
    Stop(): void;


}
    
interface VisualEffectObject extends Object {





}
    
interface VisualEffectAsset extends VisualEffectObject {



    GetEvents(names: CSArray<string>): void;
    GetExposedProperties(exposedProperties: CSArray<VFXExposedProperty>): void;
    GetExposedSpace(nameID: number): VFXSpace;
    GetExposedSpace(name: string): VFXSpace;
    GetTextureDimension(nameID: number): TextureDimension;
    GetTextureDimension(name: string): TextureDimension;


}
    
interface VFXExposedProperty {
    name: string;
    type: unknown;





}
    
interface VisualEffectAssetConstructor {
    PlayEventName: string;
    StopEventName: string;
    readonly PlayEventID: number;
    readonly StopEventID: number;


    new(): VisualEffectAsset;



}
declare const VisualEffectAsset: VisualEffectAssetConstructor;
    
interface VFXEventAttribute {



    CopyValuesFrom(eventAttibute: VFXEventAttribute): void;
    Dispose(): void;
    GetBool(nameID: number): boolean;
    GetBool(name: string): boolean;
    GetFloat(nameID: number): number;
    GetFloat(name: string): number;
    GetInt(nameID: number): number;
    GetInt(name: string): number;
    GetMatrix4x4(nameID: number): Matrix4x4;
    GetMatrix4x4(name: string): Matrix4x4;
    GetUint(nameID: number): number;
    GetUint(name: string): number;
    GetVector2(nameID: number): Vector2;
    GetVector2(name: string): Vector2;
    GetVector3(nameID: number): Vector3;
    GetVector3(name: string): Vector3;
    GetVector4(nameID: number): Vector4;
    GetVector4(name: string): Vector4;
    HasBool(nameID: number): boolean;
    HasBool(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasMatrix4x4(nameID: number): boolean;
    HasMatrix4x4(name: string): boolean;
    HasUint(nameID: number): boolean;
    HasUint(name: string): boolean;
    HasVector2(nameID: number): boolean;
    HasVector2(name: string): boolean;
    HasVector3(nameID: number): boolean;
    HasVector3(name: string): boolean;
    HasVector4(nameID: number): boolean;
    HasVector4(name: string): boolean;
    SetBool(nameID: number, b: boolean): void;
    SetBool(name: string, b: boolean): void;
    SetFloat(nameID: number, f: number): void;
    SetFloat(name: string, f: number): void;
    SetInt(nameID: number, i: number): void;
    SetInt(name: string, i: number): void;
    SetMatrix4x4(nameID: number, v: Matrix4x4): void;
    SetMatrix4x4(name: string, v: Matrix4x4): void;
    SetUint(nameID: number, i: number): void;
    SetUint(name: string, i: number): void;
    SetVector2(nameID: number, v: Vector2): void;
    SetVector2(name: string, v: Vector2): void;
    SetVector3(nameID: number, v: Vector3): void;
    SetVector3(name: string, v: Vector3): void;
    SetVector4(nameID: number, v: Vector4): void;
    SetVector4(name: string, v: Vector4): void;


}
    
interface VFXEventAttributeConstructor {


    new(original: VFXEventAttribute): VFXEventAttribute;



}
declare const VFXEventAttribute: VFXEventAttributeConstructor;
    
interface VFXParticleSystemInfo {
    aliveCount: number;
    capacity: number;
    sleeping: boolean;
    bounds: Bounds;





}
    
interface VFXParticleSystemInfoConstructor {


    new(aliveCount: number, capacity: number, sleeping: boolean, bounds: Bounds): VFXParticleSystemInfo;



}
declare const VFXParticleSystemInfo: VFXParticleSystemInfoConstructor;
    
interface VFXSpawnerState {
    playing: boolean;
    readonly newLoop: boolean;
    loopState: VFXSpawnerLoopState;
    spawnCount: number;
    deltaTime: number;
    totalTime: number;
    delayBeforeLoop: number;
    loopDuration: number;
    delayAfterLoop: number;
    loopIndex: number;
    loopCount: number;
    readonly vfxEventAttribute: VFXEventAttribute;



    Dispose(): void;


}
    
interface VFXSpawnerStateConstructor {


    new(): VFXSpawnerState;



}
declare const VFXSpawnerState: VFXSpawnerStateConstructor;
    
interface VisualEffectConstructor {


    new(): VisualEffect;



}
declare const VisualEffect: VisualEffectConstructor;
    
interface AnimationEventData extends ScriptableObject {
    key: string;
    stringValue: string;
    intValue: number;
    floatValue: number;





}
    
interface AnimationEventDataConstructor {


    new(): AnimationEventData;



}
declare const AnimationEventData: AnimationEventDataConstructor;
    
interface VoxelWorld extends MonoBehaviour {
    doVisuals: boolean;
    debugReloadOnScriptReloadMode: boolean;
    focusPosition: Vector3;
    autoLoad: boolean;
    voxelWorldFile: WorldSaveFile;
    worldNetworker: VoxelWorldNetworker;
    chunksFolder: GameObject;
    lightsFolder: GameObject;
    finishedReplicatingChunksFromServer: boolean;
    chunks: CSDictionary<Vector3, Chunk>;
    lodNearDistance: number;
    lodFarDistance: number;
    lodTransitionSpeed: number;
    voxelBlocks: VoxelBlocks;
    selectedBlockIndex: number;
    highlightedBlock: number;
    highlightedBlockPos: Vector3;
    currentCamera: Camera;
    mirrorAround: Vector3;
    renderingDisabled: boolean;
    hasUnsavedChanges: boolean;
    loadingStatus: LoadingStatus;

    readonly BeforeVoxelChunkUpdated: MonoSignal<Chunk>;
    readonly VoxelChunkUpdated: MonoSignal<Chunk>;
    readonly BeforeVoxelPlaced: MonoSignal<number, Vector3>;
    readonly VoxelPlaced: MonoSignal<unknown, unknown, unknown, unknown>;
    readonly OnFinishedLoading: MonoSignal<void>;
    readonly OnFinishedReplicatingChunksFromServer: MonoSignal<void>;


    AddChunk(key: Vector3, chunk: Chunk): void;
    BulkReadVoxels(positions: CSArray<Vector3>): CSArray<number>;
    CalculatePlaneIntersection(origin: Vector3, dir: Vector3, planeNormal: Vector3, planePoint: Vector3): Vector3;
    CanSeePoint(pos: Vector3, dest: Vector3, destNormal: Vector3): boolean;
    ColorVoxelAt(pos: Vector3, color: Color, priority: boolean): void;
    CreateSingleStarterBlock(): void;
    DamageVoxelAt(pos: Vector3, damage: number, priority: boolean): void;
    DeleteRenderedGameObjects(): void;
    DirtyMesh(voxel: Vector3, priority: boolean): void;
    DirtyNeighborMeshes(voxel: Vector3, priority: boolean): void;
    FillRandomTerrain(): void;
    FillSingleBlock(): void;
    FullWorldUpdate(): void;
    GenerateWorld(populateTerrain: boolean): void;
    GetChunkByChunkPos(pos: Vector3): Chunk;
    GetCollisionType(voxelData: number): CollisionType;
    GetNumProcessingMeshChunks(): number;
    GetNumRadiosityProcessingChunks(): number;
    GetPrefabAt(pos: Vector3): GameObject;
    GetVoxelAndChunkAt(pos: Vector3): unknown;
    GetVoxelAt(pos: Vector3): number;
    GetVoxelColorAt(pos: Vector3): Color32;
    InvokeOnFinishedReplicatingChunksFromServer(): void;
    LoadEmptyWorld(): void;
    LoadWorldFromSaveFile(file: WorldSaveFile): void;
    OnRenderObject(): void;
    RaycastVoxel(pos: Vector3, direction: Vector3, maxDistance: number): VoxelRaycastResult;
    RaycastVoxel_Internal(pos: Vector3, direction: Vector3, maxDistance: number, debug: boolean): unknown;
    RaycastVoxelForLighting(pos: Vector3, direction: Vector3, maxDistance: number, debug: boolean): number;
    ReadVoxelAt(pos: Vector3): number;
    RegenerateAllMeshes(): void;
    ReloadTextureAtlas(): void;
    SaveToDomainReloadFile(): void;
    SaveToFile(): void;
    SpawnDebugSphere(pos: Vector3, col: Color, radius: number): GameObject;
    TransformPointToLocalSpace(point: Vector3): Vector3;
    TransformPointToWorldSpace(point: Vector3): Vector3;
    TransformRayToLocalSpace(ray: Ray): Ray;
    TransformVectorToLocalSpace(vec: Vector3): Vector3;
    TransformVectorToWorldSpace(vec: Vector3): Vector3;
    Update(): void;
    WriteVoxelAt(pos: Vector3, num: number, priority: boolean): void;
    WriteVoxelGroupAt(positions: CSArray<Vector3>, nums: CSArray<number>, priority: boolean): void;
    WriteVoxelGroupAtTS(blob: unknown, priority: boolean): void;


}
    
interface WorldSaveFile extends ScriptableObject {
    chunks: CSArray<SaveChunk>;
    blockIdToScopeName: CSArray<BlockIdToScopedName>;



    CreateFromVoxelWorld(world: VoxelWorld): void;
    GetChunks(): CSArray<SaveChunk>;
    GetFileBlockIdFromStringId(blockTypeId: string): number;
    GetFileScopedBlockTypeId(fileBlockId: number): string;
    LoadIntoVoxelWorld(world: VoxelWorld): void;


}
    
interface SaveChunk {
    key: Vector3;
    data: CSArray<number>;
    color: CSArray<number>;





}
    
interface SaveChunkConstructor {


    new(key: Vector3, data: CSArray<number>, color: CSArray<number>): SaveChunk;



}
declare const SaveChunk: SaveChunkConstructor;
    
interface BlockIdToScopedName {
    id: number;
    name: string;





}
    
interface WorldSaveFileConstructor {


    new(): WorldSaveFile;



}
declare const WorldSaveFile: WorldSaveFileConstructor;
    
interface VoxelWorldNetworker extends NetworkBehaviour {
    world: VoxelWorld;
    networkWriteVoxels: boolean;



    OnReadyCommand(connection: NetworkConnectionToClient): void;
    OnStartClient(): void;
    TargetFinishedSendingWorldRpc(conn: NetworkConnection): void;
    TargetWriteChunksRpc(conn: NetworkConnection, positions: CSArray<Vector3>, chunks: CSArray<Chunk>): void;
    TargetWriteVoxelGroupRpc(conn: NetworkConnection, positions: CSArray<Vector3>, nums: CSArray<number>, priority: boolean): void;
    TargetWriteVoxelRpc(conn: NetworkConnection, pos: Vector3, voxel: number): void;
    Weaved(): boolean;


}
    
interface Chunk {
    readWriteVoxel: CSArray<number>;
    color: CSArray<number>;
    damageMap: CSDictionary<number, number>;
    materialPropertiesDirty: boolean;
    world: VoxelWorld;
    bottomLeftInt: Vector3;
    bounds: Bounds;
    numUpdates: number;
    currentCamera: Camera;
    colliders: CSArray<BoxCollider>;
    chunkKey: Vector3;



    Busy(): boolean;
    Clear(): void;
    Free(): void;
    GetGameObject(): GameObject;
    GetKey(): Vector3;
    GetLocalColorAt(localX: number, localY: number, localZ: number): Color32;
    GetLocalVoxelAt(localPos: Vector3): number;
    GetLocalVoxelAt(localX: number, localY: number, localZ: number): number;
    GetPrefabAt(worldPos: Vector3): GameObject;
    GetPriorityUpdate(): boolean;
    GetVoxelAt(worldPos: Vector3): number;
    GetVoxelColorAt(worldPos: Vector3): Color32;
    HasVoxels(): boolean;
    IsGeometryDirty(): boolean;
    MainthreadForceCollisionRebuild(): void;
    MainthreadUpdateMesh(world: VoxelWorld): boolean;
    NeedsToCopyMeshToScene(): boolean;
    NeedsToGenerateMesh(): boolean;
    SetGeometryDirty(dirty: boolean, priority: boolean): void;
    SetWorld(world: VoxelWorld): void;
    WriteVoxel(worldPos: Vector3, num: number): void;
    WriteVoxelColor(worldPos: Vector3, col: Color32): void;
    WriteVoxelDamage(worldPos: Vector3, dmg: number): void;


}
    
interface ChunkConstructor {


    new(): Chunk;


    TestAABBSphere(aabb: Bounds, sphereCenter: Vector3, sphereRadius: number): boolean;
    WorldPosToLocalPos(globalCoord: Vector3): Vector3;
    WorldPosToLocalPos(globalCoord: Vector3): Vector3;
    WorldPosToVoxelIndex(globalCoord: Vector3): number;

}
declare const Chunk: ChunkConstructor;
    
interface VoxelWorldNetworkerConstructor {


    new(): VoxelWorldNetworker;



}
declare const VoxelWorldNetworker: VoxelWorldNetworkerConstructor;
    
interface VoxelRaycastResult {
    Hit: boolean;
    Distance: number;
    HitPosition: Vector3;
    HitNormal: Vector3;





}
    
interface VoxelWorldConstructor {
    runThreaded: boolean;
    maxActiveThreads: number;
    maxMainThreadMeshMillisecondsPerFrame: number;
    maxMainThreadThreadKickoffMillisecondsPerFrame: number;
    showDebugSpheres: boolean;
    showDebugBounds: boolean;
    chunkSize: number;
    flipNames: CSArray<string>;
    allFlips: CSArray<number>;


    new(): VoxelWorld;


    Abs(input: Vector3): Vector3;
    CardinalVector(normal: Vector3): Vector3;
    CreateChunk(key: Vector3): Chunk;
    DeleteChildGameObjects(parent: GameObject): void;
    FlipBitsToQuaternion(flipBits: number): Quaternion;
    Floor(input: Vector3): Vector3;
    FloorInt(input: Vector3): Vector3;
    GetFirstInstance(): VoxelWorld;
    GetVoxelFlippedBits(voxel: number): number;
    HashCoordinates(x: number, y: number, z: number): number;
    SetVoxelFlippedBits(voxel: number, flippedBits: number): number;
    SetVoxelSolidBit(voxel: number, solid: boolean): number;
    Sign(input: Vector3): Vector3;
    VoxelDataToBlockId(block: number): number;
    VoxelDataToBlockId(block: number): number;
    VoxelDataToExtraBits(block: number): number;
    VoxelIsSolid(voxel: number): boolean;

}
declare const VoxelWorld: VoxelWorldConstructor;
    
interface AccessorySkin extends ScriptableObject {
    skinTextureDiffuse: Texture2D;
    skinTextureNormal: Texture2D;
    skinTextureORM: Texture2D;
    faceTextureDiffuse: Texture2D;



    ToString(): string;


}
    
interface AccessorySkinConstructor {


    new(): AccessorySkin;



}
declare const AccessorySkin: AccessorySkinConstructor;
    
interface ActiveAccessory {
    AccessoryComponent: AccessoryComponent;
    rootTransform: Transform;
    gameObjects: CSArray<GameObject>;
    renderers: CSArray<Renderer>;





}
    
interface AirshipSteamFriendInfo {
    playingAirship: boolean;
    steamId: number;
    steamName: string;





}

