import { RojoResolver } from "@easy-games/unity-rojo-resolver";
import ts from "typescript";
import { CallMacro } from "../transformations/macros/macro";
import { ClassInfo } from "../types/classes";
import { GenericIdOptions } from "../util/functions/getGenericIdMap";
import { BuildInfo } from "./buildInfo";
import { PathTranslator } from "./pathTranslator";
import { SymbolProvider } from "./symbolProvider";
export interface TransformerConfig {
    /**
     * An internal option that should not be used.
     * This is used to compile the framework package, turning this on in your game will cause many errors.
     */
    $rbxpackmode$?: boolean;
    /**
     * Disables TypeScript's own semantic diagnostics.
     * Improves performance, but results in increased risk of incorrect compilation as well as messed up diagnostic spans.
     */
    noSemanticDiagnostics?: boolean;
    /**
     * This is the salt used for hashes generated by Flamework.
     * Defaults to a randomly generated 64 byte salt.
     */
    salt?: string;
    /**
     * This can be used to lower collision chance with packages.
     * Defaults to package name.
     */
    hashPrefix?: string;
    /**
     * Whether to automatically generate the identifiers for exports.
     * This is recommended for packages but it is not recommended to
     * enable this in games.
     */
    preloadIds?: boolean;
    /**
     * Whether to enable flamework's obfuscation.
     *
     * This comprises of:
     * 1. random event names
     * 2. shortened ids
     */
    obfuscation?: boolean;
    /**
     * Determines the id generation mode.
     * Defaults to "full" and should only be configured in game projects.
     */
    idGenerationMode?: "full" | "short" | "tiny" | "obfuscated";
}
export declare class TransformState {
    program: ts.Program;
    context: ts.TransformationContext;
    config: TransformerConfig;
    private parsedCommandLine;
    currentDirectory: string;
    options: ts.CompilerOptions;
    srcDir: string;
    outDir: string;
    rootDirs: string[];
    typeChecker: ts.TypeChecker;
    symbolProvider: SymbolProvider;
    classes: Map<ts.Symbol, ClassInfo>;
    rojoResolver?: RojoResolver;
    pathTranslator: PathTranslator;
    buildInfo: BuildInfo;
    rootDirectory: string;
    packageName: string;
    isGame: boolean;
    callMacros: Map<ts.Symbol, CallMacro>;
    genericIdMap?: Map<ts.Symbol, GenericIdOptions>;
    inferExpressions: Map<ts.SourceFile, ts.Identifier>;
    isUserMacroCache: Map<ts.Symbol, boolean>;
    private setupBuildInfo;
    private setupRojo;
    constructor(program: ts.Program, context: ts.TransformationContext, config: TransformerConfig);
    isUserMacro(symbol: ts.Symbol): boolean;
    private areMacrosSetup;
    setupMacros(): void;
    fileImports: Map<string, ImportInfo[]>;
    addFileImport(file: ts.SourceFile, importPath: string, name: string): ts.Identifier;
    getSourceFile(node: ts.Node): ts.SourceFile;
    getSymbol(node: ts.Node, followAlias?: boolean): ts.Symbol | undefined;
    hash(id: number, noPrefix?: boolean): string;
    obfuscateText(text: string, context?: string): string;
    hasErrors: boolean;
    addDiagnostic(diag: ts.DiagnosticWithLocation): void;
    hoistedToTop: Map<ts.SourceFile, ts.Statement[]>;
    hoistToTop(file: ts.SourceFile, node: ts.Statement): void;
    private prereqStack;
    capture<T>(cb: () => T): [T, ts.Statement[]];
    prereq(statement: ts.Statement): void;
    prereqList(statements: ts.Statement[]): void;
    isCapturing(threshold?: number): boolean;
    transform<T extends ts.Node>(node: T): T;
    transformNode<T extends ts.Node>(node: T): T;
    transformList<T extends ts.Node>(nodes: ts.NodeArray<T>): ts.NodeArray<T>;
    private _shouldViewFile;
    shouldViewFile(file: ts.SourceFile): boolean;
}
interface ImportItem {
    name: string;
    identifier: ts.Identifier;
}
interface ImportInfo {
    path: string;
    entries: Array<ImportItem>;
}
export {};
