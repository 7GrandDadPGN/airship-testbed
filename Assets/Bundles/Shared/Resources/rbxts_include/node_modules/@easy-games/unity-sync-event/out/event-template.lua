-- Compiled with unity-ts v2.1.0-57
local SyncEventConfig = require("./sync-event-config").SyncEventConfig
local EventConnection
do
	EventConnection = setmetatable({}, {
		__tostring = function()
			return "EventConnection"
		end,
	})
	EventConnection.__index = EventConnection
	function EventConnection.new(...)
		local self = setmetatable({}, EventConnection)
		return self:constructor(...) or self
	end
	function EventConnection:constructor(destroyFunction)
		self.destroyFunction = destroyFunction
	end
	function EventConnection:Destroy()
		self.destroyFunction()
	end
end
local EventTemplate
do
	EventTemplate = {}
	function EventTemplate:constructor(eventClass, pcallCallbacks)
		if pcallCallbacks == nil then
			pcallCallbacks = true
		end
		self.eventClass = eventClass
		self.pcallCallbacks = pcallCallbacks
	end
	function EventTemplate:constructEvent(params)
		local maxIndex = 0
		for index, elem in pairs(params) do
			maxIndex = math.max(index, maxIndex)
		end
		local undefinedString = "__UNDEFINED_EVENT_PARAMETER"
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < maxIndex) then
					break
				end
				if params[i + 1] == nil then
					params[i + 1] = undefinedString
				end
			end
		end
		local obj = self.eventClass.new(unpack(params))
		for title, val in pairs(obj) do
			if val == undefinedString then
				-- -1 because Roblox-TS adds one to index.
				obj[title] = nil
			end
		end
		return obj
	end
	function EventTemplate:wrapCallback(threadInfo, callback)
		local callWrapper = function(callback)
			return callback()
		end
		if self.pcallCallbacks then
			callWrapper = function(callback)
				xpcall(function()
					callback()
				end, function(err)
					-- warn(debug.traceback(err as string, 3));
					warn(err)
				end)
			end
		end
		-- Used to make sure event doesn't last for a long time (or log if it does)
		local finishedExecuting = false
		-- if (SyncEventConfig.INFINITE_YIELD_ALERT > 0) {
		-- task.delay(SyncEventConfig.INFINITE_YIELD_ALERT, () => {
		-- if (!finishedExecuting) {
		-- warn(
		-- this.formatLogs(
		-- `Infinite yield warning! Callback running for over ${SyncEventConfig.INFINITE_YIELD_ALERT} seconds:`,
		-- ),
		-- );
		-- warn(this.formatLogs(`${threadInfo}`));
		-- }
		-- });
		-- }
		local startTime = os.clock()
		local yielded = false
		if SyncEventConfig.DEBUG_YIELDING_CALLBACK then
			task.spawn(function()
				task.wait()
				yielded = true
			end)
		end
		callWrapper(callback)
		-- Debug logging/cleanup
		finishedExecuting = true
		if yielded then
			print(self:formatLogs("Callback yielded!"))
			print(self:formatLogs(threadInfo))
		end
		if SyncEventConfig.DEBUG_CALLBACK_TIME_THRESHOLD >= 0 and SyncEventConfig.DEBUG_CALLBACK_TIME_THRESHOLD < os.clock() - startTime then
			print(self:formatLogs("Callback lasted for " .. (tostring(os.clock() - startTime) .. ":")))
			print(self:formatLogs(threadInfo))
		end
	end
	function EventTemplate:getCallingThreadInfo(additionalLevels)
		if additionalLevels == nil then
			additionalLevels = 0
		end
		local info = { debug.info(coroutine.running(), 3 + additionalLevels, "sl") }
		return info[1] .. (":" .. tostring(info[2]))
	end
	function EventTemplate:formatLogs(message)
		return "[SYNC-EVENT][" .. (tostring(self.eventClass) .. ("] " .. message))
	end
end
return {
	EventConnection = EventConnection,
	EventTemplate = EventTemplate,
}
-- ----------------------------------
-- ----------------------------------
